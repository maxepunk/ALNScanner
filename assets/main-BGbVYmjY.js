(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const a of n)if(a.type==="childList")for(const o of a.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function t(n){const a={};return n.integrity&&(a.integrity=n.integrity),n.referrerPolicy&&(a.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?a.credentials="include":n.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(n){if(n.ep)return;n.ep=!0;const a=t(n);fetch(n.href,a)}})();const B={MAX_TEAM_ID_LENGTH:6,MAX_DEBUG_MESSAGES:50,ANIMATION_DURATION:200,MODE_TOGGLE_SCALE:1.1,SCAN_SIMULATION_DELAY:1e3,NFC_PULSE_INTERVAL:2e3};class W{constructor(){this.messages=[]}log(e,t=!1){const a=`[${new Date().toLocaleTimeString()}] ${t?"‚ùå":"‚úì"} ${e}`;this.messages.push(a),this.messages.length>B.MAX_DEBUG_MESSAGES&&this.messages.shift(),this.updatePanel(),t?console.error(e):console.log(e)}updatePanel(e=null){const t=document.getElementById("debugContent");t&&(t.textContent=this.messages.join(`
`),e?.viewController?.currentView==="debug"&&(t.scrollTop=t.scrollHeight))}toggle(e=null){e?.viewController?e.viewController.currentView==="debug"?e.viewController.switchView("scanner"):e.viewController.switchView("debug"):console.warn("Debug view not available in this mode")}clear(){this.messages=[],this.updatePanel()}}const d=new W;let V=class{constructor({settings:e,dataManager:t,sessionModeManager:s,app:n}={}){this.settings=e,this.dataManager=t,this.sessionModeManager=s,this.app=n,this.screens={},this.previousScreen=null,this.errorContainer=null}init(){this.screens={loading:document.getElementById("loadingScreen"),settings:document.getElementById("settingsScreen"),gameModeScreen:document.getElementById("gameModeScreen"),teamEntry:document.getElementById("teamEntryScreen"),scan:document.getElementById("scanScreen"),result:document.getElementById("resultScreen"),history:document.getElementById("historyScreen"),scoreboard:document.getElementById("scoreboardScreen"),teamDetails:document.getElementById("teamDetailsScreen")},this.initErrorDisplay()}initErrorDisplay(){if(!document.getElementById("error-container")){const e=document.createElement("div");e.id="error-container",e.className="error-container",document.body.appendChild(e)}this.errorContainer=document.getElementById("error-container")}showError(e,t=5e3){this.errorContainer||this.initErrorDisplay();const s=document.createElement("div");s.className="error-message",s.textContent=e,this.errorContainer.appendChild(s),setTimeout(()=>{s.style.animation="slideOut 0.3s ease-out forwards",setTimeout(()=>s.remove(),300)},t)}showToast(e,t="info",s=3e3){this.errorContainer||this.initErrorDisplay();const n=document.createElement("div");n.className=`toast toast-${t}`,n.textContent=e,this.errorContainer.appendChild(n),setTimeout(()=>{n.style.animation="slideOut 0.3s ease-out forwards",setTimeout(()=>n.remove(),300)},s)}showScreen(e){const t=document.querySelector(".screen.active");t&&t.id!=="historyScreen"&&t.id!=="scoreboardScreen"&&t.id!=="teamDetailsScreen"&&t.id!=="gameModeScreen"&&t.id!=="loadingScreen"&&e!=="history"&&e!=="scoreboard"&&e!=="teamDetails"&&(this.previousScreen=t.id.replace("Screen","")),Object.values(this.screens).forEach(s=>{s&&s.classList.remove("active")}),this.screens[e]&&this.screens[e].classList.add("active"),e==="teamEntry"&&this.app?.initTeamEntryUI&&this.app.initTeamEntryUI(),e==="scoreboard"&&this.renderScoreboard(),e==="result"&&this._enableResultScreenQuickDismiss()}_enableResultScreenQuickDismiss(){const e=this.screens.result;if(!e)return;const t=s=>{s.target.closest("button")||(e.removeEventListener("click",t),this.showScreen("scan"))};e._quickDismissHandler&&e.removeEventListener("click",e._quickDismissHandler),e._quickDismissHandler=t,e.addEventListener("click",t)}updateModeDisplay(e){const t=document.getElementById("modeIndicator"),s=document.getElementById("modeText"),n=document.getElementById("modeToggle");t&&(e==="blackmarket"?(t.className="mode-indicator mode-blackmarket",t.textContent="Black Market Mode",s&&(s.textContent="Black Market Mode"),n&&(n.checked=!0)):(t.className="mode-indicator mode-detective",t.textContent="Detective Mode",s&&(s.textContent="Detective Mode"),n&&(n.checked=!1)),this.updateNavigationButtons())}updateNavigationButtons(){const e=document.getElementById("scoreboardButton");e&&this.settings&&(e.style.display=this.settings.mode==="blackmarket"?"block":"none")}updateTeamDisplay(e){const t=document.getElementById("teamDisplay");t&&(t.textContent=e||"_")}updateSessionStats(){const e=this.dataManager;if(!e||!this.settings)return;const t=e.getSessionStats(),s=document.getElementById("teamTokenCount"),n=document.getElementById("teamTotalValue"),a=document.getElementById("teamValueLabel");s&&(s.textContent=t.count),n&&(this.settings.mode==="blackmarket"?(n.textContent=`$${t.totalScore.toLocaleString()}`,a&&(a.textContent="Score")):(n.textContent=t.totalValue,a&&(a.textContent="Total Value")))}updateHistoryBadge(){const e=this.dataManager;if(!e)return;const t=document.getElementById("historyBadge");if(!t)return;if(!e.getActiveStrategyType()){t.style.display="none";return}const s=e.getTransactions().length;s>0?(t.textContent=s,t.style.display="inline"):t.style.display="none"}updateHistoryStats(){const e=this.dataManager;if(!e)return;const t=e.getGlobalStats(),s=document.getElementById("totalScans"),n=document.getElementById("uniqueTeams"),a=document.getElementById("totalValue"),o=document.getElementById("avgValue");s&&(s.textContent=t.total),n&&(n.textContent=t.teams),a&&(a.textContent=t.totalValue),o&&(o.textContent=t.avgValue)}renderScoreboard(e=null){const t=this.dataManager;if(!t||!this.app)return;const s=e||document.getElementById("scoreboardContainer");if(!s)return;const n=t.getTeamScores();if(n.length===0){s.innerHTML=`
        <div class="empty-state">
          <h3>No Teams Yet</h3>
          <p>Teams will appear here after scanning tokens</p>
        </div>
      `;return}const a=n[0]?.isFromBackend?'<div class="score-source" style="text-align: center; margin: 10px 0; padding: 10px; background: rgba(103,126,234,0.1); border-radius: 8px; font-size: 14px;">üîó Live from Orchestrator</div>':'<div class="score-source" style="text-align: center; margin: 10px 0; padding: 10px; background: rgba(255,152,0,0.1); border-radius: 8px; font-size: 14px;">üì± Local Calculation</div>';s.innerHTML=a+n.map((o,i)=>{const r=i+1,u=r<=3?`rank-${r}`:"",l=r===1?"ü•á":r===2?"ü•à":r===3?"ü•â":`#${r}`;return`
        <div class="scoreboard-entry ${u}" data-action="app.showTeamDetails" data-arg="${o.teamId}" style="cursor: pointer;">
          <div class="scoreboard-rank">${l}</div>
          <div class="scoreboard-team">
            Team ${o.teamId}
            <span class="scoreboard-tokens">(${o.tokenCount} tokens)</span>
          </div>
          <div class="scoreboard-score">$${o.score.toLocaleString()}</div>
        </div>
      `}).join("")}renderSessionStatus(e){if(!e)return;const t=this.dataManager?.getCurrentSession?.();if(!t){e.innerHTML=`
        <div class="session-status session-status--empty">
          <p class="session-status__message">No Active Session</p>
          <p class="session-status__hint">Create a new session to begin tracking gameplay</p>
          <button class="btn btn-primary" data-action="app.adminCreateSession">
            Create New Session
          </button>
        </div>
      `;return}const s=new Date(t.startTime),n=this._formatDuration(Date.now()-s.getTime());if(t.status==="paused"){e.innerHTML=`
        <div class="session-status session-status--paused">
          <h4 class="session-status__header">
            <span class="session-status__icon">‚è∏Ô∏è</span>
            <span>${this.escapeHtml(t.name||"Session")}</span>
            <span class="session-status__badge session-status__badge--paused">Paused</span>
          </h4>
          <div class="session-status__details">
            <span>Started: ${s.toLocaleTimeString()}</span>
            <span>Duration: ${n}</span>
          </div>
          <div class="session-status__actions">
            <button class="btn btn-primary" data-action="app.adminResumeSession">
              Resume Session
            </button>
            <button class="btn btn-danger" data-action="app.adminEndSession">
              End Session
            </button>
          </div>
        </div>
      `;return}e.innerHTML=`
      <div class="session-status session-status--active">
        <h4 class="session-status__header">
          <span class="session-status__icon">üéÆ</span>
          <span>${this.escapeHtml(t.name||"Session")}</span>
          <span class="session-status__badge session-status__badge--active">Active</span>
        </h4>
        <div class="session-status__details">
          <span>Started: ${s.toLocaleTimeString()}</span>
          <span>Duration: ${n}</span>
        </div>
        <div class="session-status__actions">
          <button class="btn btn-secondary" data-action="app.adminPauseSession">
            Pause Session
          </button>
          <button class="btn btn-danger" data-action="app.adminEndSession">
            End Session
          </button>
        </div>
      </div>
    `}_formatDuration(e){if(!e||e<0)return"0m";const t=Math.floor(e/1e3),s=Math.floor(t/60),n=Math.floor(s/60);return n>0?`${n}h ${s%60}m`:s>0?`${s}m`:`${t}s`}renderTeamDetails(e,t){const s=this.dataManager;if(!s)return;const n=s.getEnhancedTeamTransactions(e),a=s.calculateTeamScoreWithBonuses(e),o=this.sessionModeManager?.isNetworked(),i=document.getElementById("teamDetailsTitle"),r=document.getElementById("teamDetailsSummary");i&&(i.textContent=`Team ${e}`),r&&(r.textContent=`${t.length} token${t.length!==1?"s":""} collected`);let u="";if(n.hasCompletedGroups&&(u+='<div class="section-divider">‚úÖ Completed Groups</div>',n.completedGroups.forEach(v=>{u+=`
          <div class="group-section">
            <div class="group-header completed">
              <div class="group-title">
                <span class="completion-badge">üèÜ</span>
                <span class="group-name">${v.displayName}</span>
                <span class="completion-text">COMPLETE</span>
              </div>
              <div class="bonus-amount">
                +$${v.bonusValue.toLocaleString()} bonus (${v.multiplier}x)
              </div>
            </div>`;const T=this.sessionModeManager?.isNetworked()||this.sessionModeManager?.isStandalone();v.tokens.forEach(I=>{u+=this.renderTokenCard(I,!0,!1,T)}),u+="</div>"})),n.hasIncompleteGroups&&(u+='<div class="section-divider">üî∂ In Progress Groups</div>',n.incompleteGroups.forEach(v=>{u+=`
          <div class="group-section">
            <div class="group-header in-progress">
              <div class="group-title">
                <span class="progress-badge">‚è≥</span>
                <span class="group-name">${v.displayName}</span>
                <span class="progress-text">${v.progress}</span>
              </div>
              <div class="progress-bar">
                <div class="progress-fill" style="width: ${v.percentage}%"></div>
              </div>
            </div>`;const T=this.sessionModeManager?.isNetworked()||this.sessionModeManager?.isStandalone();v.tokens.forEach(I=>{u+=this.renderTokenCard(I,!1,!1,T)}),u+="</div>"})),n.hasUngroupedTokens){u+='<div class="section-divider">üì¶ Individual Tokens</div>';const v=this.sessionModeManager?.isNetworked()||this.sessionModeManager?.isStandalone();n.ungroupedTokens.forEach(T=>{u+=this.renderTokenCard(T,!1,!1,v)})}n.hasUnknownTokens&&(u+='<div class="section-divider">‚ùì Unknown Tokens</div>',n.unknownTokens.forEach(v=>{u+=this.renderTokenCard(v,!1,!0,o)})),u===""&&(u=`
        <div class="empty-state">
          <h3>No Tokens</h3>
          <p>This team hasn't scanned any tokens yet</p>
        </div>
      `);const l=document.getElementById("teamDetailsContainer");l&&(l.innerHTML=u);const h=o&&this.dataManager?.backendScores?.get(e);let m=a.baseScore,g=a.bonusScore,p=a.totalScore;o&&h&&(m=h.baseScore,g=h.bonusPoints,p=h.currentScore);const S=document.getElementById("teamBaseScore"),w=document.getElementById("teamBonusScore"),C=document.getElementById("teamTotalScore");S&&(S.textContent=`$${m.toLocaleString()}`),w&&(w.textContent=`$${g.toLocaleString()}`),C&&(C.textContent=`$${p.toLocaleString()}`);const $=document.getElementById("teamAdminAdjustmentsSection");if($&&o&&h?.adminAdjustments?.length>0){const v=h.adminAdjustments,T=v.reduce((b,x)=>b+x.delta,0);let I=`
        <div class="transaction-detail" style="margin: 8px 0; padding: 12px; background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; border-radius: 4px;">
          <label style="color: #856404; font-weight: bold;">‚ö†Ô∏è Admin Adjustments:</label>
          <span class="value" style="color: ${T>=0?"#28a745":"#dc3545"}; font-weight: bold;">
            ${T>=0?"+":""}$${Math.abs(T).toLocaleString()}
          </span>
        </div>
        <div style="margin-left: 20px; font-size: 12px; color: #666;">
      `;v.forEach(b=>{const x=new Date(b.timestamp).toLocaleString();I+=`
          <div style="margin: 4px 0; padding: 6px; background: #f8f9fa; border-radius: 3px;">
            <span style="color: ${b.delta>=0?"#28a745":"#dc3545"}; font-weight: bold;">
              ${b.delta>=0?"+":""}$${Math.abs(b.delta).toLocaleString()}
            </span>
            - ${b.reason||"No reason provided"}
            <br><span style="font-size: 10px; color: #999;">${x} by ${b.gmStation}</span>
          </div>
        `}),I+="</div>",$.innerHTML=I,$.style.display="block"}else $&&($.style.display="none");const R=document.getElementById("teamInterventionControls");if(R){const v=this.sessionModeManager?.isNetworked()||this.sessionModeManager?.isStandalone();R.style.display=v?"block":"none"}this.app&&(this.app.currentInterventionTeamId=e)}renderTokenCard(e,t=!1,s=!1,n=!1){const a=this.dataManager;if(!a)return"";const o=a.calculateTokenValue(e),i=e.status==="duplicate";let r=s?"unknown":t?"bonus-applied":"";i&&(r+=" duplicate");let u="";if(!s&&!e.isUnknown){const g=a.SCORING_CONFIG.BASE_VALUES[e.valueRating]||0,p=a.SCORING_CONFIG.TYPE_MULTIPLIERS[e.memoryType]||1;if(t){const S=a.parseGroupInfo(e.group),w=o*S.multiplier;u=`
          <strong>${g.toLocaleString()}</strong> √ó
          <strong>${p}x</strong> ${e.memoryType} √ó
          <strong>${S.multiplier}x</strong> group =
          <strong>$${w.toLocaleString()}</strong>`}else u=`
          <strong>${g.toLocaleString()}</strong> √ó
          <strong>${p}x</strong> ${e.memoryType} =
          <strong>$${o.toLocaleString()}</strong>`}else u="Unknown token - No value";const l=n&&e.id?`
      <button class="btn" data-action="app.deleteTeamTransaction" data-arg="${e.id}"
              style="background: #dc3545; color: white; padding: 4px 8px; font-size: 12px; margin-left: 8px; cursor: pointer;">
        üóëÔ∏è Delete
      </button>
    `:"",h=a.parseGroupInfo(e.group),m=t?o*h.multiplier:o;return`
      <div class="token-detail-card ${r}">
        <div class="token-detail-header">
          <span>${e.group}</span>
          <span class="token-detail-value" style="display: flex; align-items: center;">
            <span style="margin-right: 8px;">$${m.toLocaleString()}</span>
            ${l}
          </span>
        </div>
        <div class="token-detail-grid">
          <div class="token-detail-item">
            <span class="token-detail-label">RFID</span>
            <span class="token-detail-info">${e.rfid}</span>
          </div>
          <div class="token-detail-item">
            <span class="token-detail-label">Memory Type</span>
            <span class="token-detail-info">${e.memoryType}</span>
          </div>
          <div class="token-detail-item">
            <span class="token-detail-label">Base Rating</span>
            <span class="token-detail-info">
              ${s?"N/A":`‚≠ê${"‚≠ê".repeat(Math.max(0,e.valueRating-1))}`}
            </span>
          </div>
          <div class="token-detail-item">
            <span class="token-detail-label">Status</span>
            <span class="token-detail-info">
              ${i?"‚ö†Ô∏è Duplicate":t?"‚úÖ Bonus Applied":s?"‚ùì Unknown":"‚è≥ No Bonus"}
            </span>
          </div>
          <div class="token-calculation">
            ${u}
          </div>
        </div>
      </div>
    `}showGroupCompletionNotification(e){const t=document.createElement("div");t.style.cssText=`
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      padding: 15px 20px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      z-index: 10000;
      animation: slideIn 0.3s ease-out;
      max-width: 350px;
    `,t.innerHTML=`
      <div style="display: flex; align-items: center; gap: 10px;">
        <span style="font-size: 24px;">üèÜ</span>
        <div>
          <div style="font-weight: bold; margin-bottom: 5px;">Group Completed!</div>
          <div style="font-size: 14px;">Team ${e.teamId} - ${e.groupId}</div>
          <div style="font-size: 14px;">Bonus: +$${e.bonus.toLocaleString()} (${e.multiplier}x)</div>
        </div>
      </div>
    `,document.body.appendChild(t),setTimeout(()=>{t.style.animation="fadeOut 0.3s ease-out forwards",setTimeout(()=>t.remove(),300)},5e3)}showTokenResult(e,t,s){const n=this.dataManager;if(!n||!this.settings)return;const a=document.getElementById("resultStatus"),o=document.getElementById("resultRfid"),i=document.getElementById("resultType"),r=document.getElementById("resultGroup"),u=document.getElementById("resultValue"),l=document.getElementById("resultSummaryContainer"),h=document.getElementById("resultSummary");if(!(!a||!o||!i||!r||!u)){if(s)a.className="status-message error",a.innerHTML=`
        <h2>Unknown Token</h2>
        <p style="font-size: 14px;">Not in database</p>
      `,o.textContent=t,i.textContent="UNKNOWN",i.style.color="#FF5722",r.textContent=`Raw ID: ${t}`,this.settings.mode==="blackmarket"?u.textContent="$0":u.textContent="No Value",l&&(l.style.display="none");else{if(a.className="status-message success",a.innerHTML="<h2>Transaction Complete!</h2>",o.textContent=t,i.textContent=e.SF_MemoryType,i.style.color="#333",r.textContent=e.SF_Group,this.settings.mode==="blackmarket"){const m=n.calculateTokenValue({valueRating:e.SF_ValueRating,memoryType:e.SF_MemoryType,isUnknown:!1});u.textContent=`$${m.toLocaleString()}`}else u.textContent="‚≠ê".repeat(e.SF_ValueRating||0);e.summary&&l&&h?(l.style.display="flex",h.textContent=e.summary):l&&(l.style.display="none")}this.showScreen("result")}}escapeHtml(e){if(!e)return"";const t=document.createElement("div");return t.textContent=e,t.innerHTML}_formatTime(e){return e?new Date(e).toLocaleTimeString([],{hour:"2-digit",minute:"2-digit"}):""}renderGameActivity(e,t={}){if(!e)return;const{showSummary:s=!0,showFilters:n=!0}=t,a=this.dataManager;if(!a)return;if(typeof a.getGameActivity!="function"){e.innerHTML=`
        <div class="empty-state">
          <h3>Game Activity</h3>
          <p>No activity data available</p>
        </div>
      `;return}const{tokens:o,stats:i}=a.getGameActivity();let r="";if(s&&(r+=`
        <div class="activity-summary">
          <span class="stat">${i.totalTokens} tokens</span>
          <span class="stat available">${i.available} available</span>
          <span class="stat claimed">${i.claimed} claimed</span>
          ${i.claimedWithoutDiscovery>0?`
            <span class="stat warning" title="Tokens claimed by GM without player discovery">
              ${i.claimedWithoutDiscovery} GM-only
            </span>
          `:""}
        </div>
      `),n&&(r+=`
        <div class="activity-filters">
          <input type="text" id="activitySearch" placeholder="Search tokens..." class="search-input">
          <select id="activityFilter" class="filter-select">
            <option value="all">All Tokens</option>
            <option value="available">Available Only</option>
            <option value="claimed">Claimed Only</option>
          </select>
        </div>
      `),r+='<div class="activity-grid">',o.length===0)r+='<div class="empty-state">No token activity yet</div>';else{const u=l=>!l.events||!l.events.length?0:new Date(l.events[l.events.length-1].timestamp);o.sort((l,h)=>u(h)-u(l)).forEach(l=>{r+=this._renderActivityTokenCard(l)})}r+="</div>",e.innerHTML=r,this._attachActivityFilterHandlers(e)}_renderActivityTokenCard(e){const{tokenId:t,tokenData:s,events:n,status:a,discoveredByPlayers:o,potentialValue:i}=e,r=s?.SF_MemoryType||"Unknown",u=s?.SF_ValueRating||0,l=n.filter(p=>p.type==="scan"),h=l.length>0,m=n.find(p=>p.type==="claim");let g;return a==="claimed"&&m?.mode==="blackmarket"?g=`<span class="status-icon">üí∞</span> SOLD to ${this.escapeHtml(m?.teamId||"Unknown")}
        <span class="points">$${(m?.points||0).toLocaleString()}</span>`:a==="claimed"&&m?.mode==="detective"?g=`<span class="status-icon">üîç</span> EXPOSED by ${this.escapeHtml(m?.teamId||"Unknown")}
        <span class="points potential">Worth: $${(i||0).toLocaleString()}</span>`:g=`‚óã AVAILABLE
        <span class="points potential">Worth: $${(i||0).toLocaleString()}</span>`,`
      <div class="token-card ${a}" data-token-id="${t}">
        <!-- Header: Token ID + Type + Rating -->
        <div class="token-card__header">
          <span class="token-id">${this.escapeHtml(t)}</span>
          <span class="token-type type-${r.toLowerCase()}">${r}</span>
        </div>
        <div class="token-card__rating">${"‚òÖ".repeat(u)}${"‚òÜ".repeat(5-u)}</div>

        <!-- Status Bar: Quick-glance current state with mode-specific styling -->
        <div class="token-card__status status-${a} ${m?.mode||""}">
          ${g}
        </div>

        ${s?.summary?`
          <div class="token-card__summary">
            <button class="summary-toggle" onclick="this.parentElement.classList.toggle('expanded')">Intel</button>
            <div class="summary-content">${this.escapeHtml(s.summary)}</div>
          </div>
        `:""}

        <!-- Timeline: Full event history (expandable) -->
        <div class="token-card__timeline ${h?"expandable":""}"
             data-expanded="false">

          ${!o&&a==="claimed"?`
            <div class="event warning">
              <span class="icon">‚ö†Ô∏è</span>
              <span class="label">Not discovered by players</span>
            </div>
          `:""}

          ${n.map((p,S)=>this._renderTimelineEvent(p,S,n.length)).join("")}

          ${a==="available"?`
            <div class="event status-available">
              <span class="status-badge">AWAITING CLAIM</span>
            </div>
          `:""}
        </div>

        ${h?`
          <button class="timeline-toggle" onclick="this.parentElement.querySelector('.token-card__timeline').dataset.expanded =
            this.parentElement.querySelector('.token-card__timeline').dataset.expanded === 'true' ? 'false' : 'true'">
            <span class="expand-text">Show ${l.length} more scans</span>
            <span class="collapse-text">Collapse</span>
          </button>
        `:""}
      </div>
    `}_renderTimelineEvent(e,t,s){const n=this._formatTime(e.timestamp);switch(e.type){case"discovery":return`
          <div class="event discovery">
            <span class="icon">üëÅ</span>
            <span class="label">Discovered</span>
            <span class="device">${this.escapeHtml(e.deviceId)}</span>
            <span class="time">${n}</span>
          </div>
        `;case"scan":return`
          <div class="event scan collapsible">
            <span class="icon">üëÅ</span>
            <span class="label">Scanned</span>
            <span class="device">${this.escapeHtml(e.deviceId)}</span>
            <span class="time">${n}</span>
          </div>
        `;case"claim":return`
          <div class="event claim ${e.mode}">
            <span class="icon">${e.mode==="blackmarket"?"üí∞":"üîç"}</span>
            <span class="label">${e.mode==="blackmarket"?"Black Market":"Detective"}</span>
            <span class="team">${this.escapeHtml(e.teamId)}</span>
            <span class="time">${n}</span>
            <span class="points">$${(e.points||0).toLocaleString()}</span>
            ${e.groupProgress?`
              <div class="group-progress">
                ${this.escapeHtml(e.groupProgress.name)} (${e.groupProgress.found}/${e.groupProgress.total})
              </div>
            `:""}
            ${e.summary?`
              <div class="exposed-summary">
                <span class="summary-label">Intel:</span>
                <span class="summary-text">${this.escapeHtml(e.summary)}</span>
              </div>
            `:""}
          </div>
        `;default:return""}}_attachActivityFilterHandlers(e){const t=e.querySelector("#activitySearch"),s=e.querySelector("#activityFilter");t&&t.addEventListener("input",()=>this._filterGameActivity(e)),s&&s.addEventListener("change",()=>this._filterGameActivity(e))}_filterGameActivity(e){const t=e.querySelector("#activitySearch"),s=e.querySelector("#activityFilter"),n=e.querySelectorAll(".token-card"),a=t?.value?.toLowerCase()||"",o=s?.value||"all";n.forEach(i=>{const r=i.dataset.tokenId?.toLowerCase()||"",u=i.classList.contains("claimed")?"claimed":"available",l=!a||r.includes(a),h=o==="all"||u===o;i.style.display=l&&h?"block":"none"})}};class J extends EventTarget{constructor(){super(),this.deviceId="001",this.mode="detective"}load(){this.deviceId=localStorage.getItem("deviceId")||"001",this.mode=localStorage.getItem("mode")||"detective";const e=document.getElementById("deviceId"),t=document.getElementById("deviceIdDisplay"),s=document.getElementById("modeToggle");e&&(e.value=this.deviceId),t&&(t.textContent=this.deviceId),s&&(s.checked=this.mode==="blackmarket"),this.dispatchEvent(new CustomEvent("settings:loaded",{detail:{deviceId:this.deviceId,mode:this.mode}}))}save(){const e=document.getElementById("settingsScreen"),t=this.deviceId,s=this.mode;if(e&&e.classList.contains("active")){const a=document.getElementById("deviceId"),o=document.getElementById("modeToggle");a&&(this.deviceId=a.value||"001"),o&&(this.mode=o.checked?"blackmarket":"detective")}localStorage.setItem("deviceId",this.deviceId),localStorage.setItem("mode",this.mode);const n=document.getElementById("deviceIdDisplay");n&&(n.textContent=this.deviceId),this.dispatchEvent(new CustomEvent("settings:saved",{detail:{deviceId:this.deviceId,mode:this.mode}})),(t!==this.deviceId||s!==this.mode)&&this.dispatchEvent(new CustomEvent("settings:changed",{detail:{deviceId:this.deviceId,mode:this.mode,oldDeviceId:t,oldMode:s}}))}}const N=new J;class K{constructor(){this.database={},this.groupInventory=null,this._dataManagerHelpers=null}setDataManagerHelpers(e){this._dataManagerHelpers=e}async loadDatabase(){try{let e=await fetch("data/tokens.json");if(!e.ok&&(d.log("Trying root directory for tokens.json"),e=await fetch("tokens.json"),!e.ok))throw new Error("Failed to load tokens.json from data/ or root");return this.database=await e.json(),d.log(`‚úÖ Loaded ${Object.keys(this.database).length} tokens from ${e.url}`),d.log(`Sample keys: ${Object.keys(this.database).slice(0,3).join(", ")}`),this.groupInventory=this.buildGroupInventory(),this.logGroupStats(),!0}catch(e){return d.log(`Token database error: ${e.message}`,!0),!1}}buildGroupInventory(){const e={},t=[];return Object.entries(this.database).forEach(([s,n])=>{const a=this._dataManagerHelpers?this._dataManagerHelpers.parseGroupInfo(n.SF_Group):this._parseGroupInfoFallback(n.SF_Group),o=this._dataManagerHelpers?this._dataManagerHelpers.normalizeGroupName(a.name):this._normalizeGroupNameFallback(a.name);e[o]||(e[o]={displayName:a.name,normalizedName:o,multiplier:a.multiplier,tokens:new Set,rawGroupNames:new Set,memoryTypes:new Set}),e[o].tokens.add(s),e[o].rawGroupNames.add(n.SF_Group),e[o].memoryTypes.add(n.SF_MemoryType),e[o].multiplier!==a.multiplier&&(t.push(`Group "${a.name}" has inconsistent multipliers`),e[o].multiplier=Math.max(e[o].multiplier,a.multiplier)),(a.name.length>e[o].displayName.length||a.name.length===e[o].displayName.length&&a.name>e[o].displayName)&&(e[o].displayName=a.name)}),t.length>0&&(d.log("=== Group Inventory Issues ===",!0),t.forEach(s=>d.log(s,!0))),e}_parseGroupInfoFallback(e){if(!e)return{name:"",multiplier:1};const t=e.match(/^(.+?)\s*\(x(\d+)\)$/i);return t?{name:t[1].trim(),multiplier:parseInt(t[2],10)}:{name:e.trim(),multiplier:1}}_normalizeGroupNameFallback(e){return e.toLowerCase().trim().replace(/\s+/g," ")}logGroupStats(){if(!this.groupInventory)return;d.log("=== Group Inventory Summary ===");const e=Object.values(this.groupInventory);d.log(`Total Groups: ${e.length}`);const t=e.filter(n=>n.multiplier>1&&n.tokens.size>1),s=e.filter(n=>n.tokens.size===1);d.log(`Completable Groups: ${t.length}`),d.log(`Single Token Groups: ${s.length}`),e.sort((n,a)=>a.tokens.size-n.tokens.size).forEach(n=>{d.log(`"${n.displayName}": ${n.tokens.size} tokens, ${n.multiplier}x`),n.tokens.size===1&&n.multiplier>1&&d.log(`  ‚ö†Ô∏è Only 1 token but ${n.multiplier}x multiplier`,!0)})}getGroupInventory(){return this.groupInventory||(this.groupInventory=this.buildGroupInventory()),this.groupInventory}getAllTokens(){return Object.values(this.database)}findToken(e){if(d.log(`üîç findToken called with: "${e}"`),d.log(`Database has ${Object.keys(this.database).length} tokens`),d.log(`First 5 keys: ${Object.keys(this.database).slice(0,5).join(", ")}`),this.database[e])return d.log(`‚úÖ Direct match: ${e}`),{token:this.database[e],matchedId:e};const t=e.replace(/[:-]/g,"").toLowerCase();for(const[s,n]of Object.entries(this.database)){const a=s.replace(/[:-]/g,"").toLowerCase();if(t===a)return d.log(`‚úÖ Fuzzy match: "${e}" -> "${s}"`),{token:n,matchedId:s}}return d.log(`No match found for: ${e}`,!0),null}}const G=new K;class P extends EventTarget{constructor(){super()}async initialize(){throw new Error("IStorageStrategy.initialize() must be implemented")}async addTransaction(e){throw new Error("IStorageStrategy.addTransaction() must be implemented")}async removeTransaction(e){throw new Error("IStorageStrategy.removeTransaction() must be implemented")}getTransactions(){throw new Error("IStorageStrategy.getTransactions() must be implemented")}getTeamScores(){throw new Error("IStorageStrategy.getTeamScores() must be implemented")}async adjustTeamScore(e,t,s){throw new Error("IStorageStrategy.adjustTeamScore() must be implemented")}getGameActivity(){throw new Error("IStorageStrategy.getGameActivity() must be implemented")}async createSession(e,t){throw new Error("IStorageStrategy.createSession() must be implemented")}async endSession(){throw new Error("IStorageStrategy.endSession() must be implemented")}async pauseSession(){throw new Error("IStorageStrategy.pauseSession() must be implemented")}async resumeSession(){throw new Error("IStorageStrategy.resumeSession() must be implemented")}async resetScores(){throw new Error("IStorageStrategy.resetScores() must be implemented")}getCurrentSession(){throw new Error("IStorageStrategy.getCurrentSession() must be implemented")}isReady(){throw new Error("IStorageStrategy.isReady() must be implemented")}dispose(){}}const Y={1:1e4,2:25e3,3:5e4,4:75e3,5:15e4},X={Personal:1,Business:3,Technical:5,UNKNOWN:0},H={baseValues:Y,typeMultipliers:X},D={BASE_VALUES:Object.fromEntries(Object.entries(H.baseValues).map(([c,e])=>[parseInt(c),e])),TYPE_MULTIPLIERS:{...H.typeMultipliers}};function A(c){if(!c)return{name:"Unknown",multiplier:1};const e=c.trim(),t=e.match(/^(.+?)\s*\(x(\d+)\)$/i);if(t){const s=t[1].trim(),n=parseInt(t[2])||1;return n<1?(console.warn(`[scoring] Invalid multiplier ${n} for "${s}", using 1`),{name:s,multiplier:1}):{name:s,multiplier:n}}return{name:e,multiplier:1}}function Z(c){return c?c.trim().toLowerCase().replace(/\s+/g," ").replace(/['\u2018\u2019]/g,"'"):""}function _(c){if(c.isUnknown)return 0;const e=D.BASE_VALUES[c.valueRating]||0,t=D.TYPE_MULTIPLIERS[c.memoryType]??D.TYPE_MULTIPLIERS.UNKNOWN??0;return e*t}class ee extends P{constructor({tokenManager:e,debug:t}={}){super(),this.tokenManager=e,this.debug=t,this.SCORING_CONFIG=D,this.sessionData={sessionId:this._generateSessionId(),startTime:new Date().toISOString(),transactions:[],teams:{},mode:"standalone"},this.scannedTokens=new Set,this.playerScans=[]}_generateSessionId(){return`LOCAL_${Date.now()}_${Math.random().toString(36).substring(2,11)}`}isReady(){return!0}async initialize(){this._loadSession()}_loadSession(){const e=localStorage.getItem("standaloneSession");if(e)try{const t=JSON.parse(e),s=new Date(t.startTime).toDateString(),n=new Date().toDateString();s===n&&(this.sessionData=t,this._repopulateScannedTokens(),this.debug?.log(`Loaded session: ${t.sessionId}`))}catch{this.debug?.log("Failed to load session",!0)}}_repopulateScannedTokens(){this.scannedTokens.clear(),this.sessionData.transactions.forEach(e=>{const t=e.tokenId||e.rfid;t&&this.scannedTokens.add(t)})}_saveSession(){localStorage.setItem("standaloneSession",JSON.stringify(this.sessionData))}getTransactions(){return this.sessionData.transactions}getTeamScores(){return Object.values(this.sessionData.teams).map(e=>({teamId:e.teamId,score:e.score,baseScore:e.baseScore,bonusScore:e.bonusPoints,tokenCount:e.tokensScanned,completedGroups:e.completedGroups?.length||0,isFromBackend:!1})).sort((e,t)=>t.score-e.score)}getCurrentSession(){return{sessionId:this.sessionData.sessionId,name:this.sessionData.name,startTime:this.sessionData.startTime,status:this.sessionData.status||"active"}}async createSession(e,t){return this.sessionData={sessionId:this._generateSessionId(),name:e,status:"active",startTime:new Date().toISOString(),transactions:[],teams:{},mode:"standalone"},this.scannedTokens.clear(),this._saveSession(),this.getCurrentSession()}async endSession(){this._saveSession()}async pauseSession(){return!this.sessionData?.sessionId||!this.sessionData?.status?{success:!1,error:"No active session to pause"}:this.sessionData.status==="paused"?{success:!1,error:"Session already paused"}:(this.sessionData.status="paused",this.sessionData.pausedAt=new Date().toISOString(),this._saveSession(),this.dispatchEvent(new CustomEvent("session:updated",{detail:{session:this.getCurrentSession()}})),{success:!0})}async resumeSession(){return!this.sessionData?.sessionId||!this.sessionData?.status?{success:!1,error:"No session to resume"}:this.sessionData.status!=="paused"?{success:!1,error:"Session is not paused"}:(this.sessionData.status="active",delete this.sessionData.pausedAt,this._saveSession(),this.dispatchEvent(new CustomEvent("session:updated",{detail:{session:this.getCurrentSession()}})),{success:!0})}async resetScores(){return Object.keys(this.sessionData.teams).forEach(e=>{const t=this.sessionData.teams[e];t.score=0,t.baseScore=0,t.bonusPoints=0,t.adminAdjustments=[]}),this._saveSession(),this.dispatchEvent(new CustomEvent("scores:cleared",{detail:{}})),{success:!0}}async addTransaction(e){if(this.sessionData?.status==="paused")return{success:!1,error:"Cannot add transaction: session is paused"};if(!e||!e.teamId)return{success:!1,error:"Transaction must have teamId"};this.sessionData.transactions.push(e);const t=e.tokenId||e.rfid;return t&&this.scannedTokens.add(t),this._updateTeamScore(e),this._saveSession(),{success:!0,transaction:e,teamScore:this.sessionData.teams[e.teamId]}}_updateTeamScore(e){const t=e.teamId;this.sessionData.teams[t]||(this.sessionData.teams[t]={teamId:t,score:0,baseScore:0,bonusPoints:0,tokensScanned:0,completedGroups:[],lastScanTime:null});const s=this.sessionData.teams[t];e.mode==="blackmarket"&&e.points&&(s.baseScore+=e.points,s.score=s.baseScore+s.bonusPoints),s.tokensScanned++,s.lastScanTime=e.timestamp,e.mode==="blackmarket"&&e.group&&this._checkGroupCompletion(t,e.group)}_checkGroupCompletion(e,t){const s=A(t);if(s.multiplier<=1)return;const n=this.sessionData.teams[e];if(n.completedGroups.includes(s.name))return;const o=this.sessionData.transactions.filter(m=>m.teamId===e&&m.mode==="blackmarket").filter(m=>A(m.group).name===s.name);if(!this.tokenManager)return;const r=this.tokenManager.getAllTokens().filter(m=>m.SF_Group?A(m.SF_Group).name===s.name:!1),u=o.map(m=>m.tokenId);if(r.map(m=>m.SF_RFID).every(m=>u.includes(m))&&r.length>0){const m=o.reduce((p,S)=>p+(S.points||0),0),g=(s.multiplier-1)*m;n.bonusPoints+=g,n.score=n.baseScore+n.bonusPoints,n.completedGroups.push(s.name),this.debug?.log(`Group completed: ${s.name}, bonus: ${g}`)}}async removeTransaction(e){const t=this.sessionData.transactions.findIndex(i=>i.id===e);if(t===-1)return{success:!1,error:`Transaction not found: ${e}`};const s=this.sessionData.transactions.splice(t,1)[0],n=s.tokenId||s.rfid,a=s.teamId;return!this.sessionData.transactions.some(i=>(i.tokenId||i.rfid)===n)&&n&&this.scannedTokens.delete(n),a&&this.sessionData.teams[a]&&this._recalculateTeamScores(a),this._saveSession(),{success:!0,transaction:s}}_recalculateTeamScores(e){const t=this.sessionData.teams[e];t.baseScore=0,t.bonusPoints=0,t.score=0,t.tokensScanned=0,t.completedGroups=[],this.sessionData.transactions.filter(s=>s.teamId===e).forEach(s=>this._updateTeamScore(s))}async adjustTeamScore(e,t,s="Manual adjustment"){if(!this.sessionData.teams[e])return{success:!1,error:`Team not found: ${e}`};const n=this.sessionData.teams[e];n.adminAdjustments||(n.adminAdjustments=[]);const a={delta:parseInt(t),reason:s,timestamp:new Date().toISOString()};return n.adminAdjustments.push(a),n.score+=a.delta,this._saveSession(),{success:!0,teamScore:{...n}}}getGameActivity(){const e=new Map;this.playerScans.forEach(n=>{e.has(n.tokenId)?e.get(n.tokenId).events.push({type:"scan",timestamp:n.timestamp,deviceId:n.deviceId}):e.set(n.tokenId,{tokenId:n.tokenId,tokenData:n.tokenData||{},potentialValue:_({valueRating:n.tokenData?.SF_ValueRating,memoryType:n.tokenData?.SF_MemoryType}),events:[{type:"discovery",timestamp:n.timestamp,deviceId:n.deviceId}],status:"available",discoveredByPlayers:!0})}),this.sessionData.transactions.forEach(n=>{let a=e.get(n.tokenId);if(!a){const o=this.tokenManager?.findToken(n.tokenId),i=o?{SF_MemoryType:o.SF_MemoryType,SF_ValueRating:o.SF_ValueRating,SF_Group:o.SF_Group||null,summary:o.summary||null}:{SF_MemoryType:n.memoryType,SF_ValueRating:n.valueRating};a={tokenId:n.tokenId,tokenData:i,potentialValue:_({valueRating:i.SF_ValueRating,memoryType:i.SF_MemoryType}),events:[],status:"claimed",discoveredByPlayers:!1},e.set(n.tokenId,a)}a.events.push({type:"claim",timestamp:n.timestamp,mode:n.mode,teamId:n.teamId,points:n.points||0,summary:n.summary||a.tokenData?.summary||null}),a.status="claimed"}),e.forEach(n=>{n.events.sort((a,o)=>new Date(a.timestamp)-new Date(o.timestamp))});const t=Array.from(e.values()),s={totalTokens:t.length,available:t.filter(n=>n.status==="available").length,claimed:t.filter(n=>n.status==="claimed").length,claimedWithoutDiscovery:t.filter(n=>n.status==="claimed"&&!n.discoveredByPlayers).length,totalPlayerScans:this.playerScans.length};return{tokens:t,stats:s}}dispose(){}}class te extends P{constructor({socket:e,tokenManager:t,debug:s}={}){super(),this.socket=e,this.tokenManager=t,this.debug=s,this.transactions=[],this.backendScores=new Map,this.scannedTokens=new Set,this.playerScans=[],this.currentSessionId=null}isReady(){return this.socket?.connected===!0}async initialize(){this._setupEventListeners()}_setupEventListeners(){this.socket}async addTransaction(e){return!e||!e.teamId?{success:!1,error:"Transaction must have teamId"}:this.isReady()?(this.debug?.log(`[NetworkedStorage] Submitting transaction: ${e.tokenId} for team ${e.teamId}`),this.socket.emit("transaction:submit",{tokenId:e.tokenId,teamId:e.teamId,deviceId:e.deviceId,deviceType:"gm",mode:e.mode,timestamp:e.timestamp||new Date().toISOString()}),e.tokenId&&this.scannedTokens.add(e.tokenId),{success:!0,pending:!0}):(this.debug?.log("[NetworkedStorage] Cannot add transaction: socket not connected",!0),{success:!1,error:"Socket not connected"})}async removeTransaction(e){return this.isReady()?(this.debug?.log(`[NetworkedStorage] Removing transaction: ${e}`),this.socket.emit("gm:command",{event:"gm:command",data:{action:"transaction:delete",payload:{transactionId:e}},timestamp:new Date().toISOString()}),{success:!0,pending:!0}):(this.debug?.log("[NetworkedStorage] Cannot remove transaction: socket not connected",!0),{success:!1,error:"Socket not connected"})}getTransactions(){return this.transactions}getTeamScores(){return this.backendScores.size===0?[]:Array.from(this.backendScores.entries()).map(([e,t])=>({teamId:e,score:t.currentScore,baseScore:t.baseScore,bonusScore:t.bonusPoints,tokenCount:t.tokensScanned,completedGroups:t.completedGroups?.length||0,isFromBackend:!0})).sort((e,t)=>t.score-e.score)}async adjustTeamScore(e,t,s){return this.isReady()?(this.debug?.log(`[NetworkedStorage] Adjusting score for team ${e}: ${t>0?"+":""}${t} (${s})`),this.socket.emit("gm:command",{event:"gm:command",data:{action:"score:adjust",payload:{teamId:e,delta:t,reason:s}},timestamp:new Date().toISOString()}),{success:!0,pending:!0}):(this.debug?.log("[NetworkedStorage] Cannot adjust score: socket not connected",!0),{success:!1,error:"Socket not connected"})}getGameActivity(){const e=new Map;this.playerScans.forEach(s=>{if(e.has(s.tokenId))e.get(s.tokenId).events.push({type:"scan",timestamp:s.timestamp,deviceId:s.deviceId});else{const n=s.tokenData||{};e.set(s.tokenId,{tokenId:s.tokenId,tokenData:n,potentialValue:_({valueRating:n.SF_ValueRating,memoryType:n.SF_MemoryType}),events:[{type:"discovery",timestamp:s.timestamp,deviceId:s.deviceId}],status:"available",discoveredByPlayers:!0})}}),this.transactions.forEach(s=>{if(s.status&&s.status!=="accepted")return;let n=e.get(s.tokenId);if(!n){const a=this.tokenManager?.findToken(s.tokenId),o=a?{SF_MemoryType:a.SF_MemoryType,SF_ValueRating:a.SF_ValueRating,SF_Group:a.SF_Group,summary:a.summary}:{SF_MemoryType:s.memoryType,SF_ValueRating:s.valueRating};n={tokenId:s.tokenId,tokenData:o,potentialValue:_({valueRating:o.SF_ValueRating,memoryType:o.SF_MemoryType}),events:[],status:"claimed",discoveredByPlayers:!1},e.set(s.tokenId,n)}n.events.push({type:"claim",timestamp:s.timestamp,mode:s.mode,teamId:s.teamId,points:s.points||_({valueRating:s.valueRating,memoryType:s.memoryType}),summary:s.summary||n.tokenData?.summary}),n.status="claimed"}),e.forEach(s=>{s.events.sort((n,a)=>new Date(n.timestamp)-new Date(a.timestamp))});const t=Array.from(e.values());return{tokens:t,stats:{totalTokens:t.length,available:t.filter(s=>s.status==="available").length,claimed:t.filter(s=>s.status==="claimed").length,claimedWithoutDiscovery:t.filter(s=>!s.discoveredByPlayers&&s.status==="claimed").length,totalPlayerScans:this.playerScans.length}}}async createSession(e,t){return this.isReady()?(this.debug?.log(`[NetworkedStorage] Creating session: ${e}`),this.socket.emit("gm:command",{event:"gm:command",data:{action:"session:create",payload:{name:e,teams:t}},timestamp:new Date().toISOString()}),{pending:!0}):(this.debug?.log("[NetworkedStorage] Cannot create session: socket not connected",!0),{success:!1,error:"Socket not connected"})}async endSession(){if(!this.isReady()){this.debug?.log("[NetworkedStorage] Cannot end session: socket not connected",!0);return}this.debug?.log("[NetworkedStorage] Ending session"),this.socket.emit("gm:command",{event:"gm:command",data:{action:"session:end",payload:{}},timestamp:new Date().toISOString()})}getCurrentSession(){return this.currentSessionId?{sessionId:this.currentSessionId,status:"active"}:null}async pauseSession(){return this.isReady()?(this.debug?.log("[NetworkedStorage] Pausing session"),this.socket.emit("gm:command",{event:"gm:command",data:{action:"session:pause",payload:{}},timestamp:new Date().toISOString()}),{success:!0,pending:!0}):(this.debug?.log("[NetworkedStorage] Cannot pause session: socket not connected",!0),{success:!1,error:"Socket not connected"})}async resumeSession(){return this.isReady()?(this.debug?.log("[NetworkedStorage] Resuming session"),this.socket.emit("gm:command",{event:"gm:command",data:{action:"session:resume",payload:{}},timestamp:new Date().toISOString()}),{success:!0,pending:!0}):(this.debug?.log("[NetworkedStorage] Cannot resume session: socket not connected",!0),{success:!1,error:"Socket not connected"})}async resetScores(){return this.isReady()?(this.debug?.log("[NetworkedStorage] Resetting all scores"),this.socket.emit("gm:command",{event:"gm:command",data:{action:"scores:reset",payload:{}},timestamp:new Date().toISOString()}),{success:!0,pending:!0}):(this.debug?.log("[NetworkedStorage] Cannot reset scores: socket not connected",!0),{success:!1,error:"Socket not connected"})}setTransactions(e){this.transactions=e}addTransactionFromBroadcast(e){this.transactions.some(s=>s.id===e.id)||this.transactions.push(e)}setBackendScores(e,t){this.backendScores.set(e,t)}clearBackendScores(){this.backendScores.clear()}setScannedTokens(e){this.scannedTokens=new Set(e)}setPlayerScans(e){this.playerScans=e}addPlayerScan(e){this.playerScans.some(s=>s.id===e.id)||this.playerScans.push(e)}setSessionId(e){this.currentSessionId=e}dispose(){}}class F{static isTokenScanned(e,t){return e.has(t)}static markTokenAsScanned(e,t){e.add(t)}static unmarkTokenAsScanned(e,t){return e.delete(t)}static calculateGlobalStats(e,t){const s=e.length,n=[...new Set(e.map(l=>l.teamId))].length,a=e.filter(l=>!l.isUnknown),i=a.filter(l=>l.mode==="blackmarket").reduce((l,h)=>l+t(h),0),r=Math.floor(i/1e3),u=a.length>0?parseFloat((r/a.length).toFixed(1)):0;return{total:s,teams:n,totalValue:r,avgValue:u,blackMarketScore:i}}}class se extends EventTarget{constructor({tokenManager:e,sessionModeManager:t,debug:s}={}){super(),this.tokenManager=e,this.sessionModeManager=t,this.debug=s,this._localStrategy=null,this._networkedStrategy=null,this._activeStrategy=null,this._strategyListeners=new Map,this.scannedTokens=new Set,this.SCORING_CONFIG=D,this.currentSessionId=null}async initializeStandaloneMode(){this._log("Initializing standalone mode"),this._localStrategy=new ee({tokenManager:this.tokenManager,debug:this.debug}),await this._localStrategy.initialize(),this._activeStrategy=this._localStrategy,this._syncScannedTokens(),this._wireStrategyEvents(this._localStrategy),this._log("Standalone mode initialized")}async initializeNetworkedMode(e){this._log("Initializing networked mode");const t=e?.socket||e;this._networkedStrategy=new te({tokenManager:this.tokenManager,socket:t,debug:this.debug}),await this._networkedStrategy.initialize(),this._activeStrategy=this._networkedStrategy,this._syncScannedTokens(),this._wireStrategyEvents(this._networkedStrategy),this._log("Networked mode initialized")}isReady(){return this._activeStrategy?.isReady()??!1}getActiveStrategyType(){return this._activeStrategy?this._activeStrategy===this._localStrategy?"local":this._activeStrategy===this._networkedStrategy?"networked":null:null}_syncScannedTokens(){this._activeStrategy?.scannedTokens&&(this.scannedTokens=this._activeStrategy.scannedTokens)}_wireStrategyEvents(e){const t=["transaction:added","transaction:deleted","team-score:updated","scores:cleared","data:cleared","game-state:updated","player-scan:added","session:updated"],s=[];t.forEach(n=>{const a=o=>{this.dispatchEvent(new CustomEvent(n,{detail:o.detail}))};e.addEventListener(n,a),s.push({eventName:n,handler:a})}),this._strategyListeners.set(e,s)}_unwireStrategyEvents(e){const t=this._strategyListeners.get(e);t&&(t.forEach(({eventName:s,handler:n})=>{e.removeEventListener(s,n)}),this._strategyListeners.delete(e))}_log(e){this.debug?.log&&this.debug.log(`[UnifiedDataManager] ${e}`)}async addTransaction(e){return this._requireActiveStrategy(),this._activeStrategy.addTransaction(e)}async removeTransaction(e){return this._requireActiveStrategy(),this._activeStrategy.removeTransaction(e)}addTransactionFromBroadcast(e){typeof this._activeStrategy?.addTransactionFromBroadcast=="function"&&(this._activeStrategy.addTransactionFromBroadcast(e),this.dispatchEvent(new CustomEvent("transaction:added",{detail:{transaction:e}})))}getTransactions(){return this._requireActiveStrategy(),this._activeStrategy.getTransactions()}getTeamScores(){return this._requireActiveStrategy(),this._activeStrategy.getTeamScores()}async adjustTeamScore(e,t,s){return this._requireActiveStrategy(),this._activeStrategy.adjustTeamScore(e,t,s)}getGameActivity(){return this._requireActiveStrategy(),this._activeStrategy.getGameActivity()}getCurrentSession(){return this._activeStrategy?.getCurrentSession()??null}async createSession(e,t){return this._requireActiveStrategy(),this._activeStrategy.createSession(e,t)}async endSession(){return this._requireActiveStrategy(),this._activeStrategy.endSession()}async pauseSession(){return this._requireActiveStrategy(),this._activeStrategy.pauseSession()}async resumeSession(){return this._requireActiveStrategy(),this._activeStrategy.resumeSession()}async resetScores(){return this._requireActiveStrategy(),this._activeStrategy.resetScores()}dispose(){this._localStrategy&&(this._unwireStrategyEvents(this._localStrategy),this._localStrategy.dispose()),this._networkedStrategy&&(this._unwireStrategyEvents(this._networkedStrategy),this._networkedStrategy.dispose()),this._activeStrategy=null,this._localStrategy=null,this._networkedStrategy=null,this._strategyListeners.clear(),this.scannedTokens=new Set,this._log("Disposed")}_requireActiveStrategy(){if(!this._activeStrategy)throw new Error("UnifiedDataManager: No active strategy. Call initializeStandaloneMode() or initializeNetworkedMode() first.")}isTokenScanned(e){return F.isTokenScanned(this.scannedTokens,e)}markTokenAsScanned(e){F.markTokenAsScanned(this.scannedTokens,e)}unmarkTokenAsScanned(e){F.unmarkTokenAsScanned(this.scannedTokens,e)}calculateTokenValue(e){return _(e)}getTeamTransactions(e){return this.getTransactions().filter(s=>s.teamId===e)}parseGroupInfo(e){return A(e)}normalizeGroupName(e){return Z(e)}resetForNewSession(e=null){this.currentSessionId=e,this.scannedTokens.clear(),this._localStrategy&&this._localStrategy.scannedTokens?.clear(),this._networkedStrategy&&(this._networkedStrategy.scannedTokens?.clear(),this._networkedStrategy.transactions=[],this._networkedStrategy.playerScans=[],this._networkedStrategy.backendScores?.clear(),this._networkedStrategy.setSessionId?.(e)),this._log(`Reset for new session: ${e||"none"}`),this.dispatchEvent(new CustomEvent("data:cleared"))}clearAllData(){this.resetForNewSession()}getTeamCompletedGroups(e){return this._activeStrategy?.getTeamCompletedGroups?this._activeStrategy.getTeamCompletedGroups(e):[]}getEnhancedTeamTransactions(e){const t=this.getTeamTransactions(e),s=this.tokenManager?.getGroupInventory()||{},n=this.getTeamCompletedGroups(e),a=new Set(n.map(g=>g.normalizedName)),o={};n.forEach(g=>{o[g.normalizedName]={displayName:g.name,multiplier:g.multiplier,tokens:[],totalBaseValue:0,bonusValue:0}});const i={},r={},u=[],l=[];t.forEach(g=>{if(g.isUnknown){l.push(g);return}const p=this.parseGroupInfo(g.group),S=this.normalizeGroupName(p.name),w=s[S];if(!w||w.tokens.size<=1){u.push(g);return}const C=this.calculateTokenValue(g);a.has(S)?(i[S]||(i[S]=[]),i[S].push(g),o[S]&&(o[S].tokens.push(g),o[S].totalBaseValue+=C,o[S].bonusValue+=C*(p.multiplier-1))):(r[S]||(r[S]={displayName:w.displayName,multiplier:w.multiplier,tokens:[],totalTokens:w.tokens.size,collectedTokens:0}),r[S].tokens.push(g))}),Object.keys(r).forEach(g=>{const p=r[g];p.collectedTokens=p.tokens.length,p.progress=`${p.collectedTokens}/${p.totalTokens}`,p.percentage=Math.round(p.collectedTokens/p.totalTokens*100)});const h=Object.entries(i).map(([g,p])=>({...o[g],normalizedName:g,tokens:p})).sort((g,p)=>p.bonusValue-g.bonusValue),m=Object.values(r).sort((g,p)=>p.percentage-g.percentage);return{completedGroups:h,incompleteGroups:m,ungroupedTokens:u,unknownTokens:l,hasCompletedGroups:h.length>0,hasIncompleteGroups:m.length>0,hasUngroupedTokens:u.length>0,hasUnknownTokens:l.length>0}}calculateTeamScoreWithBonuses(e){const t=this.getTeamTransactions(e).filter(r=>r.mode==="blackmarket"&&!r.isUnknown),s=this.getTeamCompletedGroups(e),n=new Set(s.map(r=>r.normalizedName));let a=0,o=0;const i={};return s.forEach(r=>{i[r.name]={tokens:0,baseValue:0,bonusValue:0,multiplier:r.multiplier}}),t.forEach(r=>{const u=this.calculateTokenValue(r);a+=u;const l=this.parseGroupInfo(r.group),h=this.normalizeGroupName(l.name);if(n.has(h)){const m=u*(l.multiplier-1);o+=m,i[l.name]&&(i[l.name].tokens++,i[l.name].baseValue+=u,i[l.name].bonusValue+=m)}}),this._log(`Team ${e}: Base=$${a}, Bonus=$${o}`),{baseScore:a,bonusScore:o,totalScore:a+o,completedGroups:s.length,groupBreakdown:i}}getSessionStats(){const e=this.app?.currentTeamId;if(!e)return{count:0,totalValue:0,totalScore:0};const t=this.getTeamTransactions(e),s=t.length,a=t.filter(u=>!u.isUnknown).reduce((u,l)=>u+(l.valueRating||0),0),r=this.getTeamScores().find(u=>u.teamId===e)?.score||0;return{count:s,totalValue:a,totalScore:r}}getGlobalStats(){const e=this.getTransactions(),t=e.length,n=[...new Set(e.map(l=>l.teamId))].length,o=this.getTeamScores().reduce((l,h)=>l+(h.score||0),0),i=Math.floor(o/1e3),r=e.filter(l=>!l.isUnknown),u=r.length>0?(i/r.length).toFixed(1):0;return{total:t,teams:n,totalValue:i,avgValue:u,blackMarketScore:o}}updateTeamScoreFromBackend(e){if(!this._networkedStrategy){this._log("updateTeamScoreFromBackend called but no networked strategy active",!0);return}this._networkedStrategy.setBackendScores(e.teamId,{currentScore:e.currentScore,baseScore:e.baseScore,bonusPoints:e.bonusPoints,tokensScanned:e.tokensScanned,completedGroups:e.completedGroups,adminAdjustments:e.adminAdjustments||[],lastUpdate:e.lastUpdate}),this.dispatchEvent(new CustomEvent("team-score:updated",{detail:{teamId:e.teamId,scoreData:e,transactions:this.getTeamTransactions(e.teamId)}})),this._log(`Score updated from backend for team ${e.teamId}: $${e.currentScore}`)}handlePlayerScan(e){if(!this._networkedStrategy){this._log("handlePlayerScan called but no networked strategy active",!0);return}const t={id:e.scanId,tokenId:e.tokenId,deviceId:e.deviceId,timestamp:e.timestamp,memoryType:e.memoryType||null,videoQueued:e.videoQueued||!1,tokenData:e.tokenData||null};this._networkedStrategy.addPlayerScan(t),this.dispatchEvent(new CustomEvent("player-scan:added",{detail:{playerScan:t}})),this._log(`Player scan added: ${e.tokenId} from ${e.deviceId}`)}setPlayerScansFromServer(e){if(!this._networkedStrategy){this._log("setPlayerScansFromServer called but no networked strategy active",!0);return}if(!Array.isArray(e)){this._log("setPlayerScansFromServer: invalid input (not array)",!0);return}this._networkedStrategy.setPlayerScans(e),this._log(`Synced ${e.length} player scans from server`),this.dispatchEvent(new CustomEvent("player-scans:synced",{detail:{count:e.length}}))}setScannedTokensFromServer(e){if(!this._networkedStrategy){this._log("setScannedTokensFromServer called but no networked strategy active",!0);return}if(!Array.isArray(e)){this._log("setScannedTokensFromServer: invalid input (not array)",!0);return}this._networkedStrategy.setScannedTokens(e),this._syncScannedTokens(),this._log(`Synced ${e.length} scanned tokens from server`)}clearBackendScores(){if(!this._networkedStrategy){this._log("clearBackendScores called but no networked strategy active",!0);return}this._networkedStrategy.clearBackendScores(),this._log("Backend scores cleared"),this.dispatchEvent(new CustomEvent("scores:cleared"))}}let ne=class extends EventTarget{constructor(){super(),this.teams=new Map,this.mode=null,this.sessionModeManager=null,this.orchestratorClient=null}setMode(e){this.mode=e}getTeams(){return Array.from(this.teams.values())}getTeam(e){return this.teams.get(e)}hasTeam(e){return this.teams.has(e)}addTeam(e,t={}){if(!e||typeof e!="string")return console.warn("[TeamRegistry] Invalid teamId:",e),!1;const s=e.trim();if(!s)return console.warn("[TeamRegistry] Empty teamId after trim"),!1;const n=this.teams.get(s);return n?this.teams.set(s,{...n,...t,teamId:s}):(this.teams.set(s,{teamId:s,score:0,tokensScanned:0,...t}),this.dispatchEvent(new CustomEvent("team:added",{detail:{teamId:s,teamInfo:this.teams.get(s)}}))),this.dispatchEvent(new CustomEvent("teams:updated",{detail:{teams:this.getTeams()}})),!0}removeTeam(e){const t=this.teams.delete(e);return t&&this.dispatchEvent(new CustomEvent("teams:updated",{detail:{teams:this.getTeams()}})),t}clear(){this.teams.clear(),this.dispatchEvent(new CustomEvent("teams:updated",{detail:{teams:[]}}))}populateFromSession(e){e&&(this.teams.clear(),e.scores&&Array.isArray(e.scores)&&e.scores.forEach(t=>{this.teams.set(t.teamId,{teamId:t.teamId,score:t.currentScore||t.score||0,tokensScanned:t.tokensScanned||0,baseScore:t.baseScore||0,bonusPoints:t.bonusPoints||0})}),e.teams&&Array.isArray(e.teams)&&e.teams.forEach(t=>{this.teams.has(t)||this.teams.set(t,{teamId:t,score:0,tokensScanned:0})}),this.dispatchEvent(new CustomEvent("teams:updated",{detail:{teams:this.getTeams()}})))}populateFromStandaloneSession(e){e?.teams&&(this.teams.clear(),Object.entries(e.teams).forEach(([t,s])=>{this.teams.set(t,{teamId:t,score:s.score||0,tokensScanned:s.tokensScanned||0,baseScore:s.baseScore||0,bonusPoints:s.bonusPoints||0})}),this.dispatchEvent(new CustomEvent("teams:updated",{detail:{teams:this.getTeams()}})))}populateDropdown(e,t={}){if(!e)return;const{placeholder:s="Select Team...",selectedTeamId:n=null}=t;e.innerHTML="";const a=document.createElement("option");a.value="",a.textContent=s,a.disabled=!0,a.selected=!n,e.appendChild(a),this.getTeams().sort((i,r)=>i.teamId.localeCompare(r.teamId)).forEach(i=>{const r=document.createElement("option");r.value=i.teamId,r.textContent=i.teamId,i.teamId===n&&(r.selected=!0),e.appendChild(r)})}async selectTeam(e){if(!e?.trim())return{success:!1,error:"Team name required"};const t=e.trim();if(this.sessionModeManager?.isStandalone())return this._addToRecentTeams(t),{success:!0};if(!this.hasTeam(t)){const s=await this._createTeamOnBackend(t);if(!s.success)return s}return{success:!0}}getTeamsForDisplay(){return this.sessionModeManager?.isStandalone()?this._getRecentTeams():this.getTeams().map(e=>e.teamId)}getTeamListLabel(){return this.sessionModeManager?.isStandalone()?"Recent Teams:":"Session Teams:"}_getRecentTeams(){try{return JSON.parse(localStorage.getItem("aln_recent_teams")||"[]")}catch{return[]}}_addToRecentTeams(e){const t=this._getRecentTeams().filter(n=>n!==e);t.unshift(e);const s=t.slice(0,10);localStorage.setItem("aln_recent_teams",JSON.stringify(s))}async _createTeamOnBackend(e){if(!this.orchestratorClient)return{success:!1,error:"Not connected"};try{const t=await this.orchestratorClient.sendCommand("session:addTeam",{teamId:e});return t.success?(this.addTeam(e),{success:!0}):{success:!1,error:t.message||"Failed to create team"}}catch(t){return{success:!1,error:t.message}}}};class ae{constructor(){this.reader=null,this.isScanning=!1,this.lastRead=null,this.debounceMs=2e3}async init(){return"NDEFReader"in window}async startScan(e,t){if(!("NDEFReader"in window))throw new Error("NFC not supported");try{this.reader=new NDEFReader,this.reader.addEventListener("reading",({message:s,serialNumber:n})=>{try{const a=this.extractTokenId(s,n),o=Date.now(),i=a.id||n;if(i){if(this.lastRead&&this.lastRead.id===i&&o-this.lastRead.timestamp<this.debounceMs){d.log(`Debounced duplicate ${a.id?"read":"error"}: ${i}`);return}this.lastRead={id:i,timestamp:o}}e(a)}catch(a){console.error("Exception in NFC reading handler:",a),d.log(`Exception in NFC reading handler: ${a.message}`,!0)}}),this.reader.addEventListener("readingerror",s=>{d.log(`NFC Read Error: ${s}`,!0),t&&t(s)}),await this.reader.scan(),this.isScanning=!0}catch(s){throw d.log(`Error starting NFC: ${s.message}`,!0),s}}extractTokenId(e,t){if(d.log("‚ïê‚ïê‚ïê NFC TAG DETECTED ‚ïê‚ïê‚ïê"),d.log(`Serial: ${t}`),d.log(`Records: ${e.records?.length||0}`),!e.records||e.records.length===0)return d.log("No NDEF records found - returning error"),{id:null,source:"error",error:"no-ndef-records",raw:t};for(const s of e.records){if(d.log(`Record type: ${s.recordType}`),s.recordType==="text"){const a=new TextDecoder(s.encoding||"utf-8").decode(s.data);return d.log(`‚úÖ Text record: ${a}`),{id:a.trim(),source:"text-record",raw:a}}if(s.recordType==="url"){const a=new TextDecoder().decode(s.data);return d.log(`‚úÖ URL record: ${a}`),{id:a,source:"url-record",raw:a}}if(s.data)try{const n=new TextDecoder().decode(s.data);if(n&&n.trim())return d.log(`‚úÖ Generic decode: ${n}`),{id:n.trim(),source:"generic-decode",raw:n}}catch(n){d.log(`Decode failed: ${n.message}`)}}return d.log("No readable records found - returning error"),{id:null,source:"error",error:"unreadable-records",raw:t}}stopScan(){this.isScanning=!1}simulateScan(){const e=["a1b2c3d4","deadbeef","cafe1234","babe2468","feed5678","unknown_"+Math.random().toString(36).substr(2,9)],t=e[Math.floor(Math.random()*e.length)];return{id:t,source:"simulated",raw:t}}}const U=new ae;class oe{constructor(e={}){this.timeout=e.timeout||5e3}async validateAll(e){d.log("[StateValidation] Starting full validation...");const t={valid:!1,reason:null,details:{tokenValid:!1,orchestratorReachable:!1,sessionExists:!1}},s=localStorage.getItem("aln_auth_token");return s?this.isTokenValid(s)?(t.details.tokenValid=!0,d.log("[StateValidation] Token valid"),e?await this.checkOrchestratorHealth(e)?(t.details.orchestratorReachable=!0,d.log("[StateValidation] Orchestrator reachable"),await this.checkSessionExists(e)?(t.details.sessionExists=!0,d.log("[StateValidation] Session exists"),t.valid=!0,d.log("[StateValidation] All validations PASSED"),t):(t.reason="No active session on orchestrator",d.log(`[StateValidation] FAIL: ${t.reason}`),t)):(t.reason="Orchestrator unreachable",d.log(`[StateValidation] FAIL: ${t.reason}`),t):(t.reason="No orchestrator URL configured",d.log(`[StateValidation] FAIL: ${t.reason}`),t)):(t.reason="Authentication token expired",d.log(`[StateValidation] FAIL: ${t.reason}`),t):(t.reason="No authentication token found",d.log(`[StateValidation] FAIL: ${t.reason}`),t)}isTokenValid(e){try{const t=e.split(".");if(t.length!==3)return!1;const a=JSON.parse((typeof atob<"u"?r=>atob(r):r=>Buffer.from(r,"base64").toString())(t[1])).exp;if(!a)return!1;const o=Math.floor(Date.now()/1e3);return a-60>o}catch(t){return d.log(`[StateValidation] Token parse error: ${t.message}`),!1}}async checkOrchestratorHealth(e){try{const t=new AbortController,s=setTimeout(()=>t.abort(),this.timeout),n=await fetch(`${e}/health`,{method:"GET",signal:t.signal});return clearTimeout(s),n.ok}catch(t){return d.log(`[StateValidation] Health check error: ${t.message}`),!1}}async checkSessionExists(e){try{const t=new AbortController,s=setTimeout(()=>t.abort(),this.timeout),n=await fetch(`${e}/api/session`,{method:"GET",signal:t.signal});if(clearTimeout(s),!n.ok)return!1;const a=await n.json();return!!(a&&a.id)}catch(t){return d.log(`[StateValidation] Session check error: ${t.message}`),!1}}clearStaleState(){d.log("[StateValidation] Clearing stale state..."),localStorage.removeItem("aln_auth_token"),localStorage.removeItem("aln_game_session_mode"),localStorage.removeItem("aln_session_data"),d.log("[StateValidation] Stale state cleared")}}const O=new oe;function ie(c){c.init()}function re(c){const e=new c;return d.log("SessionModeManager initialized"),e}function ce(c){c.init()}function de(c){c.load()}function le(c,e){e.updateHistoryBadge()}async function ue(c){const e=await c.init();return d.log(`NFC support: ${e}`),e}async function me(c,e){if(!("serviceWorker"in c))return!1;try{const t=new URL("sw.js",window.location.href).pathname,s=await c.serviceWorker.register(t);return d.log("Service Worker registered successfully"),console.log("Service Worker registration successful:",s.scope),!0}catch(t){return t.name==="SecurityError"&&t.message.includes("SSL certificate error")?(d.log("Service Worker registration skipped due to SSL certificate (self-signed cert)"),console.warn("Service Worker not available due to self-signed certificate. Offline features disabled."),!1):(d.log("Service Worker registration failed"),console.error("Service Worker registration failed:",t),e.showError("Service Worker registration failed. Offline features may not work."),!1)}}async function he(c,e){if(!await c.loadDatabase()){const s="CRITICAL: Token database failed to load. Cannot initialize scanner.";throw d.log(s,!0),e.showError(s),new Error("Token database initialization failed")}return d.log("Token database loaded successfully"),!0}function ge(c,e){const s=new URLSearchParams(c).get("mode");return s==="blackmarket"||s==="black-market"?(e.mode="blackmarket",e.save(),d.log("Station mode set to blackmarket via URL parameter"),!0):!1}function pe(c){const e=c.restoreMode();if(!e)return{screen:"gameModeScreen",action:null,savedMode:null};if(e==="standalone")return{screen:"teamEntry",action:"initStandalone",savedMode:e};if(e==="networked"){const t=localStorage.getItem("aln_auth_token");return t&&Se(t)?{screen:"loading",action:"autoConnect",savedMode:e}:{screen:"gameModeScreen",action:"clearModeAndShowWizard",savedMode:e}}return{screen:"gameModeScreen",action:null,savedMode:null}}async function ye(c){const e=c.restoreMode();if(!e)return{screen:"gameModeScreen",action:null,savedMode:null,validationResult:null};if(e==="standalone")return{screen:"teamEntry",action:"initStandalone",savedMode:e,validationResult:null};if(e==="networked"){const t=localStorage.getItem("aln_orchestrator_url");d.log("[InitSteps] Performing full state validation for networked mode...");const s=await O.validateAll(t);return s.valid?(d.log("[InitSteps] Validation passed - attempting auto-connect"),{screen:"loading",action:"autoConnect",savedMode:e,validationResult:s}):(d.log(`[InitSteps] Validation failed: ${s.reason}`),O.clearStaleState(),{screen:"gameModeScreen",action:"clearModeAndShowWizard",savedMode:e,validationResult:s})}return{screen:"gameModeScreen",action:null,savedMode:null,validationResult:null}}function Se(c){try{const e=c.split(".");if(e.length!==3)return!1;let t;if(typeof atob<"u")t=i=>atob(i);else if(typeof Buffer<"u")t=i=>Buffer.from(i,"base64").toString();else return!1;const n=JSON.parse(t(e[1])).exp;if(!n)return!1;const a=Math.floor(Date.now()/1e3);return n-60>a}catch(e){return console.error("Token validation error:",e),!1}}async function fe(c,e,t,s,n=null){if(d.log(`Applying screen decision: screen=${c.screen}, action=${c.action}`),c.action==="clearModeAndShowWizard")d.log("Networked mode restored but no valid token - showing wizard"),e.clearMode(),t.showScreen(c.screen),s();else if(c.action==="initStandalone")d.log("Restoring standalone mode"),e.setMode("standalone"),t.showScreen(c.screen);else if(c.action==="autoConnect"){d.log("Valid token found - attempting auto-connect"),t.showScreen(c.screen);try{if(e.setMode("networked"),n)await n(),d.log("Auto-connect successful - showing team entry"),t.showScreen("teamEntry");else throw new Error("initNetworkedModeFn not provided for auto-connect")}catch(a){d.log("Auto-connect failed - showing wizard"),console.error("Auto-connect error:",a),e.clearMode(),t.showScreen("gameModeScreen"),s()}}else d.log(`Showing initial screen: ${c.screen}`),t.showScreen(c.screen)}async function ve(c){c.showScreen("loading"),await new Promise(e=>setTimeout(e,100)),d.log("Loading screen displayed")}const q={initializeUIManager:ie,createSessionModeManager:re,initializeViewController:ce,loadSettings:de,loadDataManager:le,detectNFCSupport:ue,registerServiceWorker:me,loadTokenDatabase:he,applyURLModeOverride:ge,determineInitialScreen:pe,validateAndDetermineInitialScreen:ye,applyInitialScreenDecision:fe,showLoadingScreen:ve};class ke{constructor(){this.mode=null,this.locked=!1}setMode(e){if(this.locked)throw new Error("Cannot change session mode after it is locked");if(e!=="networked"&&e!=="standalone")throw new Error(`Invalid session mode: ${e}. Must be 'networked' or 'standalone'`);this.mode=e,this.locked=!0,this._persistMode(e)}isNetworked(){return this.mode==="networked"}isStandalone(){return this.mode==="standalone"}restoreMode(){const e=this._getPersistedMode();return e&&(e==="networked"||e==="standalone")?(this.mode=e,e):null}clearMode(){this.mode=null,this.locked=!1,this._clearPersistedMode()}getMode(){return this.mode}isLocked(){return this.locked}_persistMode(e){try{localStorage.setItem("gameSessionMode",e)}catch(t){console.error("Failed to persist session mode:",t)}}_getPersistedMode(){try{return localStorage.getItem("gameSessionMode")}catch(e){return console.error("Failed to read persisted session mode:",e),null}}_clearPersistedMode(){try{localStorage.removeItem("gameSessionMode")}catch(e){console.error("Failed to clear persisted session mode:",e)}}}class we extends EventTarget{constructor(e={}){super(),this.config={url:e.url||"https://localhost:3000",deviceId:e.deviceId||"GM_STATION_UNKNOWN",version:"1.0.0",transports:["websocket"]},this.socket=null,this.isConnected=!1,this.connectionTimeout=null}async connect(e,t){return this.socket?.connected&&console.warn("OrchestratorClient: Already connected, cleaning up old socket"),this._cleanup(),this.socket=io(this.config.url,{transports:this.config.transports,reconnection:!1,timeout:1e4,auth:{token:e,deviceId:t.deviceId,deviceType:t.deviceType,version:this.config.version}}),this._setupSocketHandlers(),new Promise((s,n)=>{const a=()=>{this.connectionTimeout&&(clearTimeout(this.connectionTimeout),this.connectionTimeout=null),this.isConnected=!0,this.dispatchEvent(new CustomEvent("socket:connected")),s()},o=i=>{this.connectionTimeout&&(clearTimeout(this.connectionTimeout),this.connectionTimeout=null),this.dispatchEvent(new CustomEvent("socket:error",{detail:{error:i}})),n(i)};this.connectionTimeout=setTimeout(()=>{this.socket&&(this.socket.off("connect",a),this.socket.off("connect_error",o)),this.connectionTimeout=null,n(new Error("Connection timeout"))},1e4),this.socket.once("connect",a),this.socket.once("connect_error",o)})}send(e,t){if(!this.socket?.connected)throw new Error("Socket not connected");this.socket.emit(e,{event:e,data:t,timestamp:new Date().toISOString()})}async sendCommand(e,t={},s=5e3){if(!this.socket?.connected)throw new Error("Socket not connected");return new Promise((n,a)=>{const o=setTimeout(()=>{r(),a(new Error(`Command ${e} timed out`))},s),i=u=>{const l=u.data||u;l.action===e&&(r(),n({success:l.success,message:l.message||""}))},r=()=>{clearTimeout(o),this.socket.off("gm:command:ack",i)};this.socket.on("gm:command:ack",i),this.socket.emit("gm:command",{event:"gm:command",data:{action:e,payload:t},timestamp:new Date().toISOString()})})}async disconnect(){if(this.socket)return new Promise(e=>{if(!this.socket.connected){this._cleanup(),e();return}this.socket.once("disconnect",t=>{this.dispatchEvent(new CustomEvent("socket:disconnected",{detail:{reason:t}})),this._cleanup(),e()}),this.socket.disconnect(),setTimeout(()=>{this._cleanup(),e()},1e3)})}destroy(){this._cleanup()}_setupSocketHandlers(){this.socket&&(this.socket.on("connect",()=>{this.isConnected=!0,this.dispatchEvent(new CustomEvent("socket:connected"))}),this.socket.on("disconnect",e=>{this.isConnected=!1,this.dispatchEvent(new CustomEvent("socket:disconnected",{detail:{reason:e}}))}),this.socket.on("connect_error",e=>{this.dispatchEvent(new CustomEvent("socket:error",{detail:{error:e}}))}),this._setupMessageHandlers())}_setupMessageHandlers(){["sync:full","transaction:result","transaction:new","transaction:deleted","score:updated","scores:reset","video:status","session:update","session:overtime","device:connected","device:disconnected","group:completed","display:mode","video:progress","video:queue:update","gm:command:ack","offline:queue:processed","batch:ack","error","player:scan"].forEach(t=>{this.socket.on(t,s=>{const n=s.data||s;this.dispatchEvent(new CustomEvent("message:received",{detail:{type:t,payload:n}}))})})}_cleanup(){this.connectionTimeout&&(clearTimeout(this.connectionTimeout),this.connectionTimeout=null),this.socket&&(this.socket.removeAllListeners(),this.socket.connected&&this.socket.disconnect(),this.socket=null),this.isConnected=!1}}class Te extends EventTarget{constructor(e={}){super(),this.config={url:e.url||"https://localhost:3000",deviceId:e.deviceId||"GM_STATION_UNKNOWN",deviceType:"gm"},this.client=e.client,this.token=e.token||null,this.state="disconnected",this.retryCount=0,this.maxRetries=e.maxRetries||5,this.retryTimer=null,this.disconnectHandler=null,this.addEventListener("connecting",()=>this._updateGlobalConnectionStatus("connecting")),this.addEventListener("connected",()=>this._updateGlobalConnectionStatus("connected")),this.addEventListener("disconnected",()=>this._updateGlobalConnectionStatus("disconnected"))}isTokenValid(){if(!this.token)return!1;try{const e=this.token.split(".");if(e.length!==3)return!1;const s=JSON.parse(atob(e[1])).exp;if(!s)return!1;const n=Math.floor(Date.now()/1e3);return s-60>n}catch{return!1}}async checkHealth(){try{const e=new AbortController,t=setTimeout(()=>e.abort(),5e3),s=await fetch(`${this.config.url}/health`,{method:"GET",mode:"cors",signal:e.signal});return clearTimeout(t),s.ok}catch{return!1}}async connect(){if(!this.isTokenValid())throw this.dispatchEvent(new CustomEvent("auth:required",{detail:{reason:"invalid_token"}})),new Error("Invalid or expired token");if(!await this.checkHealth())throw new Error("Orchestrator unreachable");this._clearRetryTimer(),this.state="connecting",this.dispatchEvent(new CustomEvent("connecting"));try{await this.client.connect(this.token,{deviceId:this.config.deviceId,deviceType:this.config.deviceType}),this.state="connected",this.retryCount=0,this.dispatchEvent(new CustomEvent("connected")),this._setupReconnectionHandler()}catch(t){throw this.state="disconnected",this.retryCount++,this.retryCount<this.maxRetries?this._scheduleRetry():this.dispatchEvent(new CustomEvent("auth:required",{detail:{reason:"max_retries"}})),t}}async disconnect(){this._clearRetryTimer(),this._removeReconnectionHandler(),this.client&&await this.client.disconnect(),this.state="disconnected"}updateToken(e){this.token=e}_setupReconnectionHandler(){this.disconnectHandler&&this._removeReconnectionHandler(),this.disconnectHandler=e=>{const t=e.detail?.reason;if(this.state="disconnected",this.dispatchEvent(new CustomEvent("disconnected",{detail:{reason:t}})),t==="io server disconnect"){if(!this.isTokenValid()){this.dispatchEvent(new CustomEvent("auth:required",{detail:{reason:"token_expired"}}));return}setTimeout(()=>{this.connect().catch(()=>{})},1e3)}},this.client.addEventListener("socket:disconnected",this.disconnectHandler)}_removeReconnectionHandler(){this.disconnectHandler&&(this.client.removeEventListener("socket:disconnected",this.disconnectHandler),this.disconnectHandler=null)}_scheduleRetry(){const e=this._calculateRetryDelay();this.retryTimer=setTimeout(()=>{this.connect().catch(()=>{})},e)}_calculateRetryDelay(){const s=1e3*Math.pow(2,this.retryCount);return Math.min(s,3e4)}_clearRetryTimer(){this.retryTimer&&(clearTimeout(this.retryTimer),this.retryTimer=null)}_updateGlobalConnectionStatus(e){const t=document.getElementById("connectionStatus");if(!t)return;t.classList.remove("connected","connecting","disconnected"),t.classList.add(e);const s=t.querySelector(".status-text");if(s){const n={connecting:"Connecting...",connected:"Connected",disconnected:"Disconnected"};s.textContent=n[e]||"Unknown"}}}class be extends EventTarget{constructor(e={}){super(),this.client=e.client,this.debug=e.debug||console,this.deviceId=e.deviceId||"GM_STATION_UNKNOWN",this.tempQueue=[],this.syncing=!1,this.activeHandlers=new Map,this.loadQueue(),this.mergeOrphanedTransactions()}mergeOrphanedTransactions(){try{const e=localStorage.getItem("pendingNetworkedTransactions");if(e){const t=JSON.parse(e);Array.isArray(t)&&t.length>0&&(this.debug.log("Merging orphaned transactions",{count:t.length}),this.tempQueue.push(...t),localStorage.removeItem("pendingNetworkedTransactions"),this.saveQueue(),this.debug.log("Orphaned transactions merged successfully",{totalQueueSize:this.tempQueue.length}))}}catch(e){this.debug.error?.("Failed to merge orphaned transactions",e)}}queueTransaction(e){!this.client||!this.client.isConnected?(this.tempQueue.push(e),this.saveQueue(),this.debug.log("Transaction queued for later submission",{tokenId:e.tokenId,queueSize:this.tempQueue.length}),this.dispatchEvent(new CustomEvent("queue:changed",{detail:this.getStatus()}))):(this.client.send("transaction:submit",e),this.debug.log("Transaction sent immediately",{tokenId:e.tokenId}))}async syncQueue(){if(this.syncing||this.tempQueue.length===0||!this.client||!this.client.isConnected)return;this.syncing=!0,this.debug.log("Starting queue sync via WebSocket replay",{queueSize:this.tempQueue.length});const e=[...this.tempQueue],t=[];try{for(let o=0;o<e.length;o++){const i=e[o];this.debug.log(`Replaying transaction ${o+1}/${e.length}`,{tokenId:i.tokenId,teamId:i.teamId});try{const r=await this.replayTransaction(i);t.push({success:!0,transaction:i,result:r})}catch(r){let u="unknown";const l=r.message.toLowerCase();l.includes("timeout")?u="timeout":l.includes("validation")||l.includes("invalid")?u="validation":(l.includes("network")||l.includes("connection"))&&(u="network"),this.debug.error?.(`Transaction replay failed (${u})`,{tokenId:i.tokenId,error:r.message,errorType:u}),t.push({success:!1,transaction:i,error:r.message,errorType:u})}}const s=t.filter(o=>o.success).length,n=t.filter(o=>!o.success).length,a=t.filter(o=>!o.success).reduce((o,i)=>(o[i.errorType]=(o[i.errorType]||0)+1,o),{});this.debug.log("Queue sync complete",{total:e.length,success:s,failed:n,errorBreakdown:a}),this.tempQueue=[],this.saveQueue()}catch(s){this.debug.error?.("Queue sync failed - keeping queue for retry",{error:s.message,queueSize:this.tempQueue.length})}finally{this.syncing=!1,this.dispatchEvent(new CustomEvent("queue:changed",{detail:this.getStatus()}))}}replayTransaction(e){return new Promise((t,s)=>{const n=`${e.tokenId}-${e.teamId}`,a=(r,u)=>{clearTimeout(r),this.client.removeEventListener("message:received",u),this.activeHandlers.delete(n)},o=setTimeout(()=>{const r=this.activeHandlers.get(n);r&&a(o,r),s(new Error(`Transaction replay timeout after 30s: ${e.tokenId}`))},3e4),i=r=>{const{type:u,payload:l}=r.detail;u==="transaction:result"&&l.tokenId===e.tokenId&&l.teamId===e.teamId&&(a(o,i),l.status==="error"?s(new Error(l.message||"Transaction failed")):t(l))};this.activeHandlers.set(n,i),this.client.addEventListener("message:received",i),this.client.send("transaction:submit",e),this.debug.log("Transaction submitted for replay",{tokenId:e.tokenId,teamId:e.teamId})})}saveQueue(){try{this.tempQueue.length>0?localStorage.setItem("networkedTempQueue",JSON.stringify(this.tempQueue)):localStorage.removeItem("networkedTempQueue")}catch(e){e.name==="QuotaExceededError"?(this.debug.error?.("localStorage quota exceeded - unable to save queue",{queueSize:this.tempQueue.length,error:e.message}),alert("Storage full: Unable to queue transactions offline. Please sync or clear data.")):this.debug.error?.("Failed to save queue to localStorage",e)}}loadQueue(){try{const e=localStorage.getItem("networkedTempQueue");e&&(this.tempQueue=JSON.parse(e),this.debug.log("Loaded queued transactions",{count:this.tempQueue.length}))}catch(e){this.debug.error?.("Failed to load queue",e),this.tempQueue=[]}}clearQueue(){this.tempQueue=[],localStorage.removeItem("networkedTempQueue"),this.debug.log("Queue cleared")}getStatus(){return{queuedCount:this.tempQueue.length,syncing:this.syncing}}destroy(){for(const[e,t]of this.activeHandlers.entries())this.client.removeEventListener("message:received",t);this.activeHandlers.clear(),this.client=null}}function f(c,e,t,s=5e3){return new Promise((n,a)=>{const o=setTimeout(()=>{c.removeEventListener("message:received",i),a(new Error(`${e} timeout after ${s}ms`))},s),i=r=>{const{type:u,payload:l}=r.detail;u==="gm:command:ack"&&(clearTimeout(o),c.removeEventListener("message:received",i),l.success?n(l):a(new Error(l.message||`Command failed: ${e}`)))};c.addEventListener("message:received",i),c.send("gm:command",{action:e,payload:t})})}class Ie{constructor(e){this.connection=e,this.currentSession=null,this._messageHandler=this._handleMessage.bind(this),this.connection.addEventListener("message:received",this._messageHandler)}_handleMessage(e){const{type:t,payload:s}=e.detail;t==="session:update"&&(this.currentSession=s),t==="sync:full"&&s.session&&(this.currentSession=s.session)}async createSession(e,t=[]){return f(this.connection,"session:create",{name:e,teams:t})}async pauseSession(){if(this.currentSession)return f(this.connection,"session:pause",{})}async resumeSession(){if(this.currentSession)return f(this.connection,"session:resume",{})}async endSession(){if(this.currentSession)return f(this.connection,"session:end",{})}getSession(){return this.currentSession}isActive(){return this.currentSession?.status==="active"}isPaused(){return this.currentSession?.status==="paused"}destroy(){this.connection&&this._messageHandler&&this.connection.removeEventListener("message:received",this._messageHandler)}}class Me{constructor(e){this.connection=e,this.currentVideo=null,this.queueLength=0}async playVideo(){return f(this.connection,"video:play",{})}async pauseVideo(){return f(this.connection,"video:pause",{})}async stopVideo(){return f(this.connection,"video:stop",{})}async skipVideo(){return f(this.connection,"video:skip",{})}async addToQueue(e){return f(this.connection,"video:queue:add",{videoFile:e})}async reorderQueue(e,t){return f(this.connection,"video:queue:reorder",{fromIndex:e,toIndex:t})}async clearQueue(){return f(this.connection,"video:queue:clear",{})}destroy(){}}class Ee{constructor(e){this.connection=e}async setIdleLoop(){return f(this.connection,"display:idle-loop",{})}async setScoreboard(){return f(this.connection,"display:scoreboard",{})}async toggleDisplayMode(){return f(this.connection,"display:toggle",{})}async getDisplayStatus(){return f(this.connection,"display:status",{})}destroy(){}}class _e{constructor(e){this.connection=e,this.backendHealth=null,this.vlcHealth=null}async checkHealth(){try{const e=this.connection?.config?.url||"http://localhost:3000",t=await fetch(`${e}/health`);return this.backendHealth=t.ok?"healthy":"unhealthy",this.backendHealth}catch(e){throw this.backendHealth="error",e}}getBackendHealth(){return this.backendHealth}getVlcHealth(){return this.vlcHealth}setVlcHealth(e){this.vlcHealth=e}destroy(){}}class Ce{constructor(e){this.connection=e,this._messageHandler=this._handleMessage.bind(this),this.connection.addEventListener("message:received",this._messageHandler)}_handleMessage(e){const{type:t}=e.detail;t==="scores:reset"&&d.log("[AdminOperations] Scores reset broadcast received")}async restartSystem(){return f(this.connection,"system:restart",{})}async clearData(){return f(this.connection,"system:clear",{})}async resetScores(){return f(this.connection,"score:reset",{})}async adjustScore(e,t,s="Admin adjustment"){return f(this.connection,"score:adjust",{teamId:e,delta:t,reason:s})}async deleteTransaction(e){return f(this.connection,"transaction:delete",{transactionId:e})}destroy(){this.connection&&this._messageHandler&&this.connection.removeEventListener("message:received",this._messageHandler)}}class $e{constructor(e,t,s=null){this.client=e,this.dataManager=t,this.teamRegistry=s,this.devices=[],this.overtimeData=null,this._currentSession=null,this.isVideoPlaying=!1,this.currentIdleMode="IDLE_LOOP",this._messageHandler=this._handleMessage.bind(this),this.client.addEventListener("message:received",this._messageHandler),this.loadAvailableVideos(),this._requestInitialState()}_sendMessage(e,t){this.client?.socket?.connected?this.client.socket.emit(e,t):console.warn("[MonitoringDisplay] Cannot send message - disconnected")}_requestInitialState(){this.client?.socket?.connected?(this.client.socket.emit("sync:request"),console.log("[MonitoringDisplay] Requested initial state via sync:request")):console.warn("[MonitoringDisplay] Cannot request state - socket not connected")}_handleMessage(e){const{type:t,payload:s}=e.detail;switch(d.log(`[MonitoringDisplay] _handleMessage called: ${t}`),t){case"transaction:new":this._handleTransactionNew(s);break;case"score:updated":this._handleScoreUpdated(s);break;case"session:update":this._handleSessionUpdate(s);break;case"session:overtime":this._handleSessionOvertime(s);break;case"video:status":this.updateVideoDisplay(s);break;case"display:mode":this._handleDisplayMode(s);break;case"video:progress":this.updateVideoProgress(s);break;case"video:queue:update":this.updateQueueDisplay(s);break;case"device:connected":this._handleDeviceConnected(s);break;case"device:disconnected":this._handleDeviceDisconnected(s);break;case"scores:reset":this._handleScoresReset();break;case"transaction:deleted":this._handleTransactionDeleted(s);break;case"sync:full":this.updateAllDisplays(s);break;case"gm:command:ack":s.success&&s.action&&(s.action==="display:scoreboard"?this._handleDisplayMode({mode:"SCOREBOARD"}):s.action==="display:idle-loop"&&this._handleDisplayMode({mode:"IDLE_LOOP"}));break}}_handleTransactionNew(e){e?.transaction&&d.log("[MonitoringDisplay] transaction:new received (UI updates via ScreenUpdateManager)")}_handleScoreUpdated(e){d.log("[MonitoringDisplay] Score updated event received")}_handleSessionUpdate(e){this.updateSessionDisplay(e),this.teamRegistry&&this.teamRegistry.populateFromSession(e),e.status==="ended"?(d.log("[MonitoringDisplay] Session ended, clearing admin panel displays"),this.overtimeData=null,this._clearAdminPanelDisplays()):e.status==="active"&&(this.overtimeData=null,this._requestInitialState())}_clearAdminPanelDisplays(){const e=document.getElementById("admin-game-activity");e&&(e.innerHTML="");const t=document.getElementById("admin-score-board");t&&(t.innerHTML=""),d.log("[MonitoringDisplay] Admin panel displays cleared")}_handleSessionOvertime(e){d.log("[MonitoringDisplay] Session overtime warning received:",e),this.overtimeData=e,this.updateSessionDisplay(this._currentSession||e)}_handleDeviceConnected(e){this.devices.findIndex(s=>s.deviceId===e.deviceId)===-1&&this.devices.push(e),this.updateDeviceList(this.devices),this.updateSystemDisplay()}_handleDeviceDisconnected(e){this.devices=this.devices.filter(t=>t.deviceId!==e.deviceId),this.updateDeviceList(this.devices),this.updateSystemDisplay()}_handleScoresReset(){d.log("[MonitoringDisplay] Scores reset broadcast received")}_handleTransactionDeleted(e){d.log("[MonitoringDisplay] Transaction deleted:",e?.transactionId);const t=document.getElementById("admin-transaction-log");if(t&&e?.transactionId){const s=t.querySelector(`[data-transaction-id="${e.transactionId}"]`);s&&s.remove()}}_handleDisplayMode(e){if(!e?.mode)return;const t=document.getElementById("now-showing-value"),s=document.getElementById("now-showing-icon"),n=document.getElementById("returns-to-container"),a=document.getElementById("btn-idle-loop"),o=document.getElementById("btn-scoreboard");a?.classList.toggle("active",e.mode==="IDLE_LOOP"),o?.classList.toggle("active",e.mode==="SCOREBOARD"),this.currentIdleMode=e.mode,this.isVideoPlaying||(e.mode==="IDLE_LOOP"?(t&&(t.textContent="Idle Loop"),s&&(s.textContent="üîÑ")):e.mode==="SCOREBOARD"&&(t&&(t.textContent="Scoreboard"),s&&(s.textContent="üèÜ")),n&&(n.style.display="none")),d.log(`[MonitoringDisplay] Display mode updated: ${e.mode}`)}updateTransactionDisplay(e){if(!e)return;const t=document.getElementById("admin-transaction-log");if(!t)return;const s=e.timestamp?new Date(e.timestamp).toLocaleTimeString():"-",n=e.memoryType||"UNKNOWN",a=e.status==="duplicate",o=a?" duplicate":"",i=a?' <span class="duplicate-badge-small">DUP</span>':"",r=`
      <div class="transaction-item${o}" data-transaction-id="${e.id||""}">
        <span class="tx-time">${s}</span>
        <span class="tx-team">${e.teamId||"-"}</span>
        <span class="tx-token">${e.tokenId||"-"}${i}</span>
        <span class="tx-type">${n}</span>
      </div>
    `;t.innerHTML=r+t.innerHTML;const u=t.querySelectorAll(".transaction-item");if(u.length>10)for(let l=10;l<u.length;l++)u[l].remove()}updateDeviceList(e){if(!Array.isArray(e))return;this.devices=e;const t=document.getElementById("device-count"),s=document.getElementById("device-list");t&&(t.textContent=String(e.length)),s&&(e.length===0?s.innerHTML='<p class="text-muted text-sm">No devices connected</p>':s.innerHTML=e.map(n=>`
          <div class="device-item">
            <span>${n.deviceId||"Unknown"}</span>
            <span class="device-type">${n.type||"-"}</span>
          </div>
        `).join(""))}updateSessionDisplay(e){const t=document.getElementById("session-status-container");if(!t){d.log("session-status-container not found in DOM",!0);return}if(this._currentSession=e,!e){t.innerHTML=this._renderNoSession();return}if(e.status==="ended"){t.innerHTML=this._renderEndedSession(e);return}if(e.status==="paused"){t.innerHTML=this._renderPausedSession(e);return}t.innerHTML=this._renderActiveSession(e)}_renderNoSession(){return`
      <div class="session-status session-status--empty">
        <p class="session-status__message">No Active Session</p>
        <p class="session-status__hint">Create a new session to begin tracking gameplay</p>
        <button class="btn btn-primary" data-action="app.adminCreateSession">
          Create New Session
        </button>
      </div>
    `}_renderEndedSession(e){const t=e.endTime?new Date(e.endTime).toLocaleString():"Unknown",s=e.getDuration?this.formatDuration(e.getDuration()):"Unknown";return`
      <div class="session-status session-status--ended">
        <h4 class="session-status__header">
          <span class="session-status__icon">‚ö†Ô∏è</span>
          <span>Previous Session Ended</span>
        </h4>
        <div class="session-status__details">
          <p class="session-status__name">${this.escapeHtml(e.name||"Unnamed Session")}</p>
          <p class="session-status__meta">Ended: ${this.escapeHtml(t)}</p>
          <p class="session-status__meta">Duration: ${this.escapeHtml(s)}</p>
          <p class="session-status__meta">Total Scans: ${e.metadata?.totalScans||0}</p>
        </div>
        <div class="session-status__actions">
          <button class="btn btn-primary" data-action="app.adminResetAndCreateNew">
            Reset & Start New Session
          </button>
          <button class="btn btn-secondary" data-action="app.adminViewSessionDetails">
            View Details
          </button>
        </div>
        <p class="session-status__tip">üí° Start a new session to continue gameplay</p>
      </div>
    `}_renderPausedSession(e){const t=e.startTime?new Date(e.startTime).toLocaleString():"Unknown";return`
      <div class="session-status session-status--paused">
        <h4 class="session-status__header">
          <span class="session-status__icon">‚è∏Ô∏è</span>
          <span>Session Paused</span>
        </h4>
        <div class="session-status__details">
          <p class="session-status__name">${this.escapeHtml(e.name||"Session")}</p>
          <p class="session-status__meta">Started: ${this.escapeHtml(t)}</p>
          <p class="session-status__meta">Scans: ${e.metadata?.totalScans||0}</p>
        </div>
        <div class="session-status__actions">
          <button class="btn btn-primary" data-action="app.adminResumeSession">
            Resume Session
          </button>
          <button class="btn btn-danger" data-action="app.adminEndSession">
            End Session
          </button>
        </div>
      </div>
    `}_renderActiveSession(e){const t=e.startTime?new Date(e.startTime).toLocaleString():"Unknown",s=e.metadata?.totalScans||0;let n="";if(this.overtimeData){const a=this.overtimeData.expectedDuration||120,o=this.overtimeData.actualDuration||a,i=this.overtimeData.overtimeDuration||0;n=`
        <div class="session-overtime-warning">
          <div class="session-overtime-warning__content">
            <span class="session-overtime-warning__icon">‚ö†Ô∏è</span>
            <div class="session-overtime-warning__text">
              <strong>Session Running Overtime</strong>
              <p>Expected: ${a} min | Actual: ${o} min | Overtime: <strong>${i} min</strong></p>
            </div>
          </div>
        </div>
      `}return`
      <div class="session-status session-status--active">
        <h4 class="session-status__header">
          <span class="session-status__icon">‚úÖ</span>
          <span>${this.escapeHtml(e.name||"Active Session")}</span>
        </h4>
        ${n}
        <div class="session-status__details">
          <p class="session-status__meta">Started: ${this.escapeHtml(t)}</p>
          <p class="session-status__meta">Total Scans: ${s}</p>
          <p class="session-status__meta">Status: <span class="status-active">Active</span></p>
        </div>
        <div class="session-status__actions">
          <button class="btn btn-secondary" data-action="app.adminPauseSession">
            Pause
          </button>
          <button class="btn btn-danger" data-action="app.adminEndSession">
            End Session
          </button>
        </div>
      </div>
    `}updateVideoDisplay(e){if(!e)return;const t=document.getElementById("admin-current-video"),s=document.getElementById("admin-queue-length"),n=document.getElementById("now-showing-value"),a=document.getElementById("now-showing-icon"),o=document.getElementById("returns-to-container"),i=document.getElementById("returns-to-mode"),r=document.getElementById("pending-queue-count");if(t)if(e.status==="playing"&&e.tokenId){const u=e.progress||0;t.textContent=`${e.tokenId} (${u}%)`}else t.textContent=e.tokenId||"None (idle loop)";s&&(s.textContent=String(e.queueLength||0)),r&&(r.textContent=String(e.queueLength||0)),e.status==="playing"&&e.tokenId?(this.isVideoPlaying=!0,n&&(n.textContent=`${e.tokenId}.mp4`),a&&(a.textContent="‚ñ∂Ô∏è"),o&&(o.style.display="block"),i&&(i.textContent=this.currentIdleMode==="SCOREBOARD"?"Scoreboard":"Idle Loop")):e.status==="idle"&&(this.isVideoPlaying=!1,this.currentIdleMode==="SCOREBOARD"?(n&&(n.textContent="Scoreboard"),a&&(a.textContent="üèÜ")):(n&&(n.textContent="Idle Loop"),a&&(a.textContent="üîÑ")),o&&(o.style.display="none"))}updateVideoProgress(e){if(!e)return;const t=document.getElementById("admin-current-video"),s=document.getElementById("video-progress-container"),n=document.getElementById("video-progress-fill"),a=document.getElementById("video-progress-time");if(t&&e.tokenId&&e.progress!==void 0){const o=Math.round(e.progress),i=Math.round(e.position),r=Math.round(e.duration);t.textContent=`${e.tokenId} (${o}% - ${i}s/${r}s)`,s&&(s.style.display="block"),n&&(n.style.width=`${o}%`),a&&(a.textContent=`${i}s / ${r}s`)}else s&&(s.style.display="none")}updateQueueDisplay(e){if(!e)return;const t=document.getElementById("video-queue-container"),s=document.getElementById("video-queue-list"),n=document.getElementById("queue-count");if(!(!t||!s||!n)){if(!e.items||e.items.length===0){t.style.display="none";return}t.style.display="block",n.textContent=e.items.length,s.innerHTML=e.items.map((a,o)=>`
      <div class="queue-item">
        <span class="queue-item__index">${o+1}.</span>
        <span class="queue-item__name">${a.tokenId}</span>
        <span class="queue-item__duration">(${a.duration}s)</span>
      </div>
    `).join("")}}async loadAvailableVideos(){try{const e=this.client?.config?.url||"http://localhost:3000",s=await(await fetch(`${e}/api/tokens`)).json(),n=document.getElementById("available-videos");if(!n)return;const a=Object.entries(s.tokens).filter(([,o])=>o.video).map(([o,i])=>`<option value="${i.video}">${o} - ${i.video}</option>`).join("");n.innerHTML=a,d.log(`Loaded video options: ${Object.keys(s.tokens).filter(o=>s.tokens[o].video).length}`)}catch(e){d.log(`Failed to load available videos: ${e.message}`,!0)}}updateSystemDisplay(){if(!this.client)return;const e=document.getElementById("orchestrator-status");if(e){const t=this.client.isConnected?"connected":"disconnected";e.className=`status-dot status-dot--${t}`,e.title=t}}updateAllDisplays(e){if(e){if(this.updateSessionDisplay(e.session||null),e.session&&this.teamRegistry&&this.teamRegistry.populateFromSession(e.session),e.videoStatus&&this.updateVideoDisplay(e.videoStatus),e.recentTransactions&&Array.isArray(e.recentTransactions)){const t=document.getElementById("admin-transaction-log");t&&(t.innerHTML="",e.recentTransactions.slice(-10).reverse().forEach(n=>this.updateTransactionDisplay(n)))}if(e.systemStatus){const t=document.getElementById("vlc-status");if(t){const s=e.systemStatus.vlc;t.className=`status-dot status-dot--${s==="connected"?"connected":"disconnected"}`,t.title=s}}e.devices&&Array.isArray(e.devices)&&this.updateDeviceList(e.devices),this.updateSystemDisplay()}}refreshAllDisplays(){d.log("[MonitoringDisplay] refreshAllDisplays called"),d.log(`[MonitoringDisplay] Refreshing session display. Current session: ${this._currentSession?this._currentSession.id:"null"}`),this.updateSessionDisplay(this._currentSession),this.devices?.length>0&&this.updateDeviceList(this.devices),this.updateSystemDisplay(),this.loadAvailableVideos()}resume(){console.log("[MonitoringDisplay] Resuming monitoring..."),this._requestInitialState()}escapeHtml(e){if(!e)return"";const t=document.createElement("div");return t.textContent=e,t.innerHTML}formatDuration(e){if(!e||e<0)return"Unknown";const t=Math.floor(e/1e3),s=Math.floor(t/60),n=Math.floor(s/60);return n>0?`${n}h ${s%60}m`:s>0?`${s}m ${t%60}s`:`${t}s`}destroy(){this.client&&this._messageHandler&&this.client.removeEventListener("message:received",this._messageHandler)}}class De extends EventTarget{constructor(e,t,s=null){super(),this.client=e,this.dataManager=t,this.teamRegistry=s,this.modules=null,this.initialized=!1}initialize(){if(this.initialized){console.warn("AdminController: Already initialized");return}this.modules={sessionManager:new Ie(this.client),videoController:new Me(this.client),displayController:new Ee(this.client),systemMonitor:new _e(this.client),adminOperations:new Ce(this.client),monitoringDisplay:new $e(this.client,this.dataManager,this.teamRegistry)},this.initialized=!0,this.dispatchEvent(new CustomEvent("initialized"))}getModule(e){if(!this.initialized)throw new Error("Admin modules not initialized");if(!this.modules[e])throw new Error(`Unknown module: ${e}`);return this.modules[e]}pause(){this.modules&&(this.modules.sessionManager?.pause&&this.modules.sessionManager.pause(),this.modules.videoController?.pause&&this.modules.videoController.pause())}resume(){this.modules&&(this.modules.sessionManager?.resume&&this.modules.sessionManager.resume(),this.modules.videoController?.resume&&this.modules.videoController.resume(),this.modules.monitoringDisplay?.resume&&this.modules.monitoringDisplay.resume())}destroy(){this.modules&&(Object.values(this.modules).forEach(e=>{e?.destroy&&e.destroy()}),this.modules=null,this.initialized=!1)}}class Ae extends EventTarget{constructor(e,t,s=null){super(),this.config=e,this.dataManager=t,this.teamRegistry=s,this.services=null,this.state="disconnected"}async initialize(){if(this.services)throw new Error("Session already initialized");try{this._createServices(),this._wireEventHandlers(),await this._initiateConnection(),this.state="connected",this.dispatchEvent(new CustomEvent("session:ready",{detail:{services:this.services}}))}catch(e){throw this.state="error",await this.destroy(),this.dispatchEvent(new CustomEvent("session:error",{detail:{error:e}})),e}}getService(e){if(!this.services)throw new Error("Session not initialized");if(!this.services[e])throw new Error(`Unknown service: ${e}`);return this.services[e]}async destroy(){this.services&&(this.services.adminController&&this.services.adminController.destroy(),this.services.queueManager&&this.services.queueManager.destroy(),this.services.connectionManager&&(this._connectedHandler&&this.services.connectionManager.removeEventListener("connected",this._connectedHandler),this._disconnectedHandler&&this.services.connectionManager.removeEventListener("disconnected",this._disconnectedHandler),this._authRequiredHandler&&this.services.connectionManager.removeEventListener("auth:required",this._authRequiredHandler),await this.services.connectionManager.disconnect()),this.services.client&&(this._messageHandler&&this.services.client.removeEventListener("message:received",this._messageHandler),this.services.client.destroy()),this.services=null,this.state="disconnected")}_createServices(){this.services={},this.services.client=new we({url:this.config.url,deviceId:this.config.deviceId}),this.services.connectionManager=new Te({url:this.config.url,deviceId:this.config.deviceId,token:this.config.token,client:this.services.client}),this.services.queueManager=new be({client:this.services.client,deviceId:this.config.deviceId,debug:console}),this.services.adminController=new De(this.services.client,this.dataManager,this.teamRegistry)}_wireEventHandlers(){this._connectedHandler=()=>{this.services.adminController&&this.services.adminController.initialize(),this.services.queueManager&&this.services.queueManager.syncQueue()},this._disconnectedHandler=()=>{this.services.adminController&&this.services.adminController.pause()},this._authRequiredHandler=()=>{this.dispatchEvent(new CustomEvent("auth:required"))},this._messageHandler=e=>{const{type:t,payload:s}=e.detail;switch(t){case"score:updated":this.dataManager.updateTeamScoreFromBackend(s);break;case"sync:full":this._handleSessionBoundary(s.session?.id),s.deviceScannedTokens&&this.dataManager.setScannedTokensFromServer(s.deviceScannedTokens),s.scores&&s.scores.forEach(n=>this.dataManager.updateTeamScoreFromBackend(n)),s.recentTransactions&&s.recentTransactions.forEach(n=>this.dataManager.addTransaction(n)),s.playerScans&&this.dataManager.setPlayerScansFromServer(s.playerScans);break;case"session:update":s.status==="ended"?this.dataManager.resetForNewSession(null):this._handleSessionBoundary(s.id);break;case"transaction:new":s.transaction&&this.dataManager.addTransactionFromBroadcast(s.transaction);break;case"transaction:deleted":s.transactionId&&this.dataManager.removeTransaction(s.transactionId);break;case"scores:reset":this.dataManager.clearBackendScores();break;case"player:scan":this.dataManager.handlePlayerScan(s);break}},this.services.connectionManager.addEventListener("connected",this._connectedHandler),this.services.connectionManager.addEventListener("disconnected",this._disconnectedHandler),this.services.connectionManager.addEventListener("auth:required",this._authRequiredHandler),this.services.client.addEventListener("message:received",this._messageHandler)}_handleSessionBoundary(e){const t=this.dataManager.currentSessionId;e&&e!==t&&this.dataManager.resetForNewSession(e)}async _initiateConnection(){await this.services.connectionManager.connect()}}class j{constructor(e={}){this.debug=e.debug||d,this.uiManager=e.uiManager||V,this.settings=e.settings||N,this.tokenManager=e.tokenManager||G,this.dataManager=e.dataManager,this.teamRegistry=e.teamRegistry||null,this.nfcHandler=e.nfcHandler||U,this.config=e.config||B,this.initializationSteps=e.initializationSteps||q,this.sessionModeManager=e.sessionModeManager||null,this.networkedSession=e.networkedSession||null,this.showConnectionWizard=e.showConnectionWizard||(typeof window<"u"?window.showConnectionWizard:null),this.currentTeamId="",this.nfcSupported=!1,this.currentInterventionTeamId=null,this.viewController=this._createViewController()}async init(){this.debug.log("App initializing..."),this.initializationSteps.initializeUIManager(this.uiManager),await this.initializationSteps.showLoadingScreen(this.uiManager),this.sessionModeManager=this.initializationSteps.createSessionModeManager(ke),this.uiManager.sessionModeManager=this.sessionModeManager,this.uiManager.app=this,this.initializationSteps.initializeViewController(this.viewController),this.initializationSteps.loadSettings(this.settings),this.initializationSteps.loadDataManager(this.dataManager,this.uiManager),this.nfcSupported=await this.initializationSteps.detectNFCSupport(this.nfcHandler),await this.initializationSteps.loadTokenDatabase(this.tokenManager,this.uiManager),this.initializationSteps.applyURLModeOverride(window.location.search,this.settings),await this.initializationSteps.registerServiceWorker(navigator,this.uiManager);const e=await this.initializationSteps.validateAndDetermineInitialScreen(this.sessionModeManager);e.validationResult&&(e.validationResult.valid?this.debug.log("[App] State validation passed - proceeding with auto-connect"):this.debug.log(`[App] State validation failed: ${e.validationResult.reason}`)),await this.initializationSteps.applyInitialScreenDecision(e,this.sessionModeManager,this.uiManager,this.showConnectionWizard,this._initializeNetworkedMode.bind(this))}_wireNetworkedSessionEvents(){if(!this.networkedSession){this.debug.log("Cannot wire networked session events: session is null");return}this.networkedSession.addEventListener("session:ready",e=>{this.debug.log("NetworkedSession ready - initializing admin modules"),e.detail&&e.detail.services&&this.debug.log("Received services via session:ready event.detail"),this.viewController&&this.viewController.initAdminModules()}),this.networkedSession.addEventListener("auth:required",()=>{this.debug.log("Authentication required - showing connection wizard"),this.showConnectionWizard&&this.showConnectionWizard()})}_createViewController(){const e=this;return{currentView:"scanner",views:["scanner","admin","debug"],adminInstances:null,init(){const t=document.getElementById("viewSelector");t&&(t.style.display="flex")},switchView(t){if(!this.views.includes(t)){console.error("Invalid view:",t),e.uiManager.showError(`Invalid view: ${t}`);return}document.querySelectorAll(".view-content").forEach(a=>{a.style.display="none"});const s=document.getElementById(`${t}-view`);s&&(s.style.display="block"),document.querySelectorAll(".view-tab").forEach(a=>{a.classList.remove("active")});const n=document.querySelector(`[data-view="${t}"]`);n&&n.classList.add("active"),this.currentView=t,t==="admin"&&(this.adminInstances||this.initAdminModules(),this.adminInstances&&this.fetchCurrentSession(),e.updateAdminPanel())},async fetchCurrentSession(){this.adminInstances?.sessionManager&&e.debug.log(this.adminInstances.sessionManager.currentSession?"Session active: "+JSON.stringify(this.adminInstances.sessionManager.currentSession):"No active session")},initAdminModules(){if(!e.sessionModeManager?.isNetworked()){console.log("Admin modules only available in networked mode");return}if(!e.networkedSession){console.error("NetworkedSession not initialized"),e.uiManager.showError("Network session not available. Check connection.");return}const t=e.networkedSession.getService("adminController");t.initialized||(console.log("Initializing admin modules..."),t.initialize()),this.adminInstances={sessionManager:t.getModule("sessionManager"),videoController:t.getModule("videoController"),displayController:t.getModule("displayController"),systemMonitor:t.getModule("systemMonitor"),adminOps:t.getModule("adminOperations"),monitoring:t.getModule("monitoringDisplay")},console.log("Admin modules referenced from AdminController")}}}showSettings(){this.uiManager.showScreen("settings")}saveSettings(){this.settings.save(),this.uiManager.showScreen("teamEntry")}toggleMode(){this.settings.mode=this.settings.mode==="detective"?"blackmarket":"detective",this.uiManager.updateModeDisplay(this.settings.mode);const e=document.getElementById("scanScreen");e&&e.classList.contains("active")&&this.uiManager.updateSessionStats();const t=document.getElementById("modeIndicator");t&&(t.style.transform=`scale(${this.config.MODE_TOGGLE_SCALE})`,setTimeout(()=>{t.style.transform="scale(1)"},this.config.ANIMATION_DURATION))}updateModeFromToggle(){const e=document.getElementById("modeToggle");e&&(this.settings.mode=e.checked?"blackmarket":"detective",this.uiManager.updateModeDisplay(this.settings.mode))}initTeamEntryUI(){const e=document.getElementById("teamNameInput"),t=document.getElementById("teamList"),s=document.getElementById("teamListLabel");s&&this.teamRegistry&&(s.textContent=this.teamRegistry.getTeamListLabel()),this.teamRegistry&&t&&this._renderTeamList(t),e&&(e.value="",e.focus()),this.teamRegistry&&!this._teamsListenerAdded&&(this._teamsListenerAdded=!0,this.teamRegistry.addEventListener("teams:updated",()=>{const n=document.getElementById("teamList");n&&this._renderTeamList(n)}))}_renderTeamList(e){e.innerHTML="",this.teamRegistry.getTeamsForDisplay().forEach(s=>{const n=document.createElement("div");n.className="team-list-item",n.textContent=s,n.setAttribute("role","option"),n.addEventListener("click",()=>{document.getElementById("teamNameInput").value=s,this.confirmTeamId()}),e.appendChild(n)})}async confirmTeamId(){const t=document.getElementById("teamNameInput")?.value?.trim();if(!t){this.uiManager.showError("Please enter a team name");return}const s=await this.teamRegistry.selectTeam(t);if(!s.success){this.uiManager.showError(s.error||"Failed to select team");return}this.currentTeamId=t;const n=document.getElementById("currentTeam");n&&(n.textContent=t),this.uiManager.updateSessionStats(),this.uiManager.showScreen("scan"),await this._startNFCScanning()}async selectGameMode(e){if(!this.sessionModeManager){console.error("SessionModeManager not initialized"),this.uiManager.showError("System error: SessionModeManager not initialized. Please reload the page.");return}try{if(e==="networked"){const t=localStorage.getItem("aln_auth_token");if(!t||!this._isTokenValid(t)){this.debug.log("Networked mode selected - showing connection wizard (mode not locked yet)"),this.showConnectionWizard?this.showConnectionWizard():this.uiManager.showError("Connection wizard not available");return}this.sessionModeManager.setMode(e),this.debug.log(`Game mode locked: ${e}`),await this._initializeNetworkedMode()}else if(e==="standalone"){this.sessionModeManager.setMode(e),this.debug.log(`Game mode locked: ${e}`),document.body.classList.add("standalone-mode"),document.body.classList.remove("networked-mode"),localStorage.removeItem("standaloneSession"),this.dataManager.sessionModeManager=this.sessionModeManager,await this.dataManager.initializeStandaloneMode(),this.debug.log("UnifiedDataManager initialized for standalone mode"),this.viewController.init();const t=document.getElementById("session-status-container");t&&this.uiManager.renderSessionStatus(t),this.teamRegistry&&(this.teamRegistry.sessionModeManager=this.sessionModeManager),this.initTeamEntryUI(),this.uiManager.showScreen("teamEntry")}}catch(t){throw console.error("Failed to set game mode:",t),this.uiManager.showError(`Failed to set game mode: ${t.message}`),t}}async _initializeNetworkedMode(){document.body.classList.add("networked-mode"),document.body.classList.remove("standalone-mode");const e=localStorage.getItem("aln_orchestrator_url")||"https://localhost:3000",t=this.settings?.deviceId||"GM_STATION_UNKNOWN",s=localStorage.getItem("aln_auth_token");if(s&&this._isTokenValid(s)){this.debug.log("Valid token found - creating NetworkedSession..."),this.uiManager.showToast("Reconnecting to orchestrator...","info",3e3),this.networkedSession=new Ae({url:e,deviceId:t,stationName:this.settings?.stationName||"GM Station",token:s},this.dataManager,this.teamRegistry);try{this._wireNetworkedSessionEvents(),this.dataManager.sessionModeManager=this.sessionModeManager,await this.dataManager.initializeNetworkedMode(null),this.debug.log("UnifiedDataManager initialized for networked mode (socket pending)"),await this.networkedSession.initialize(),this.debug.log("NetworkedSession initialized - session:ready will fire");const n=this.networkedSession.getService("client");n?.socket&&this.dataManager._networkedStrategy&&(this.dataManager._networkedStrategy.socket=n.socket,this.debug.log("NetworkedStorage socket reference updated")),this.teamRegistry&&(this.teamRegistry.sessionModeManager=this.sessionModeManager,n&&(this.teamRegistry.orchestratorClient=n));const a=document.getElementById("connectionModal");a&&a.style.display!=="none"&&(a.style.display="none",this.debug.log("Connection wizard closed after successful initialization"));const o=document.getElementById("viewSelector");o&&(o.style.display="flex"),this.uiManager.showScreen("teamEntry"),this.debug.log("UI transitioned to team entry screen")}catch(n){throw console.error("NetworkedSession initialization failed:",n),this.networkedSession&&(await this.networkedSession.destroy(),this.networkedSession=null),n}}else this.debug.log("No valid token - showing connection wizard"),this.showConnectionWizard?this.showConnectionWizard():this.uiManager.showError("Connection wizard not available")}_isTokenValid(e){if(!e)return!1;try{const t=e.split(".");if(t.length!==3)return!1;const n=JSON.parse(atob(t[1])).exp;if(!n)return!1;const a=Math.floor(Date.now()/1e3);return n>a+1*60}catch(t){return console.error("Token validation error:",t),!1}}switchView(e){this.viewController.switchView(e)}async startScan(){console.warn("startScan() is deprecated - NFC now auto-starts on team confirmation"),await this._startNFCScanning()}async _startNFCScanning(){if(!this.nfcSupported){this.debug.log("NFC not supported - scan simulation available via Manual Entry");return}const e=document.getElementById("scanStatus");try{e&&(e.textContent="Scanning... Tap a token"),await this.nfcHandler.startScan(t=>this.processNFCRead(t),t=>{this.debug.log(`NFC read error: ${t?.message||t}`,!0),e&&(e.textContent="Read error. Tap token again.")}),this.debug.log("NFC scanning started automatically")}catch(t){this.debug.log(`NFC start error: ${t.message}`,!0),e&&(e.textContent="NFC unavailable. Use Manual Entry.")}}simulateScan(){const e=document.getElementById("scanStatus");e&&(e.textContent="Demo Mode: Simulating scan..."),setTimeout(()=>{const t=this.nfcHandler.simulateScan();this.processNFCRead(t)},this.config.SCAN_SIMULATION_DELAY)}async processNFCRead(e){if(e.source==="error"){this.debug.log(`NFC read failed: ${e.error}`,!0),this.uiManager.showError("Could not read token - please re-tap");return}if(this.debug.log(`Processing token: "${e.id}" (from ${e.source})`),this.debug.log(`Token ID length: ${e.id.length} characters`),!this.currentTeamId||this.currentTeamId.trim()===""){this.debug.log("ERROR: No team selected - cannot process token",!0),this.uiManager.showError("Please select a team before scanning tokens");return}const t=e.id.trim();this.debug.log(`Cleaned ID: "${t}" (length: ${t.length})`);const s=this.tokenManager.findToken(t),n=s?s.matchedId:t;if(this.dataManager.isTokenScanned(n)){this.debug.log(`Duplicate token detected: ${n}`,!0),this.showDuplicateError(n);return}s?await this.recordTransaction(s.token,s.matchedId,!1):await this.recordTransaction(null,t,!0)}showDuplicateError(e){const t=document.getElementById("resultStatus");t&&(t.className="status-message error",t.innerHTML=`
        <h2>Token Already Scanned</h2>
        <p style="font-size: 14px;">This token has been used</p>
        <p style="font-size: 12px; color: #666;">ID: ${e}</p>
      `);const s=document.getElementById("resultRfid");s&&(s.textContent=e);const n=document.getElementById("resultType");n&&(n.textContent="DUPLICATE",n.style.color="#FF5722");const a=document.getElementById("resultGroup");a&&(a.textContent="Previously scanned");const o=document.getElementById("resultValue");o&&(o.textContent="No points awarded"),this.uiManager.showScreen("result")}async recordTransaction(e,t,s){const n={timestamp:new Date().toISOString(),deviceId:this.settings.deviceId,mode:this.settings.mode,teamId:this.currentTeamId,rfid:t,tokenId:t,memoryType:s?"UNKNOWN":e?.SF_MemoryType||"UNKNOWN",group:s?`Unknown: ${t}`:e?.SF_Group||"",tokenGroup:s?"":e?.SF_Group||"",valueRating:s?0:e?.SF_ValueRating||0,isUnknown:s};if(this.settings.mode==="blackmarket"&&!s?(n.points=this.dataManager.calculateTokenValue(n),console.log("[app.js] Transaction points calculated:",{tokenId:n.tokenId,valueRating:n.valueRating,memoryType:n.memoryType,calculatedPoints:n.points,tokenGroup:n.tokenGroup})):(n.points=0,console.log("[app.js] Transaction points set to 0 (detective mode or unknown token)")),this.sessionModeManager&&this.sessionModeManager.isNetworked()){if(this.dataManager.markTokenAsScanned(t),!this.networkedSession)throw new Error("Cannot scan: NetworkedSession not initialized. Please reconnect.");const o=this.networkedSession.getService("queueManager").queueTransaction({tokenId:t,teamId:this.currentTeamId,deviceId:this.settings.deviceId,deviceType:"gm",mode:this.settings.mode,summary:e?.summary||null,timestamp:n.timestamp});this.debug.log(`Transaction queued for orchestrator: ${o}`)}else if(this.sessionModeManager&&this.sessionModeManager.isStandalone())await this.dataManager.addTransaction(n),this.dataManager.markTokenAsScanned(t),this.debug.log("Transaction stored via UnifiedDataManager (standalone mode)");else{this.debug.log("Warning: No session mode selected - cannot process transaction",!0),this.uiManager.showError("Please select a game mode first");return}if(this.settings.mode==="blackmarket"&&!s){const a=this.dataManager.calculateTokenValue(n);this.debug.log(`Token scored: $${a.toLocaleString()}`)}this.uiManager.updateSessionStats(),this.uiManager.showTokenResult(e,t,s)}manualEntry(){const e=prompt("Enter RFID manually:");e&&e.trim()&&this.processNFCRead({id:e.trim(),source:"manual",raw:e.trim()})}cancelScan(){this.nfcHandler.stopScan(),this.currentTeamId="",this.uiManager.updateTeamDisplay(""),this.uiManager.showScreen("teamEntry")}continueScan(){this.uiManager.updateSessionStats(),this.uiManager.showScreen("scan")}finishTeam(){this.currentTeamId="",this.uiManager.updateTeamDisplay(""),this.uiManager.showScreen("teamEntry")}showHistory(){this.uiManager.updateHistoryStats();const e=document.getElementById("historyContainer");e&&this.uiManager.renderGameActivity(e,{showSummary:!0,showFilters:!0}),this.uiManager.showScreen("history")}closeHistory(){const e=this.uiManager.previousScreen||"teamEntry";this.uiManager.showScreen(e)}showScoreboard(){if(this.settings.mode!=="blackmarket"){this.debug.log("Scoreboard only available in Black Market mode");return}this.uiManager.renderScoreboard(),this.uiManager.showScreen("scoreboard")}closeScoreboard(){const e=this.uiManager.previousScreen||"teamEntry";this.uiManager.showScreen(e)}showTeamDetails(e){this.viewController&&this.viewController.currentView==="admin"&&this.viewController.switchView("scanner"),this.currentInterventionTeamId=e;const t=this.dataManager.getTeamTransactions(e);this.uiManager.renderTeamDetails(e,t),this.uiManager.showScreen("teamDetails")}closeTeamDetails(){this.uiManager.showScreen("scoreboard")}async adminCreateSession(){const e=prompt("Enter session name:");if(!e)return;if(this.sessionModeManager?.isStandalone()){try{await this.dataManager.createSession(e.trim(),[]),this.debug.log(`Session created (standalone): ${e}`),this.uiManager.showToast("Session created","success"),this._refreshAdminSessionDisplay()}catch(s){console.error("Failed to create session (standalone):",s),this.uiManager.showError(`Failed to create session: ${s.message}`)}return}if(!this.viewController.adminInstances?.sessionManager){alert("Admin functions not available. Please ensure you are connected.");return}try{await this.viewController.adminInstances.sessionManager.createSession(e),this.debug.log(`Session created: ${e}`)}catch(s){console.error("Failed to create session:",s),this.uiManager.showError("Failed to create session. Check connection.")}}async adminPauseSession(){if(this.sessionModeManager?.isStandalone()){try{const t=await this.dataManager.pauseSession();t.success?(this.debug.log("Session paused (standalone)"),this.uiManager.showToast("Session paused","info"),this._refreshAdminSessionDisplay()):this.uiManager.showError(t.error||"Failed to pause session")}catch(t){console.error("Failed to pause session (standalone):",t),this.uiManager.showError(`Failed to pause session: ${t.message}`)}return}if(!this.viewController.adminInstances?.sessionManager){alert("Admin functions not available.");return}try{await this.viewController.adminInstances.sessionManager.pauseSession(),this.debug.log("Session paused")}catch(t){console.error("Failed to pause session:",t),this.uiManager.showError("Failed to pause session.")}}async adminResumeSession(){if(this.sessionModeManager?.isStandalone()){try{const t=await this.dataManager.resumeSession();t.success?(this.debug.log("Session resumed (standalone)"),this.uiManager.showToast("Session resumed","success"),this._refreshAdminSessionDisplay()):this.uiManager.showError(t.error||"Failed to resume session")}catch(t){console.error("Failed to resume session (standalone):",t),this.uiManager.showError(`Failed to resume session: ${t.message}`)}return}if(!this.viewController.adminInstances?.sessionManager){alert("Admin functions not available.");return}try{await this.viewController.adminInstances.sessionManager.resumeSession(),this.debug.log("Session resumed")}catch(t){console.error("Failed to resume session:",t),this.uiManager.showError("Failed to resume session.")}}async adminEndSession(){if(!confirm("Are you sure you want to end the session?"))return;if(this.sessionModeManager?.isStandalone()){try{await this.dataManager.endSession(),this.debug.log("Session ended (standalone)"),this.uiManager.showToast("Session ended","info"),this._refreshAdminSessionDisplay()}catch(t){console.error("Failed to end session (standalone):",t),this.uiManager.showError(`Failed to end session: ${t.message}`)}return}if(!this.viewController.adminInstances?.sessionManager){alert("Admin functions not available.");return}try{await this.viewController.adminInstances.sessionManager.endSession(),this.debug.log("Session ended")}catch(t){console.error("Failed to end session:",t),this.uiManager.showError("Failed to end session.")}}async adminResetAndCreateNew(){if(!confirm(`Reset system and start new session?

This will:
‚Ä¢ Archive the current completed session
‚Ä¢ Clear all current data
‚Ä¢ Prepare system for a new game

Continue?`))return;const t=prompt("Enter new session name:");if(!t||t.trim()===""){alert("Session name is required");return}if(!this.viewController.adminInstances?.sessionManager){alert("Admin functions not available. Please ensure you are connected to the orchestrator.");return}try{this.debug.log("Sending system:reset command..."),await new Promise((s,n)=>{const a=setTimeout(()=>{n(new Error("System reset timeout (5s)"))},5e3),o=this.viewController.adminInstances.sessionManager.connection.socket;o.once("gm:command:ack",i=>{if(clearTimeout(a),i.data&&i.data.success)this.debug.log("System reset successful"),s();else{const r=i.data?.message||"Reset failed";n(new Error(r))}}),o.emit("gm:command",{event:"gm:command",data:{action:"system:reset",payload:{}},timestamp:new Date().toISOString()})}),this.debug.log("System reset complete, creating new session..."),await this.viewController.adminInstances.sessionManager.createSession(t.trim()),this.debug.log(`New session created: ${t}`),this.uiManager.showToast?this.uiManager.showToast(`Session "${t}" started successfully`,"success",5e3):alert(`Session "${t}" created successfully!`)}catch(s){console.error("Failed to reset and create session:",s);const n=`Failed to reset and create session: ${s.message}`;this.uiManager.showError?this.uiManager.showError(n):alert(n)}}async adminViewSessionDetails(){const e=this.viewController.adminInstances?.sessionManager?.currentSession;if(!e){alert("No session data available");return}const t=e.startTime?new Date(e.startTime).toLocaleString():"Unknown",s=e.endTime?new Date(e.endTime).toLocaleString():"Ongoing",n=e.getDuration?this.formatSessionDuration(e.getDuration()):"Unknown",a=`
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
SESSION DETAILS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Name: ${e.name||"Unnamed Session"}
ID: ${e.id}
Status: ${e.status.toUpperCase()}

TIMING
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Started: ${t}
${e.endTime?"Ended: "+s:"Status: In Progress"}
Duration: ${n}

STATISTICS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Total Scans: ${e.metadata?.totalScans||0}
Unique Tokens: ${e.metadata?.uniqueTokensScanned?.length||0}
Teams: ${e.scores?.length||0}
GM Stations: ${e.connectedDevices?.filter(o=>o.type==="gm").length||0}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    `.trim();alert(a)}formatSessionDuration(e){if(e==null||e<0)return"Unknown";const t=Math.floor(e/1e3),s=Math.floor(t/60),n=Math.floor(s/60),a=Math.floor(n/24),o=[];return a>0&&o.push(`${a}d`),n%24>0&&o.push(`${n%24}h`),s%60>0&&o.length<2&&o.push(`${s%60}m`),t%60>0&&o.length<2&&o.push(`${t%60}s`),o.length>0?o.join(" "):"0s"}async adminPlayVideo(){if(!this.viewController.adminInstances?.videoController){alert("Video controls not available.");return}try{await this.viewController.adminInstances.videoController.playVideo()}catch(e){console.error("Failed to play video:",e),this.uiManager.showError("Failed to play video.")}}async adminPauseVideo(){if(!this.viewController.adminInstances?.videoController){alert("Video controls not available.");return}try{await this.viewController.adminInstances.videoController.pauseVideo()}catch(e){console.error("Failed to pause video:",e),this.uiManager.showError("Failed to pause video.")}}async adminStopVideo(){if(!this.viewController.adminInstances?.videoController){alert("Video controls not available.");return}try{await this.viewController.adminInstances.videoController.stopVideo()}catch(e){console.error("Failed to stop video:",e),this.uiManager.showError("Failed to stop video.")}}async adminSkipVideo(){if(!this.viewController.adminInstances?.videoController){alert("Video controls not available.");return}try{await this.viewController.adminInstances.videoController.skipVideo()}catch(e){console.error("Failed to skip video:",e),this.uiManager.showError("Failed to skip video.")}}async adminAddVideoToQueue(){if(!this.viewController.adminInstances?.videoController){alert("Video controls not available.");return}const e=document.getElementById("manual-video-input"),t=e?.value;if(!t){alert("Enter a video filename (e.g., jaw001.mp4)");return}try{await this.viewController.adminInstances.videoController.addToQueue(t),this.uiManager.showToast(`Added ${t} to queue`,"success"),e&&(e.value="")}catch(s){console.error("Failed to add video to queue:",s),this.uiManager.showError(`Failed to add video: ${s.message}`)}}async adminClearQueue(){if(!this.viewController.adminInstances?.videoController){alert("Video controls not available.");return}if(confirm("Clear entire video queue?"))try{await this.viewController.adminInstances.videoController.clearQueue(),this.uiManager.showToast("Queue cleared","success")}catch(e){console.error("Failed to clear queue:",e),this.uiManager.showError(`Failed to clear queue: ${e.message}`)}}updateAdminPanel(){this.viewController?.adminInstances?.monitoring&&this.viewController.adminInstances.monitoring.refreshAllDisplays();const e=document.getElementById("admin-game-activity");if(e&&this.uiManager.renderGameActivity(e,{showSummary:!0,showFilters:!0}),!this.viewController?.adminInstances?.monitoring){const t=document.getElementById("admin-score-board");if(t){const s={};this.dataManager.getTransactions().forEach(a=>{if(s[a.teamId]||(s[a.teamId]={score:0,count:0}),s[a.teamId].count++,a.mode==="blackmarket"){const o=this.dataManager.calculateTokenValue(a);s[a.teamId].score+=o}});let n='<table class="score-table"><tr><th>Team</th><th>Tokens</th><th>Score</th></tr>';Object.keys(s).forEach(a=>{n+=`<tr>
            <td style="cursor: pointer; color: #007bff; text-decoration: underline;"
                data-action="app.showTeamDetails" data-arg="${a}">
              ${a}
            </td>
            <td>${s[a].count}</td>
            <td>${s[a].score.toLocaleString()}</td>
          </tr>`}),n+="</table>",t.innerHTML=n}}}async adminResetScores(){if(!confirm("Reset all team scores to zero? Transactions will be preserved."))return;if(this.sessionModeManager?.isStandalone()){try{const t=await this.dataManager.resetScores();t.success?(this.debug.log("Scores reset (standalone)"),this.uiManager.showToast("All scores reset to zero","success")):this.uiManager.showError(t.error||"Failed to reset scores")}catch(t){console.error("Failed to reset scores (standalone):",t),this.uiManager.showError(`Failed to reset scores: ${t.message}`)}return}if(!this.viewController.adminInstances?.adminOps){alert("Admin functions not available.");return}try{await this.viewController.adminInstances.adminOps.resetScores(),this.debug.log("Scores reset"),this.uiManager.showToast("All scores reset","success")}catch(t){console.error("Failed to reset scores:",t),this.uiManager.showError("Failed to reset scores.")}}viewFullScoreboard(){this.switchView("scanner"),this.showScoreboard()}viewFullHistory(){this.switchView("scanner"),this.showHistory()}_refreshAdminSessionDisplay(){const e=document.getElementById("session-status-container");e&&this.uiManager&&this.uiManager.renderSessionStatus(e)}async adjustTeamScore(){const e=this.currentInterventionTeamId;if(!e){alert("No team selected. Please open team details first.");return}const t=document.getElementById("scoreAdjustmentInput"),s=document.getElementById("scoreAdjustmentReason"),n=parseInt(t?.value||"0");if(isNaN(n)||n===0){alert("Please enter a valid positive or negative number.");return}const a=s?.value.trim()||"Manual GM adjustment";if(this.sessionModeManager?.isStandalone()){try{await this.dataManager.adjustTeamScore(e,n,a),this.debug.log(`Score adjusted (standalone): Team ${e} ${n>0?"+":""}${n} (${a})`),t&&(t.value=""),s&&(s.value="");const i=this.dataManager.getTeamTransactions(e);this.uiManager.renderTeamDetails(e,i),this.uiManager.showToast(`Score adjusted: ${n>0?"+":""}${n} points`,"success")}catch(i){console.error("Failed to adjust score (standalone):",i),this.uiManager.showError(`Failed to adjust score: ${i.message}`)}return}if(!this.viewController?.adminInstances?.adminOps){alert("Admin functions not available. Ensure you are in networked mode.");return}try{await this.viewController.adminInstances.adminOps.adjustScore(e,n,a),this.debug.log(`Score adjusted (networked): Team ${e} ${n>0?"+":""}${n} (${a})`),t&&(t.value=""),s&&(s.value=""),this.uiManager.showToast(`Score adjusted: ${n>0?"+":""}${n} points`,"success")}catch(i){console.error("Failed to adjust score (networked):",i),this.uiManager.showError(`Failed to adjust score: ${i.message}`)}}async deleteTeamTransaction(e){if(!confirm("Delete this transaction? This cannot be undone."))return;if(this.sessionModeManager?.isStandalone()){try{if((await this.dataManager.removeTransaction(e)).success){this.debug.log(`Transaction deleted (standalone): ${e}`);const n=this.currentInterventionTeamId;if(n){const a=this.dataManager.getTeamTransactions(n);this.uiManager.renderTeamDetails(n,a)}this.uiManager.showToast("Transaction deleted","success")}else this.uiManager.showError("Transaction not found")}catch(s){console.error("Failed to delete transaction (standalone):",s),this.uiManager.showError(`Failed to delete transaction: ${s.message}`)}return}if(!this.viewController?.adminInstances?.adminOps){alert("Admin functions not available. Ensure you are in networked mode.");return}try{await this.viewController.adminInstances.adminOps.deleteTransaction(e),this.debug.log(`Transaction deleted (networked): ${e}`),this.uiManager.showToast("Transaction deleted","success")}catch(s){console.error("Failed to delete transaction (networked):",s),this.uiManager.showError(`Failed to delete transaction: ${s.message}`)}}async adminSetIdleLoop(){if(!this.sessionModeManager?.isNetworked()){this.debug.log("Display control only available in networked mode");return}const e=this.viewController?.adminInstances?.displayController;if(!e){this.debug.log("DisplayController not available - admin modules not initialized"),this.uiManager.showError("Admin functions not available. Please ensure connection is established.");return}try{const t=await e.setIdleLoop();this.debug.log(`Display mode set to Idle Loop: ${JSON.stringify(t)}`)}catch(t){console.error("Failed to set display mode:",t),this.uiManager.showError(`Failed to set display mode: ${t.message}`)}}async adminSetScoreboard(){if(!this.sessionModeManager?.isNetworked()){this.debug.log("Display control only available in networked mode");return}const e=this.viewController?.adminInstances?.displayController;if(!e){this.debug.log("DisplayController not available - admin modules not initialized"),this.uiManager.showError("Admin functions not available. Please ensure connection is established.");return}try{const t=await e.setScoreboard();this.debug.log(`Display mode set to Scoreboard: ${JSON.stringify(t)}`)}catch(t){console.error("Failed to set display mode:",t),this.uiManager.showError(`Failed to set display mode: ${t.message}`)}}testTokenMatch(){const e=prompt("Enter a token ID to test:");if(e){const t=this.tokenManager.findToken(e);alert(t?`Match found!
ID: ${t.matchedId}
Type: ${t.token.SF_MemoryType}
Group: ${t.token.SF_Group}`:`No match found for: ${e}`)}}testGroupParsing(){const e=["Server Logs (x5)","Marcus' Memories (x1)","Government Files (x3)","No Multiplier Group","Bad Format (x)","Zero Multiplier (x0)","Large Multiplier (x999)"];console.log("=== Testing Group Parsing ==="),e.forEach(t=>{const s=this.dataManager.parseGroupInfo(t),n=this.dataManager.normalizeGroupName(s.name);console.log(`Input: "${t}"`),console.log(`  Parsed: name="${s.name}", multiplier=${s.multiplier}`),console.log(`  Normalized: "${n}"`)}),alert("Check console for test results")}testGroupInventory(){const e=this.tokenManager.getGroupInventory();console.log("=== Group Inventory Test ==="),console.log("Total groups:",Object.keys(e).length),Object.entries(e).forEach(([t,s])=>{console.log(`
Group: "${s.displayName}"`),console.log(`  Normalized: "${t}"`),console.log(`  Multiplier: ${s.multiplier}x`),console.log(`  Tokens: ${s.tokens.size}`)}),alert("Check console for group inventory details")}testCompletionDetection(){console.log(`=== Testing Group Completion Detection ===
`);const e=[...new Set(this.dataManager.getTransactions().filter(t=>t.mode==="blackmarket").map(t=>t.teamId))];e.length>0?(console.log("=== Testing with REAL data ==="),e.forEach(t=>{const s=this.dataManager.getTeamCompletedGroups(t);console.log(`Team ${t}: ${s.length} completed groups`),s.forEach(n=>{console.log(`  ‚úÖ "${n.name}" - ${n.tokenCount} tokens, ${n.multiplier}x`)})})):console.log("No real data found. Add some transactions first."),alert("Check console for completion detection results")}testBonusCalculations(){console.log(`=== Testing Bonus Score Calculations ===
`);const e=this.dataManager.getTeamScores();e.length>0?e.forEach((t,s)=>{console.log(`${s+1}. Team ${t.teamId}`),console.log(`   Base: $${t.baseScore.toLocaleString()}`),console.log(`   Bonus: $${t.bonusScore.toLocaleString()}`),console.log(`   Total: $${t.score.toLocaleString()}`),console.log(`   Completed Groups: ${t.completedGroups}`)}):console.log("No teams found. Add some transactions first."),alert("Check console for bonus calculation results")}testEnhancedUI(){console.log(`=== Testing Enhanced UI Data Structure ===
`);const e=prompt("Enter a team ID to test (or leave blank for first team):"),t=this.dataManager.getTransactions(),s=e||t[0]?.teamId;if(!s){alert("No teams found. Add some transactions first.");return}const n=this.dataManager.getEnhancedTeamTransactions(s);console.log(`Team ${s} Enhanced Data:`),console.log(`  Completed Groups: ${n.completedGroups.length}`),console.log(`  In-Progress Groups: ${n.incompleteGroups.length}`),console.log(`  Ungrouped Tokens: ${n.ungroupedTokens.length}`),console.log(`  Unknown Tokens: ${n.unknownTokens.length}`),n.hasCompletedGroups&&(console.log(`
Completed Groups:`),n.completedGroups.forEach(a=>{console.log(`  "${a.displayName}": ${a.tokens.length} tokens, +$${a.bonusValue.toLocaleString()} bonus`)})),n.hasIncompleteGroups&&(console.log(`
In-Progress Groups:`),n.incompleteGroups.forEach(a=>{console.log(`  "${a.displayName}": ${a.progress} (${a.percentage}%)`)})),alert("Check console for enhanced UI data structure")}}new j;class Le{constructor(e){this.app=e,this.scanForServers=this.scanForServers.bind(this),this.handleConnectionSubmit=this.handleConnectionSubmit.bind(this),this.cancelNetworkedMode=this.cancelNetworkedMode.bind(this),this.showConnectionWizard=this.showConnectionWizard.bind(this),this.showAuthModal=this.showAuthModal.bind(this)}init(){const e=document.getElementById("connectionForm");e&&e.addEventListener("submit",this.handleConnectionSubmit),this._setupServerUrlHandler()}async scanForServers(){const e=document.getElementById("discoveryStatus"),t=document.getElementById("discoveredServers"),s=document.getElementById("scanServersBtn");s.disabled=!0,s.textContent="üîç Scanning...",e.textContent="Looking for orchestrators on the network...",e.style.color="#2196F3",t.innerHTML="";try{const n=window.location.hostname;let a="192.168.1";if(n&&n!=="localhost"&&n!=="127.0.0.1"){const h=n.split(".");h.length>=3&&(a=h.slice(0,3).join("."))}const o=[3e3,8080],i=window.location.protocol.replace(":",""),r=[];for(let h=1;h<=254;h++){for(const m of o){const g=`${i}://${a}.${h}:${m}`;r.push(fetch(`${g}/health`,{method:"GET",mode:"cors",signal:AbortSignal.timeout(500)}).then(p=>p.ok?g:null).catch(()=>null))}r.length>=20&&await Promise.race(r)}r.push(fetch(`${i}://localhost:3000/health`,{signal:AbortSignal.timeout(1e3)}).then(h=>h.ok?`${i}://localhost:3000`:null).catch(()=>null)),window.location.pathname.startsWith("/gm-scanner/")&&r.push(Promise.resolve(window.location.origin));const u=await Promise.all(r),l=[...new Set(u.filter(h=>h!==null))];l.length>0?(e.textContent=`‚úÖ Found ${l.length} orchestrator(s)`,e.style.color="#4CAF50",this.displayDiscoveredServers(l.map(h=>({url:h})))):(e.textContent="‚ö†Ô∏è No orchestrators found. Please enter URL manually below.",e.style.color="#ff9800")}catch(n){e.textContent="‚ùå Discovery failed. Please enter URL manually below.",e.style.color="#f44336",console.error("Server discovery error:",n)}finally{s.disabled=!1,s.textContent="üîç Scan for Game Servers"}}displayDiscoveredServers(e){const t=document.getElementById("discoveryStatus"),s=document.getElementById("discoveredServers");t.textContent=`‚úÖ Found ${e.length} game server(s)`,s.innerHTML="",e.forEach(n=>{const a=document.createElement("div");a.className="server-item",a.innerHTML=`
        <span>üéÆ Game Server at ${n.ip||n.url}</span>
        <button data-action="connectionWizard.selectServer" data-arg="${n.url}">Select</button>
      `,s.appendChild(a)})}_setupServerUrlHandler(){const e=document.getElementById("serverUrl");if(!e)return;let t;const s=500;e.addEventListener("input",()=>{clearTimeout(t),t=setTimeout(()=>{const n=e.value.trim();if(n){let a=n;a.match(/^https?:\/\//i)||(a=`http://${a}`),this.assignStationName(a)}},s)})}async assignStationName(e){const t=document.getElementById("stationNameDisplay");if(t)try{const s=await fetch(`${e}/api/state`,{method:"GET",mode:"cors",signal:AbortSignal.timeout(3e3)});if(!s.ok)throw new Error("Server unreachable");const o=((await s.json()).devices||[]).filter(r=>r.type==="gm").map(r=>r.deviceId),i=this._findNextStationId(o);t.textContent=i,t.dataset.deviceId=i,console.log(`[ConnectionWizard] Auto-assigned station name: ${i}`)}catch(s){console.warn("[ConnectionWizard] Failed to query /api/state, using localStorage fallback:",s.message);const a=`GM_Station_${localStorage.getItem("lastStationNum")||"1"}`;t&&(t.textContent=a,t.dataset.deviceId=a)}}_findNextStationId(e){const t=e.filter(n=>n&&n.startsWith("GM_Station_")).map(n=>{const a=n.match(/GM_Station_(\d+)$/);return a?parseInt(a[1],10):null}).filter(n=>n!==null).sort((n,a)=>n-a);let s=1;for(const n of t)if(n===s)s++;else if(n>s)break;return`GM_Station_${s}`}selectServer(e){document.getElementById("serverUrl").value=e,document.getElementById("discoveryStatus").textContent="‚úÖ Server selected",this.assignStationName(e)}async handleConnectionSubmit(e){e.preventDefault();const t=document.getElementById("serverUrl").value,s=document.getElementById("gmPassword").value,n=document.getElementById("connectionStatusMsg"),a=document.getElementById("stationNameDisplay"),o=a?a.dataset.deviceId:null;if(!t||!o||!s){n.textContent="‚ö†Ô∏è Please fill in all fields",n.style.color="#ff9800";return}n.textContent="‚è≥ Connecting...",n.style.color="#2196F3";try{let i=t.trim();if(i.match(/^https?:\/\//i)||(i=`http://${i}`,n.textContent=`üîß Using ${i}`),!(await fetch(`${i}/health`,{method:"GET",mode:"cors",signal:AbortSignal.timeout(3e3)})).ok)throw new Error("Server not responding");const u=await fetch(`${i}/api/admin/auth`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({password:s})});if(!u.ok){n.textContent="‚ùå Invalid password",n.style.color="#f44336";return}const{token:l}=await u.json();localStorage.setItem("aln_orchestrator_url",i),localStorage.setItem("aln_auth_token",l),localStorage.setItem("aln_station_name",o);const h=this.app.settings;h.deviceId=o,h.stationName=o,h.save();const m=o.match(/GM_Station_(\d+)$/);if(m){const g=parseInt(m[1],10)+1;localStorage.setItem("lastStationNum",g.toString())}n.textContent="‚úÖ Authenticated! Connecting...",n.style.color="#4CAF50",await this.app.selectGameMode("networked")}catch(i){n.textContent=`‚ùå Connection failed: ${i.message}`,n.style.color="#f44336"}}cancelNetworkedMode(){document.getElementById("connectionModal").style.display="none";const e=this.app.sessionModeManager;e&&e.clearMode(),this.app.uiManager.showScreen("gameModeScreen")}showConnectionWizard(){const e=document.getElementById("connectionModal");e.style.display="flex",setTimeout(()=>this.scanForServers(),100)}async showAuthModal(){this.showConnectionWizard();const e=this.app.networkedSession?.services?.connectionManager;if(e&&e.url&&(document.getElementById("serverUrl").value=e.url,this.assignStationName(e.url)),e&&e.stationName){const t=document.getElementById("stationNameDisplay");t&&(t.textContent=e.stationName,t.dataset.deviceId=e.stationName)}}}class Ne{constructor(e){this.app=e,this.updateQueueIndicator=this.updateQueueIndicator.bind(this)}init(){this.updateQueueIndicator();const e=this.app.networkedSession?.services?.queueManager;e&&e.addEventListener("queue:changed",t=>{console.log("Queue changed:",t.detail),this.updateQueueIndicator()})}updateQueueIndicator(){const e=document.getElementById("queueStatusIndicator"),t=document.getElementById("queueCount");if(!e||!t)return;const n=this.app.networkedSession?.services?.queueManager?.getStatus(),a=n?n.queuedCount:0;t.textContent=a,a>0?e.classList.add("visible"):e.classList.remove("visible")}}function xe(c){window.addEventListener("beforeunload",()=>{c.networkedSession?.services?.client&&(console.log("Page unloading - disconnecting socket"),c.networkedSession.services.client.disconnect())})}function Fe(c,e,t,s,n,a,o){document.addEventListener("click",i=>{const r=i.target.closest("[data-action]");if(!r)return;r.tagName==="A"&&i.preventDefault();const u=r.dataset.action,l=r.dataset.arg,[h,m]=u.split(".");try{switch(h){case"app":typeof c[m]=="function"?c[m](l):s.log(`Action method not found: app.${m}`,!0);break;case"dataManager":typeof e[m]=="function"?e[m](l):s.log(`Action method not found: dataManager.${m}`,!0);break;case"settings":typeof t[m]=="function"?t[m](l):s.log(`Action method not found: settings.${m}`,!0);break;case"debug":typeof s[m]=="function"?s[m](l):s.log(`Action method not found: debug.${m}`,!0);break;case"uiManager":typeof n[m]=="function"?n[m](l):s.log(`Action method not found: uiManager.${m}`,!0);break;case"connectionWizard":typeof a[m]=="function"?a[m](l):s.log(`Action method not found: connectionWizard.${m}`,!0);break;case"queueStatusManager":typeof o[m]=="function"?o[m](l):s.log(`Action method not found: queueStatusManager.${m}`,!0);break;default:s.log(`Unknown action target: ${h}`,!0)}}catch(g){s.log(`Action handler error: ${u} - ${g.message}`,!0),console.error(`Action handler error: ${u}`,g)}})}class Be{constructor({uiManager:e,dataManager:t,debug:s}={}){this.uiManager=e,this.dataManager=t,this.debug=s,this.appContext=null,this.globalHandlers={},this.screenHandlers=new Map,this.containerHandlers={},this.connectedSources=new Map}setAppContext(e){this.appContext=e,this.debug?.log("[ScreenUpdateManager] App context set")}registerGlobalHandler(e,t){this.globalHandlers[e]||(this.globalHandlers[e]=[]),this.globalHandlers[e].push(t),this.debug?.log(`[ScreenUpdateManager] Registered global handler for ${e}`)}registerScreen(e,t){if(!t||typeof t!="object"||Array.isArray(t))throw new TypeError(`[ScreenUpdateManager] registerScreen('${e}'): handlers must be an object, got ${typeof t}`);this.screenHandlers.set(e,t);const s=Object.keys(t).join(", ");this.debug?.log(`[ScreenUpdateManager] Registered screen '${e}' for events: ${s}`)}registerContainer(e,t){this.containerHandlers[e]=t;const s=Object.keys(t).join(", ");this.debug?.log(`[ScreenUpdateManager] Registered container '${e}' for events: ${s}`)}getActiveScreenId(){const e=document.querySelector(".screen.active");if(!e)return null;const t=e.id;return t.endsWith("Screen")?t.replace("Screen",""):(console.warn(`[ScreenUpdateManager] Unexpected screen ID pattern: '${t}' (expected 'xxxScreen' format). Screen handlers may not work correctly.`),t)}onDataUpdate(e,t){this.debug?.log(`[ScreenUpdateManager] ${e} event received`);const s=this.globalHandlers[e]||[];for(const i of s)try{i(t)}catch(r){console.error(`[ScreenUpdateManager] Global handler error for ${e}:`,r)}for(const[i,r]of Object.entries(this.containerHandlers)){const u=document.getElementById(i);if(u&&r[e])try{r[e](t,u)}catch(l){console.error(`[ScreenUpdateManager] Container handler error for ${i}/${e}:`,l)}}const n=this.getActiveScreenId();if(!n){this.debug?.log("[ScreenUpdateManager] No active screen, skipping screen handler");return}const o=this.screenHandlers.get(n)?.[e];if(o){this.debug?.log(`[ScreenUpdateManager] Running ${e} handler for screen '${n}'`);try{o(t,this.appContext)}catch(i){console.error(`[ScreenUpdateManager] Screen handler error for ${n}/${e}:`,i)}}}connectToDataSource(e,t){this.connectedSources.has(e)||this.connectedSources.set(e,new Map);const s=this.connectedSources.get(e);for(const n of t){const a=o=>{this.onDataUpdate(n,o.detail)};s.set(n,a),e.addEventListener(n,a)}this.debug?.log(`[ScreenUpdateManager] Connected to data source for events: ${t.join(", ")}`)}disconnectFromDataSource(e){const t=this.connectedSources.get(e);if(!t){this.debug?.log("[ScreenUpdateManager] No listeners found for data source, skipping disconnect");return}for(const[s,n]of t)e.removeEventListener(s,n);this.connectedSources.delete(e),this.debug?.log(`[ScreenUpdateManager] Disconnected from data source (${t.size} listeners removed)`)}disconnectAll(){for(const e of this.connectedSources.keys())this.disconnectFromDataSource(e);this.debug?.log("[ScreenUpdateManager] Disconnected from all data sources")}}const M=new se({tokenManager:G,sessionModeManager:null,debug:d}),Ge=new ne,y=new V({settings:N,dataManager:M}),k=new Be({uiManager:y,dataManager:M,debug:d});k.registerGlobalHandler("transaction:added",()=>{y.updateHistoryBadge(),y.updateSessionStats()});k.registerGlobalHandler("transaction:deleted",()=>{y.updateHistoryBadge(),y.updateSessionStats()});k.registerGlobalHandler("data:cleared",()=>{y.updateHistoryBadge()});k.registerGlobalHandler("game-state:updated",()=>{y.updateHistoryBadge(),y.updateSessionStats()});k.registerScreen("history",{"transaction:added":()=>{d.log("[main.js] History screen active - rendering game activity"),y.updateHistoryStats();const c=document.getElementById("historyContainer");c&&y.renderGameActivity(c,{showSummary:!0,showFilters:!0})},"transaction:deleted":()=>{d.log("[main.js] History screen active - re-rendering after deletion"),y.updateHistoryStats();const c=document.getElementById("historyContainer");c&&y.renderGameActivity(c,{showSummary:!0,showFilters:!0})},"player-scan:added":()=>{d.log("[main.js] History screen active - rendering game activity (player scan)");const c=document.getElementById("historyContainer");c&&y.renderGameActivity(c,{showSummary:!0,showFilters:!0})}});k.registerScreen("teamDetails",{"transaction:added":(c,e)=>{const t=e?.currentInterventionTeamId;if(t){d.log(`[main.js] Team details active - re-rendering for team ${t}`);const s=M.getTeamTransactions(t);y.renderTeamDetails(t,s)}},"transaction:deleted":(c,e)=>{const t=e?.currentInterventionTeamId;if(t){d.log(`[main.js] Team details active - re-rendering after deletion for team ${t}`);const s=M.getTeamTransactions(t);y.renderTeamDetails(t,s)}},"team-score:updated":(c,e)=>{const{teamId:t,transactions:s}=c||{},n=e?.currentInterventionTeamId;n&&n===t&&(d.log(`[main.js] Team details active - score update for team ${t}`),y.renderTeamDetails(t,s))}});k.registerContainer("scoreboardContainer",{"team-score:updated":(c,e)=>{d.log("[main.js] Updating scoreboardContainer"),y.renderScoreboard(e)},"scores:cleared":(c,e)=>{d.log("[main.js] Clearing scoreboardContainer"),e.innerHTML=""},"data:cleared":(c,e)=>{d.log("[main.js] Session reset - clearing scoreboardContainer"),e.innerHTML=""}});k.registerContainer("admin-score-board",{"team-score:updated":(c,e)=>{d.log("[main.js] Updating admin-score-board"),y.renderScoreboard(e)},"scores:cleared":(c,e)=>{d.log("[main.js] Clearing admin-score-board"),e.innerHTML=""},"data:cleared":(c,e)=>{d.log("[main.js] Session reset - clearing admin-score-board"),e.innerHTML=""}});k.registerContainer("admin-game-activity",{"transaction:added":(c,e)=>{d.log("[main.js] Updating admin-game-activity (transaction added)"),y.renderGameActivity(e,{showSummary:!0,showFilters:!0})},"transaction:deleted":(c,e)=>{d.log("[main.js] Updating admin-game-activity (transaction deleted)"),y.renderGameActivity(e,{showSummary:!0,showFilters:!0})},"player-scan:added":(c,e)=>{d.log("[main.js] Updating admin-game-activity (player scan)"),y.renderGameActivity(e,{showSummary:!0,showFilters:!0})},"data:cleared":(c,e)=>{d.log("[main.js] Session reset - clearing admin-game-activity"),e.innerHTML=""}});k.registerContainer("session-status-container",{"session:updated":(c,e)=>{d.log("[main.js] Updating session-status-container (session updated)"),y.renderSessionStatus(e)},"data:cleared":(c,e)=>{d.log("[main.js] Session reset - re-rendering session-status-container"),y.renderSessionStatus(e)}});k.connectToDataSource(M,["transaction:added","transaction:deleted","scores:cleared","data:cleared","game-state:updated","team-score:updated","player-scan:added","session:updated"]);const E=new j({debug:d,uiManager:y,settings:N,tokenManager:G,dataManager:M,teamRegistry:Ge,nfcHandler:U,config:B,initializationSteps:q});k.setAppContext(E);const L=new Le(E),Q=new Ne(E);E.showConnectionWizard=L.showConnectionWizard.bind(L);Fe(E,M,N,d,y,L,Q);xe(E);async function z(){d.log("=== ALNScanner ES6 Module Architecture ==="),d.log("Main entry point loaded"),d.log("Initializing application...");try{await E.init(),d.log("Application initialization complete"),L.init(),d.log("Connection wizard initialized"),Q.init(),d.log("Queue status manager initialized")}catch(c){d.log(`Initialization error: ${c.message}`,!0),console.error("App initialization failed:",c),y&&y.showError(`Failed to initialize: ${c.message}`)}}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",z):z();
//# sourceMappingURL=main-BGbVYmjY.js.map
