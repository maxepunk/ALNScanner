{"version":3,"file":"main-BDF0Frq9.js","sources":["../../src/utils/config.js","../../src/utils/debug.js","../../src/ui/uiManager.js","../../src/ui/settings.js","../../src/core/tokenManager.js","../../src/core/storage/IStorageStrategy.js","../../src/core/scoring.js","../../src/core/storage/LocalStorage.js","../../src/core/storage/NetworkedStorage.js","../../src/core/dataManagerUtils.js","../../src/core/unifiedDataManager.js","../../src/core/teamRegistry.js","../../src/utils/nfcHandler.js","../../src/services/StateValidationService.js","../../src/app/initializationSteps.js","../../src/app/sessionModeManager.js","../../src/network/orchestratorClient.js","../../src/network/connectionManager.js","../../src/network/networkedQueueManager.js","../../src/admin/utils/CommandSender.js","../../src/admin/SessionManager.js","../../src/admin/VideoController.js","../../src/admin/DisplayController.js","../../src/admin/SystemMonitor.js","../../src/admin/AdminOperations.js","../../src/admin/MonitoringDisplay.js","../../src/app/adminController.js","../../src/network/networkedSession.js","../../src/app/app.js","../../src/ui/connectionWizard.js","../../src/utils/domEventBindings.js","../../src/ui/ScreenUpdateManager.js","../../src/main.js"],"sourcesContent":["/**\n * Application Configuration Constants\n * ES6 Module Export\n */\n\nexport const CONFIG = {\n    MAX_TEAM_ID_LENGTH: 6,\n    MAX_DEBUG_MESSAGES: 50,\n    ANIMATION_DURATION: 200,\n    MODE_TOGGLE_SCALE: 1.1,\n    SCAN_SIMULATION_DELAY: 1000,\n    NFC_PULSE_INTERVAL: 2000\n};\n\n// Export as default as well for convenience\nexport default CONFIG;\n","/**\n * Debug Logging System\n * ES6 Module Export\n */\n\nimport CONFIG from './config.js';\n\nclass DebugLogger {\n  constructor() {\n    this.messages = [];\n  }\n\n  /**\n   * Log a debug message\n   * @param {string} message - Message to log\n   * @param {boolean} isError - Whether this is an error message\n   */\n  log(message, isError = false) {\n    const timestamp = new Date().toLocaleTimeString();\n    const prefix = isError ? '‚ùå' : '‚úì';\n    const formatted = `[${timestamp}] ${prefix} ${message}`;\n\n    this.messages.push(formatted);\n    if (this.messages.length > CONFIG.MAX_DEBUG_MESSAGES) {\n      this.messages.shift();\n    }\n\n    this.updatePanel();\n\n    if (isError) {\n      console.error(message);\n    } else {\n      console.log(message);\n    }\n  }\n\n  /**\n   * Update the debug panel display\n   * @param {Object} app - App instance (for viewController access)\n   */\n  updatePanel(app = null) {\n    const content = document.getElementById('debugContent');\n    if (content) {\n      content.textContent = this.messages.join('\\n');\n      // Auto-scroll to bottom if debug view is active\n      // TODO: Remove app parameter once App is converted to ES6\n      if (app?.viewController?.currentView === 'debug') {\n        content.scrollTop = content.scrollHeight;\n      }\n    }\n  }\n\n  /**\n   * Toggle debug panel visibility\n   * @param {Object} app - App instance (for viewController access)\n   */\n  toggle(app = null) {\n    // TODO: Remove app parameter once App is converted to ES6\n    if (app?.viewController) {\n      if (app.viewController.currentView === 'debug') {\n        app.viewController.switchView('scanner');\n      } else {\n        app.viewController.switchView('debug');\n      }\n    } else {\n      console.warn('Debug view not available in this mode');\n    }\n  }\n\n  /**\n   * Clear all debug messages\n   */\n  clear() {\n    this.messages = [];\n    this.updatePanel();\n  }\n}\n\n// Create singleton instance\nconst Debug = new DebugLogger();\n\nexport default Debug;\nexport { DebugLogger };\n","/**\n * UI Manager Module\n * Manages all UI rendering and screen navigation\n * ES6 Module - Pure Rendering Layer (does NOT extend EventTarget)\n *\n * Responsibilities:\n * - Screen navigation\n * - DOM updates and rendering\n * - Error/toast notifications\n * - Mode display management\n * - Scoreboard and team details rendering\n */\n\nclass UIManager {\n  /**\n   * Create UIManager instance\n   * @param {Object} options - Dependency injection options\n   * @param {Object} options.settings - Settings instance (for mode checking)\n   * @param {Object} options.dataManager - UnifiedDataManager instance\n   * @param {Object} options.sessionModeManager - SessionModeManager instance (for mode check)\n   * @param {Object} options.app - App instance (for callbacks like showTeamDetails, deleteTeamTransaction)\n   */\n  constructor({ settings, dataManager, sessionModeManager, app } = {}) {\n    this.settings = settings;\n    this.dataManager = dataManager;\n    this.sessionModeManager = sessionModeManager;\n    this.app = app;\n\n    this.screens = {};\n    this.previousScreen = null;\n    this.errorContainer = null;\n  }\n\n  /**\n   * Initialize UI elements\n   * Caches screen references and sets up error container\n   */\n  init() {\n    this.screens = {\n      loading: document.getElementById('loadingScreen'),\n      settings: document.getElementById('settingsScreen'),\n      gameModeScreen: document.getElementById('gameModeScreen'),\n      teamEntry: document.getElementById('teamEntryScreen'),\n      scan: document.getElementById('scanScreen'),\n      result: document.getElementById('resultScreen'),\n      history: document.getElementById('historyScreen'),\n      scoreboard: document.getElementById('scoreboardScreen'),\n      teamDetails: document.getElementById('teamDetailsScreen')\n    };\n\n    // Initialize error display container\n    this.initErrorDisplay();\n  }\n\n  /**\n   * Initialize error display container\n   */\n  initErrorDisplay() {\n    // Create error container if doesn't exist\n    if (!document.getElementById('error-container')) {\n      const container = document.createElement('div');\n      container.id = 'error-container';\n      container.className = 'error-container';\n      document.body.appendChild(container);\n    }\n    this.errorContainer = document.getElementById('error-container');\n  }\n\n  /**\n   * Show error message to user\n   * @param {string} message - Error message to display\n   * @param {number} duration - Duration in milliseconds (default 5000)\n   */\n  showError(message, duration = 5000) {\n    if (!this.errorContainer) {\n      this.initErrorDisplay();\n    }\n\n    const errorDiv = document.createElement('div');\n    errorDiv.className = 'error-message';\n    errorDiv.textContent = message;\n\n    this.errorContainer.appendChild(errorDiv);\n\n    // Auto-dismiss after duration\n    setTimeout(() => {\n      errorDiv.style.animation = 'slideOut 0.3s ease-out forwards';\n      setTimeout(() => errorDiv.remove(), 300);\n    }, duration);\n  }\n\n  /**\n   * Show toast notification to user\n   * @param {string} message - Notification message\n   * @param {string} type - Toast type: 'info', 'success', 'warning', 'error'\n   * @param {number} duration - Duration in milliseconds (default 3000)\n   */\n  showToast(message, type = 'info', duration = 3000) {\n    if (!this.errorContainer) {\n      this.initErrorDisplay();\n    }\n\n    const toast = document.createElement('div');\n    toast.className = `toast toast-${type}`;\n    toast.textContent = message;\n\n    this.errorContainer.appendChild(toast);\n\n    // Auto-dismiss after duration\n    setTimeout(() => {\n      toast.style.animation = 'slideOut 0.3s ease-out forwards';\n      setTimeout(() => toast.remove(), 300);\n    }, duration);\n  }\n\n  /**\n   * Show specified screen\n   * @param {string} screenName - Name of screen to show\n   */\n  showScreen(screenName) {\n    // Track previous screen for back navigation\n    const current = document.querySelector('.screen.active');\n    if (current && current.id !== 'historyScreen' &&\n      current.id !== 'scoreboardScreen' &&\n      current.id !== 'teamDetailsScreen' &&\n      current.id !== 'gameModeScreen' &&\n      current.id !== 'loadingScreen' &&\n      screenName !== 'history' &&\n      screenName !== 'scoreboard' &&\n      screenName !== 'teamDetails') {\n      this.previousScreen = current.id.replace('Screen', '');\n    }\n\n    // Hide all screens\n    Object.values(this.screens).forEach(screen => {\n      if (screen) {\n        screen.classList.remove('active');\n      }\n    });\n\n    // Show requested screen\n    if (this.screens[screenName]) {\n      this.screens[screenName].classList.add('active');\n    }\n\n    // Screen-specific initialization callbacks\n    if (screenName === 'teamEntry' && this.app?.initTeamEntryUI) {\n      this.app.initTeamEntryUI();\n    }\n    if (screenName === 'scoreboard') {\n      this.renderScoreboard();\n    }\n    if (screenName === 'result') {\n      this._enableResultScreenQuickDismiss();\n    }\n  }\n\n  /**\n   * Enable quick-dismiss behavior on result screen\n   * Tap anywhere (except buttons) returns to scan screen\n   * @private\n   */\n  _enableResultScreenQuickDismiss() {\n    const resultScreen = this.screens.result;\n    if (!resultScreen) return;\n\n    const dismissHandler = (event) => {\n      // Don't dismiss if clicking any button (let data-action handlers handle navigation)\n      if (event.target.closest('button')) {\n        return;\n      }\n      resultScreen.removeEventListener('click', dismissHandler);\n      this.showScreen('scan');\n    };\n\n    // Remove any existing handler first (prevents stacking)\n    if (resultScreen._quickDismissHandler) {\n      resultScreen.removeEventListener('click', resultScreen._quickDismissHandler);\n    }\n    resultScreen._quickDismissHandler = dismissHandler;\n    resultScreen.addEventListener('click', dismissHandler);\n  }\n\n  /**\n   * Update mode display elements\n   * @param {string} mode - 'detective' or 'blackmarket'\n   */\n  updateModeDisplay(mode) {\n    const indicator = document.getElementById('modeIndicator');\n    const modeText = document.getElementById('modeText');\n    const toggle = document.getElementById('modeToggle');\n\n    if (!indicator) return;\n\n    if (mode === 'blackmarket') {\n      indicator.className = 'mode-indicator mode-blackmarket';\n      indicator.textContent = 'Black Market Mode';\n      if (modeText) modeText.textContent = 'Black Market Mode';\n      if (toggle) toggle.checked = true;\n    } else {\n      indicator.className = 'mode-indicator mode-detective';\n      indicator.textContent = 'Detective Mode';\n      if (modeText) modeText.textContent = 'Detective Mode';\n      if (toggle) toggle.checked = false;\n    }\n\n    this.updateNavigationButtons();\n  }\n\n  /**\n   * Update navigation button visibility\n   */\n  updateNavigationButtons() {\n    const scoreboardButton = document.getElementById('scoreboardButton');\n    if (scoreboardButton && this.settings) {\n      scoreboardButton.style.display =\n        this.settings.mode === 'blackmarket' ? 'block' : 'none';\n    }\n  }\n\n  /**\n   * Update team display\n   * @param {string} teamId - Team ID to display\n   */\n  updateTeamDisplay(teamId) {\n    const display = document.getElementById('teamDisplay');\n    if (display) {\n      display.textContent = teamId || '_';\n    }\n  }\n\n  /**\n   * Update session statistics display\n   */\n  updateSessionStats() {\n    const dataSource = this.dataManager;\n    if (!dataSource || !this.settings) return;\n\n    const stats = dataSource.getSessionStats();\n    const tokenCount = document.getElementById('teamTokenCount');\n    const valueElement = document.getElementById('teamTotalValue');\n    const labelElement = document.getElementById('teamValueLabel');\n\n    if (tokenCount) {\n      tokenCount.textContent = stats.count;\n    }\n\n    if (valueElement) {\n      if (this.settings.mode === 'blackmarket') {\n        valueElement.textContent = `$${stats.totalScore.toLocaleString()}`;\n        if (labelElement) labelElement.textContent = 'Score';\n      } else {\n        valueElement.textContent = stats.totalValue;\n        if (labelElement) labelElement.textContent = 'Total Value';\n      }\n    }\n  }\n\n  /**\n   * Update history badge count\n   */\n  updateHistoryBadge() {\n    const dataSource = this.dataManager;\n    if (!dataSource) return;\n\n    const badge = document.getElementById('historyBadge');\n    if (!badge) return;\n\n    // Check if strategy is initialized before accessing transactions\n    if (!dataSource.getActiveStrategyType()) {\n      badge.style.display = 'none';\n      return;\n    }\n\n    const count = dataSource.getTransactions().length;\n    if (count > 0) {\n      badge.textContent = count;\n      badge.style.display = 'inline';\n    } else {\n      badge.style.display = 'none';\n    }\n  }\n\n  /**\n   * Update history statistics\n   */\n  updateHistoryStats() {\n    const dataSource = this.dataManager;\n    if (!dataSource) return;\n\n    const stats = dataSource.getGlobalStats();\n    const totalScans = document.getElementById('totalScans');\n    const uniqueTeams = document.getElementById('uniqueTeams');\n    const totalValue = document.getElementById('totalValue');\n    const avgValue = document.getElementById('avgValue');\n\n    if (totalScans) totalScans.textContent = stats.total;\n    if (uniqueTeams) uniqueTeams.textContent = stats.teams;\n    if (totalValue) totalValue.textContent = stats.totalValue;\n    if (avgValue) avgValue.textContent = stats.avgValue;\n  }\n\n  /**\n   * Render scoreboard\n   * @param {HTMLElement|null} container - Optional container element. Defaults to #scoreboardContainer\n   */\n  renderScoreboard(container = null) {\n    const dataSource = this.dataManager;\n    if (!dataSource || !this.app) return;\n\n    // Use provided container or default to scoreboardContainer\n    const targetContainer = container || document.getElementById('scoreboardContainer');\n    if (!targetContainer) return;\n\n    const teamScores = dataSource.getTeamScores();\n\n    if (teamScores.length === 0) {\n      targetContainer.innerHTML = `\n        <div class=\"empty-state\">\n          <h3>No Teams Yet</h3>\n          <p>Teams will appear here after scanning tokens</p>\n        </div>\n      `;\n      return;\n    }\n\n    // Add score source indicator\n    const scoreSource = teamScores[0]?.isFromBackend ?\n      '<div class=\"score-source\" style=\"text-align: center; margin: 10px 0; padding: 10px; background: rgba(103,126,234,0.1); border-radius: 8px; font-size: 14px;\">üîó Live from Orchestrator</div>' :\n      '<div class=\"score-source\" style=\"text-align: center; margin: 10px 0; padding: 10px; background: rgba(255,152,0,0.1); border-radius: 8px; font-size: 14px;\">üì± Local Calculation</div>';\n\n    targetContainer.innerHTML = scoreSource + teamScores.map((team, index) => {\n      const rank = index + 1;\n      const rankClass = rank <= 3 ? `rank-${rank}` : '';\n      const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `#${rank}`;\n\n      return `\n        <div class=\"scoreboard-entry ${rankClass}\" data-action=\"app.showTeamDetails\" data-arg=\"${team.teamId}\" style=\"cursor: pointer;\">\n          <div class=\"scoreboard-rank\">${medal}</div>\n          <div class=\"scoreboard-team\">\n            Team ${team.teamId}\n            <span class=\"scoreboard-tokens\">(${team.tokenCount} tokens)</span>\n          </div>\n          <div class=\"scoreboard-score\">$${team.score.toLocaleString()}</div>\n        </div>\n      `;\n    }).join('');\n  }\n\n  /**\n   * Render session status display (mode-agnostic)\n   * Used by standalone mode admin panel\n   * @param {HTMLElement} container - Container element\n   */\n  renderSessionStatus(container) {\n    if (!container) return;\n\n    const session = this.dataManager?.getCurrentSession?.();\n\n    // No session\n    if (!session) {\n      container.innerHTML = `\n        <div class=\"session-status session-status--empty\">\n          <p class=\"session-status__message\">No Active Session</p>\n          <p class=\"session-status__hint\">Create a new session to begin tracking gameplay</p>\n          <button class=\"btn btn-primary\" data-action=\"app.adminCreateSession\">\n            Create New Session\n          </button>\n        </div>\n      `;\n      return;\n    }\n\n    // Calculate duration\n    const startTime = new Date(session.startTime);\n    const duration = this._formatDuration(Date.now() - startTime.getTime());\n\n    // Paused session\n    if (session.status === 'paused') {\n      container.innerHTML = `\n        <div class=\"session-status session-status--paused\">\n          <h4 class=\"session-status__header\">\n            <span class=\"session-status__icon\">‚è∏Ô∏è</span>\n            <span>${this.escapeHtml(session.name || 'Session')}</span>\n            <span class=\"session-status__badge session-status__badge--paused\">Paused</span>\n          </h4>\n          <div class=\"session-status__details\">\n            <span>Started: ${startTime.toLocaleTimeString()}</span>\n            <span>Duration: ${duration}</span>\n          </div>\n          <div class=\"session-status__actions\">\n            <button class=\"btn btn-primary\" data-action=\"app.adminResumeSession\">\n              Resume Session\n            </button>\n            <button class=\"btn btn-danger\" data-action=\"app.adminEndSession\">\n              End Session\n            </button>\n          </div>\n        </div>\n      `;\n      return;\n    }\n\n    // Active session (default)\n    container.innerHTML = `\n      <div class=\"session-status session-status--active\">\n        <h4 class=\"session-status__header\">\n          <span class=\"session-status__icon\">üéÆ</span>\n          <span>${this.escapeHtml(session.name || 'Session')}</span>\n          <span class=\"session-status__badge session-status__badge--active\">Active</span>\n        </h4>\n        <div class=\"session-status__details\">\n          <span>Started: ${startTime.toLocaleTimeString()}</span>\n          <span>Duration: ${duration}</span>\n        </div>\n        <div class=\"session-status__actions\">\n          <button class=\"btn btn-secondary\" data-action=\"app.adminPauseSession\">\n            Pause Session\n          </button>\n          <button class=\"btn btn-danger\" data-action=\"app.adminEndSession\">\n            End Session\n          </button>\n        </div>\n      </div>\n    `;\n  }\n\n  /**\n   * Format duration in milliseconds to human readable\n   * @private\n   */\n  _formatDuration(ms) {\n    if (!ms || ms < 0) return '0m';\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n\n    if (hours > 0) {\n      return `${hours}h ${minutes % 60}m`;\n    } else if (minutes > 0) {\n      return `${minutes}m`;\n    } else {\n      return `${seconds}s`;\n    }\n  }\n\n  /**\n   * Render team details with enhanced grouping\n   * @param {string} teamId - Team ID\n   * @param {Array} transactions - Team transactions\n   */\n  renderTeamDetails(teamId, transactions) {\n    const dataSource = this.dataManager;\n    if (!dataSource) return;\n\n    // Get enhanced data structure\n    const enhancedData = dataSource.getEnhancedTeamTransactions(teamId);\n    const scoreData = dataSource.calculateTeamScoreWithBonuses(teamId);\n\n    // Check if networked mode for intervention controls\n    const isNetworked = this.sessionModeManager?.isNetworked();\n\n    // Update header\n    const titleEl = document.getElementById('teamDetailsTitle');\n    const summaryEl = document.getElementById('teamDetailsSummary');\n\n    if (titleEl) {\n      titleEl.textContent = `Team ${teamId}`;\n    }\n    if (summaryEl) {\n      summaryEl.textContent = `${transactions.length} token${transactions.length !== 1 ? 's' : ''} collected`;\n    }\n\n    // Build HTML with grouped sections\n    let html = '';\n\n    // Completed Groups Section\n    if (enhancedData.hasCompletedGroups) {\n      html += '<div class=\"section-divider\">‚úÖ Completed Groups</div>';\n\n      enhancedData.completedGroups.forEach(group => {\n        html += `\n          <div class=\"group-section\">\n            <div class=\"group-header completed\">\n              <div class=\"group-title\">\n                <span class=\"completion-badge\">üèÜ</span>\n                <span class=\"group-name\">${group.displayName}</span>\n                <span class=\"completion-text\">COMPLETE</span>\n              </div>\n              <div class=\"bonus-amount\">\n                +$${group.bonusValue.toLocaleString()} bonus (${group.multiplier}x)\n              </div>\n            </div>`;\n\n        // Add tokens in this group\n        const hasActiveSession = this.sessionModeManager?.isNetworked() || this.sessionModeManager?.isStandalone();\n        group.tokens.forEach(token => {\n          html += this.renderTokenCard(token, true, false, hasActiveSession);\n        });\n\n        html += '</div>';\n      });\n    }\n\n    // In-progress Groups Section\n    if (enhancedData.hasIncompleteGroups) {\n      html += '<div class=\"section-divider\">üî∂ In Progress Groups</div>';\n\n      enhancedData.incompleteGroups.forEach(group => {\n        html += `\n          <div class=\"group-section\">\n            <div class=\"group-header in-progress\">\n              <div class=\"group-title\">\n                <span class=\"progress-badge\">‚è≥</span>\n                <span class=\"group-name\">${group.displayName}</span>\n                <span class=\"progress-text\">${group.progress}</span>\n              </div>\n              <div class=\"progress-bar\">\n                <div class=\"progress-fill\" style=\"width: ${group.percentage}%\"></div>\n              </div>\n            </div>`;\n\n        // Add tokens in this group\n        const hasActiveSession = this.sessionModeManager?.isNetworked() || this.sessionModeManager?.isStandalone();\n        group.tokens.forEach(token => {\n          html += this.renderTokenCard(token, false, false, hasActiveSession);\n        });\n\n        html += '</div>';\n      });\n    }\n\n    // Ungrouped Tokens Section\n    if (enhancedData.hasUngroupedTokens) {\n      html += '<div class=\"section-divider\">üì¶ Individual Tokens</div>';\n\n      const hasActiveSession = this.sessionModeManager?.isNetworked() || this.sessionModeManager?.isStandalone();\n      enhancedData.ungroupedTokens.forEach(token => {\n        html += this.renderTokenCard(token, false, false, hasActiveSession);\n      });\n    }\n\n    // Unknown Tokens Section\n    if (enhancedData.hasUnknownTokens) {\n      html += '<div class=\"section-divider\">‚ùì Unknown Tokens</div>';\n\n      enhancedData.unknownTokens.forEach(token => {\n        html += this.renderTokenCard(token, false, true, isNetworked);\n      });\n    }\n\n    // Handle empty state\n    if (html === '') {\n      html = `\n        <div class=\"empty-state\">\n          <h3>No Tokens</h3>\n          <p>This team hasn't scanned any tokens yet</p>\n        </div>\n      `;\n    }\n\n    // Update container\n    const container = document.getElementById('teamDetailsContainer');\n    if (container) {\n      container.innerHTML = html;\n    }\n\n    // Check if backend has authoritative score (networked mode only)\n    // backendScores only exists in networked mode\n    const backendScore = isNetworked && this.dataManager?.backendScores?.get(teamId);\n\n    // Use backend scores if available (authoritative in networked mode)\n    let displayBaseScore = scoreData.baseScore;\n    let displayBonusScore = scoreData.bonusScore;\n    let displayTotalScore = scoreData.totalScore;\n\n    if (isNetworked && backendScore) {\n      displayBaseScore = backendScore.baseScore;\n      displayBonusScore = backendScore.bonusPoints;\n      displayTotalScore = backendScore.currentScore;\n    }\n\n    // Update score breakdown with authoritative values\n    const baseScoreEl = document.getElementById('teamBaseScore');\n    const bonusScoreEl = document.getElementById('teamBonusScore');\n    const totalScoreEl = document.getElementById('teamTotalScore');\n\n    if (baseScoreEl) baseScoreEl.textContent = `$${displayBaseScore.toLocaleString()}`;\n    if (bonusScoreEl) bonusScoreEl.textContent = `$${displayBonusScore.toLocaleString()}`;\n    if (totalScoreEl) totalScoreEl.textContent = `$${displayTotalScore.toLocaleString()}`;\n\n    // Display admin adjustments if present\n    const adjustmentsSection = document.getElementById('teamAdminAdjustmentsSection');\n    if (adjustmentsSection && isNetworked && backendScore?.adminAdjustments?.length > 0) {\n      const adjustments = backendScore.adminAdjustments;\n      const totalAdjustment = adjustments.reduce((sum, adj) => sum + adj.delta, 0);\n\n      let adjHtml = `\n        <div class=\"transaction-detail\" style=\"margin: 8px 0; padding: 12px; background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; border-radius: 4px;\">\n          <label style=\"color: #856404; font-weight: bold;\">‚ö†Ô∏è Admin Adjustments:</label>\n          <span class=\"value\" style=\"color: ${totalAdjustment >= 0 ? '#28a745' : '#dc3545'}; font-weight: bold;\">\n            ${totalAdjustment >= 0 ? '+' : ''}$${Math.abs(totalAdjustment).toLocaleString()}\n          </span>\n        </div>\n        <div style=\"margin-left: 20px; font-size: 12px; color: #666;\">\n      `;\n\n      adjustments.forEach(adj => {\n        const date = new Date(adj.timestamp).toLocaleString();\n        adjHtml += `\n          <div style=\"margin: 4px 0; padding: 6px; background: #f8f9fa; border-radius: 3px;\">\n            <span style=\"color: ${adj.delta >= 0 ? '#28a745' : '#dc3545'}; font-weight: bold;\">\n              ${adj.delta >= 0 ? '+' : ''}$${Math.abs(adj.delta).toLocaleString()}\n            </span>\n            - ${adj.reason || 'No reason provided'}\n            <br><span style=\"font-size: 10px; color: #999;\">${date} by ${adj.gmStation}</span>\n          </div>\n        `;\n      });\n\n      adjHtml += '</div>';\n      adjustmentsSection.innerHTML = adjHtml;\n      adjustmentsSection.style.display = 'block';\n    } else if (adjustmentsSection) {\n      adjustmentsSection.style.display = 'none';\n    }\n\n    // Show intervention controls in both networked and standalone modes\n    const interventionControls = document.getElementById('teamInterventionControls');\n    if (interventionControls) {\n      // Show controls if we have an active game session (networked or standalone)\n      const hasActiveSession = this.sessionModeManager?.isNetworked() || this.sessionModeManager?.isStandalone();\n      interventionControls.style.display = hasActiveSession ? 'block' : 'none';\n    }\n\n    // Store team ID for intervention handlers\n    if (this.app) {\n      this.app.currentInterventionTeamId = teamId;\n    }\n  }\n\n  /**\n   * Render individual token card\n   * @param {Object} token - Token data (transaction object)\n   * @param {boolean} hasBonus - Whether token has group bonus\n   * @param {boolean} isUnknown - Whether token is unknown\n   * @param {boolean} showDelete - Show delete button (both networked and standalone modes)\n   * @returns {string} HTML string\n   */\n  renderTokenCard(token, hasBonus = false, isUnknown = false, showDelete = false) {\n    const dataSource = this.dataManager;\n    if (!dataSource) return '';\n\n    const tokenValue = dataSource.calculateTokenValue(token);\n\n    // Add duplicate marker\n    const isDuplicate = token.status === 'duplicate';\n    let cardClass = isUnknown ? 'unknown' : (hasBonus ? 'bonus-applied' : '');\n    if (isDuplicate) cardClass += ' duplicate';\n\n    let calculationText = '';\n    if (!isUnknown && !token.isUnknown) {\n      const baseValue = dataSource.SCORING_CONFIG.BASE_VALUES[token.valueRating] || 0;\n      const multiplier = dataSource.SCORING_CONFIG.TYPE_MULTIPLIERS[token.memoryType] || 1;\n\n      if (hasBonus) {\n        const groupInfo = dataSource.parseGroupInfo(token.group);\n        const finalValue = tokenValue * groupInfo.multiplier;\n        calculationText = `\n          <strong>${baseValue.toLocaleString()}</strong> √ó\n          <strong>${multiplier}x</strong> ${token.memoryType} √ó\n          <strong>${groupInfo.multiplier}x</strong> group =\n          <strong>$${finalValue.toLocaleString()}</strong>`;\n      } else {\n        calculationText = `\n          <strong>${baseValue.toLocaleString()}</strong> √ó\n          <strong>${multiplier}x</strong> ${token.memoryType} =\n          <strong>$${tokenValue.toLocaleString()}</strong>`;\n      }\n    } else {\n      calculationText = 'Unknown token - No value';\n    }\n\n    // Delete button (both modes)\n    const deleteButton = showDelete && token.id ? `\n      <button class=\"btn\" data-action=\"app.deleteTeamTransaction\" data-arg=\"${token.id}\"\n              style=\"background: #dc3545; color: white; padding: 4px 8px; font-size: 12px; margin-left: 8px; cursor: pointer;\">\n        üóëÔ∏è Delete\n      </button>\n    ` : '';\n\n    const groupInfo = dataSource.parseGroupInfo(token.group);\n    const displayValue = hasBonus ? tokenValue * groupInfo.multiplier : tokenValue;\n\n    return `\n      <div class=\"token-detail-card ${cardClass}\">\n        <div class=\"token-detail-header\">\n          <span>${token.group}</span>\n          <span class=\"token-detail-value\" style=\"display: flex; align-items: center;\">\n            <span style=\"margin-right: 8px;\">$${displayValue.toLocaleString()}</span>\n            ${deleteButton}\n          </span>\n        </div>\n        <div class=\"token-detail-grid\">\n          <div class=\"token-detail-item\">\n            <span class=\"token-detail-label\">RFID</span>\n            <span class=\"token-detail-info\">${token.rfid}</span>\n          </div>\n          <div class=\"token-detail-item\">\n            <span class=\"token-detail-label\">Memory Type</span>\n            <span class=\"token-detail-info\">${token.memoryType}</span>\n          </div>\n          <div class=\"token-detail-item\">\n            <span class=\"token-detail-label\">Base Rating</span>\n            <span class=\"token-detail-info\">\n              ${isUnknown ? 'N/A' : `‚≠ê${'‚≠ê'.repeat(Math.max(0, token.valueRating - 1))}`}\n            </span>\n          </div>\n          <div class=\"token-detail-item\">\n            <span class=\"token-detail-label\">Status</span>\n            <span class=\"token-detail-info\">\n              ${isDuplicate ? '‚ö†Ô∏è Duplicate' : hasBonus ? '‚úÖ Bonus Applied' : isUnknown ? '‚ùì Unknown' : '‚è≥ No Bonus'}\n            </span>\n          </div>\n          <div class=\"token-calculation\">\n            ${calculationText}\n          </div>\n        </div>\n      </div>\n    `;\n  }\n\n  /**\n   * Show notification for group completion (from backend event)\n   * @param {Object} data - Group completion data\n   */\n  showGroupCompletionNotification(data) {\n    // Create a temporary notification element\n    const notification = document.createElement('div');\n    notification.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      background: linear-gradient(135deg, #667eea, #764ba2);\n      color: white;\n      padding: 15px 20px;\n      border-radius: 12px;\n      box-shadow: 0 10px 30px rgba(0,0,0,0.3);\n      z-index: 10000;\n      animation: slideIn 0.3s ease-out;\n      max-width: 350px;\n    `;\n\n    notification.innerHTML = `\n      <div style=\"display: flex; align-items: center; gap: 10px;\">\n        <span style=\"font-size: 24px;\">üèÜ</span>\n        <div>\n          <div style=\"font-weight: bold; margin-bottom: 5px;\">Group Completed!</div>\n          <div style=\"font-size: 14px;\">Team ${data.teamId} - ${data.groupId}</div>\n          <div style=\"font-size: 14px;\">Bonus: +$${data.bonus.toLocaleString()} (${data.multiplier}x)</div>\n        </div>\n      </div>\n    `;\n\n    document.body.appendChild(notification);\n\n    // Remove after 5 seconds\n    setTimeout(() => {\n      notification.style.animation = 'fadeOut 0.3s ease-out forwards';\n      setTimeout(() => notification.remove(), 300);\n    }, 5000);\n  }\n\n  /**\n   * Show token scan result\n   * @param {Object} token - Token data\n   * @param {string} tokenId - Token ID\n   * @param {boolean} isUnknown - Whether token is unknown\n   */\n  showTokenResult(token, tokenId, isUnknown) {\n    const dataSource = this.dataManager;\n    if (!dataSource || !this.settings) return;\n\n    const statusEl = document.getElementById('resultStatus');\n    const rfidEl = document.getElementById('resultRfid');\n    const typeEl = document.getElementById('resultType');\n    const groupEl = document.getElementById('resultGroup');\n    const valueEl = document.getElementById('resultValue');\n    const summaryContainer = document.getElementById('resultSummaryContainer');\n    const summaryEl = document.getElementById('resultSummary');\n\n    if (!statusEl || !rfidEl || !typeEl || !groupEl || !valueEl) return;\n\n    if (isUnknown) {\n      statusEl.className = 'status-message error';\n      statusEl.innerHTML = `\n        <h2>Unknown Token</h2>\n        <p style=\"font-size: 14px;\">Not in database</p>\n      `;\n      rfidEl.textContent = tokenId;\n      typeEl.textContent = 'UNKNOWN';\n      typeEl.style.color = '#FF5722';\n      groupEl.textContent = `Raw ID: ${tokenId}`;\n\n      if (this.settings.mode === 'blackmarket') {\n        valueEl.textContent = '$0';\n      } else {\n        valueEl.textContent = 'No Value';\n      }\n\n      // Hide summary for unknown tokens\n      if (summaryContainer) {\n        summaryContainer.style.display = 'none';\n      }\n    } else {\n      statusEl.className = 'status-message success';\n      statusEl.innerHTML = '<h2>Transaction Complete!</h2>';\n      rfidEl.textContent = tokenId;\n      typeEl.textContent = token.SF_MemoryType;\n      typeEl.style.color = '#333';\n      groupEl.textContent = token.SF_Group;\n\n      if (this.settings.mode === 'blackmarket') {\n        const tokenScore = dataSource.calculateTokenValue({\n          valueRating: token.SF_ValueRating,\n          memoryType: token.SF_MemoryType,\n          isUnknown: false\n        });\n        valueEl.textContent = `$${tokenScore.toLocaleString()}`;\n      } else {\n        valueEl.textContent = '‚≠ê'.repeat(token.SF_ValueRating || 0);\n      }\n\n      // Show summary if available (all modes - gives GM visibility on token content)\n      if (token.summary && summaryContainer && summaryEl) {\n        summaryContainer.style.display = 'flex';\n        summaryEl.textContent = token.summary;\n      } else if (summaryContainer) {\n        summaryContainer.style.display = 'none';\n      }\n    }\n\n    this.showScreen('result');\n    // Quick-dismiss is now handled by showScreen('result') -> _enableResultScreenQuickDismiss()\n  }\n\n  /**\n   * Escape HTML to prevent XSS\n   * @param {string} text - Text to escape\n   * @returns {string} Escaped text\n   */\n  escapeHtml(text) {\n    if (!text) return '';\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n\n  /**\n   * Format timestamp to time string (HH:MM)\n   * @param {string} timestamp - ISO timestamp\n   * @returns {string} Formatted time\n   */\n  _formatTime(timestamp) {\n    if (!timestamp) return '';\n    const date = new Date(timestamp);\n    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\n  }\n\n  /**\n   * Unified game activity renderer - used by BOTH admin panel AND historyScreen\n   * @param {HTMLElement} container - Target container\n   * @param {Object} options - Rendering options\n   * @param {boolean} options.showSummary - Show stats bar (default: true)\n   * @param {boolean} options.showFilters - Show search/filter controls (default: true)\n   * @param {string} options.defaultFilter - 'all' | 'available' | 'claimed'\n   */\n  renderGameActivity(container, options = {}) {\n    if (!container) return;\n\n    const { showSummary = true, showFilters = true } = options;\n    const dataSource = this.dataManager;\n    if (!dataSource) return;\n\n    // UnifiedDataManager delegates to strategy - both modes support this now\n    // Defensive check in case dataManager doesn't have the method\n    if (typeof dataSource.getGameActivity !== 'function') {\n      container.innerHTML = `\n        <div class=\"empty-state\">\n          <h3>Game Activity</h3>\n          <p>No activity data available</p>\n        </div>\n      `;\n      return;\n    }\n\n    const { tokens, stats } = dataSource.getGameActivity();\n\n    let html = '';\n\n    // Summary bar - includes GM-only claims for observability\n    if (showSummary) {\n      html += `\n        <div class=\"activity-summary\">\n          <span class=\"stat\">${stats.totalTokens} tokens</span>\n          <span class=\"stat available\">${stats.available} available</span>\n          <span class=\"stat claimed\">${stats.claimed} claimed</span>\n          ${stats.claimedWithoutDiscovery > 0 ? `\n            <span class=\"stat warning\" title=\"Tokens claimed by GM without player discovery\">\n              ${stats.claimedWithoutDiscovery} GM-only\n            </span>\n          ` : ''}\n        </div>\n      `;\n    }\n\n    // Filter controls\n    if (showFilters) {\n      html += `\n        <div class=\"activity-filters\">\n          <input type=\"text\" id=\"activitySearch\" placeholder=\"Search tokens...\" class=\"search-input\">\n          <select id=\"activityFilter\" class=\"filter-select\">\n            <option value=\"all\">All Tokens</option>\n            <option value=\"available\">Available Only</option>\n            <option value=\"claimed\">Claimed Only</option>\n          </select>\n        </div>\n      `;\n    }\n\n    // Token cards - sorted by MOST RECENT activity (not just discovery)\n    html += '<div class=\"activity-grid\">';\n\n    if (tokens.length === 0) {\n      html += '<div class=\"empty-state\">No token activity yet</div>';\n    } else {\n      // Sort by most recent event per token (last event timestamp)\n      const getLatestTimestamp = (token) => {\n        if (!token.events || !token.events.length) return 0;\n        return new Date(token.events[token.events.length - 1].timestamp);\n      };\n\n      tokens\n        .sort((a, b) => getLatestTimestamp(b) - getLatestTimestamp(a))\n        .forEach(token => {\n          html += this._renderActivityTokenCard(token);\n        });\n    }\n\n    html += '</div>';\n    container.innerHTML = html;\n\n    // Attach filter handlers\n    this._attachActivityFilterHandlers(container);\n  }\n\n  /**\n   * Render a single token card for game activity\n   * @param {Object} token - Token activity data\n   * @returns {string} HTML string\n   */\n  _renderActivityTokenCard(token) {\n    const { tokenId, tokenData, events, status, discoveredByPlayers, potentialValue } = token;\n    const memoryType = tokenData?.SF_MemoryType || 'Unknown';\n    const rating = tokenData?.SF_ValueRating || 0;\n\n    // Count scan events for collapse logic\n    const scanEvents = events.filter(e => e.type === 'scan');\n    const hasMultipleScans = scanEvents.length > 0;\n    const claimEvent = events.find(e => e.type === 'claim');\n\n    // Generate status bar content based on state\n    let statusContent;\n    if (status === 'claimed' && claimEvent?.mode === 'blackmarket') {\n      // Black Market: Show earned value\n      statusContent = `<span class=\"status-icon\">üí∞</span> SOLD to ${this.escapeHtml(claimEvent?.teamId || 'Unknown')}\n        <span class=\"points\">$${(claimEvent?.points || 0).toLocaleString()}</span>`;\n    } else if (status === 'claimed' && claimEvent?.mode === 'detective') {\n      // Detective: Show what they gave up\n      statusContent = `<span class=\"status-icon\">üîç</span> EXPOSED by ${this.escapeHtml(claimEvent?.teamId || 'Unknown')}\n        <span class=\"points potential\">Worth: $${(potentialValue || 0).toLocaleString()}</span>`;\n    } else {\n      // Available: Show potential value\n      statusContent = `‚óã AVAILABLE\n        <span class=\"points potential\">Worth: $${(potentialValue || 0).toLocaleString()}</span>`;\n    }\n\n    return `\n      <div class=\"token-card ${status}\" data-token-id=\"${tokenId}\">\n        <!-- Header: Token ID + Type + Rating -->\n        <div class=\"token-card__header\">\n          <span class=\"token-id\">${this.escapeHtml(tokenId)}</span>\n          <span class=\"token-type type-${memoryType.toLowerCase()}\">${memoryType}</span>\n        </div>\n        <div class=\"token-card__rating\">${'‚òÖ'.repeat(rating)}${'‚òÜ'.repeat(5-rating)}</div>\n\n        <!-- Status Bar: Quick-glance current state with mode-specific styling -->\n        <div class=\"token-card__status status-${status} ${claimEvent?.mode || ''}\">\n          ${statusContent}\n        </div>\n\n        ${tokenData?.summary ? `\n          <div class=\"token-card__summary\">\n            <button class=\"summary-toggle\" onclick=\"this.parentElement.classList.toggle('expanded')\">Intel</button>\n            <div class=\"summary-content\">${this.escapeHtml(tokenData.summary)}</div>\n          </div>\n        ` : ''}\n\n        <!-- Timeline: Full event history (expandable) -->\n        <div class=\"token-card__timeline ${hasMultipleScans ? 'expandable' : ''}\"\n             data-expanded=\"false\">\n\n          ${!discoveredByPlayers && status === 'claimed' ? `\n            <div class=\"event warning\">\n              <span class=\"icon\">‚ö†Ô∏è</span>\n              <span class=\"label\">Not discovered by players</span>\n            </div>\n          ` : ''}\n\n          ${events.map((event, idx) => this._renderTimelineEvent(event, idx, events.length)).join('')}\n\n          ${status === 'available' ? `\n            <div class=\"event status-available\">\n              <span class=\"status-badge\">AWAITING CLAIM</span>\n            </div>\n          ` : ''}\n        </div>\n\n        ${hasMultipleScans ? `\n          <button class=\"timeline-toggle\" onclick=\"this.parentElement.querySelector('.token-card__timeline').dataset.expanded =\n            this.parentElement.querySelector('.token-card__timeline').dataset.expanded === 'true' ? 'false' : 'true'\">\n            <span class=\"expand-text\">Show ${scanEvents.length} more scans</span>\n            <span class=\"collapse-text\">Collapse</span>\n          </button>\n        ` : ''}\n      </div>\n    `;\n  }\n\n  /**\n   * Render a single timeline event\n   * @param {Object} event - Event data\n   * @param {number} index - Event index\n   * @param {number} totalEvents - Total events count\n   * @returns {string} HTML string\n   */\n  _renderTimelineEvent(event, index, totalEvents) {\n    const time = this._formatTime(event.timestamp);\n\n    switch (event.type) {\n      case 'discovery':\n        return `\n          <div class=\"event discovery\">\n            <span class=\"icon\">üëÅ</span>\n            <span class=\"label\">Discovered</span>\n            <span class=\"device\">${this.escapeHtml(event.deviceId)}</span>\n            <span class=\"time\">${time}</span>\n          </div>\n        `;\n\n      case 'scan':\n        // Additional scans - collapsible by default\n        return `\n          <div class=\"event scan collapsible\">\n            <span class=\"icon\">üëÅ</span>\n            <span class=\"label\">Scanned</span>\n            <span class=\"device\">${this.escapeHtml(event.deviceId)}</span>\n            <span class=\"time\">${time}</span>\n          </div>\n        `;\n\n      case 'claim':\n        return `\n          <div class=\"event claim ${event.mode}\">\n            <span class=\"icon\">${event.mode === 'blackmarket' ? 'üí∞' : 'üîç'}</span>\n            <span class=\"label\">${event.mode === 'blackmarket' ? 'Black Market' : 'Detective'}</span>\n            <span class=\"team\">${this.escapeHtml(event.teamId)}</span>\n            <span class=\"time\">${time}</span>\n            <span class=\"points\">$${(event.points || 0).toLocaleString()}</span>\n            ${event.groupProgress ? `\n              <div class=\"group-progress\">\n                ${this.escapeHtml(event.groupProgress.name)} (${event.groupProgress.found}/${event.groupProgress.total})\n              </div>\n            ` : ''}\n            ${event.summary ? `\n              <div class=\"exposed-summary\">\n                <span class=\"summary-label\">Intel:</span>\n                <span class=\"summary-text\">${this.escapeHtml(event.summary)}</span>\n              </div>\n            ` : ''}\n          </div>\n        `;\n\n      default:\n        return '';\n    }\n  }\n\n  /**\n   * Attach filter handlers for game activity\n   * @param {HTMLElement} container - Container element\n   */\n  _attachActivityFilterHandlers(container) {\n    const searchInput = container.querySelector('#activitySearch');\n    const filterSelect = container.querySelector('#activityFilter');\n\n    if (searchInput) {\n      searchInput.addEventListener('input', () => this._filterGameActivity(container));\n    }\n    if (filterSelect) {\n      filterSelect.addEventListener('change', () => this._filterGameActivity(container));\n    }\n  }\n\n  /**\n   * Filter game activity based on search and filter\n   * @param {HTMLElement} container - Container element\n   */\n  _filterGameActivity(container) {\n    const searchInput = container.querySelector('#activitySearch');\n    const filterSelect = container.querySelector('#activityFilter');\n    const cards = container.querySelectorAll('.token-card');\n\n    const searchTerm = searchInput?.value?.toLowerCase() || '';\n    const filterValue = filterSelect?.value || 'all';\n\n    cards.forEach(card => {\n      const tokenId = card.dataset.tokenId?.toLowerCase() || '';\n      const status = card.classList.contains('claimed') ? 'claimed' : 'available';\n\n      const matchesSearch = !searchTerm || tokenId.includes(searchTerm);\n      const matchesFilter = filterValue === 'all' || status === filterValue;\n\n      card.style.display = matchesSearch && matchesFilter ? 'block' : 'none';\n    });\n  }\n}\n\n// Export class (not pre-created instance)\n// Instance created in main.js with proper dependency injection\nexport default UIManager;\nexport { UIManager };\n","/**\n * Settings Manager\n * Manages station configuration (device ID and mode)\n * ES6 Module - Event-Driven Architecture\n *\n * Emits events:\n * - 'settings:loaded' - After loading from localStorage\n * - 'settings:saved' - After saving to localStorage\n * - 'settings:changed' - When any setting value changes\n */\n\nclass Settings extends EventTarget {\n  /**\n   * Create Settings instance\n   * Pure event-driven - no dependencies on UIManager\n   */\n  constructor() {\n    super();\n    this.deviceId = '001';\n    this.mode = 'detective';\n  }\n\n  /**\n   * Load settings from localStorage\n   * Updates DOM and emits 'settings:loaded' event\n   */\n  load() {\n    // Load from localStorage\n    this.deviceId = localStorage.getItem('deviceId') || '001';\n    this.mode = localStorage.getItem('mode') || 'detective';\n\n    // Update DOM elements if they exist\n    const deviceIdInput = document.getElementById('deviceId');\n    const deviceIdDisplay = document.getElementById('deviceIdDisplay');\n    const modeToggle = document.getElementById('modeToggle');\n\n    if (deviceIdInput) {\n      deviceIdInput.value = this.deviceId;\n    }\n    if (deviceIdDisplay) {\n      deviceIdDisplay.textContent = this.deviceId;\n    }\n    if (modeToggle) {\n      modeToggle.checked = this.mode === 'blackmarket';\n    }\n\n    // Emit event for listeners (UIManager, App.js, etc.)\n    this.dispatchEvent(new CustomEvent('settings:loaded', {\n      detail: {\n        deviceId: this.deviceId,\n        mode: this.mode\n      }\n    }));\n  }\n\n  /**\n   * Save settings to localStorage\n   * Reads from DOM if settings screen is active\n   * Emits 'settings:saved' and 'settings:changed' events\n   */\n  save() {\n    const settingsScreen = document.getElementById('settingsScreen');\n\n    const oldDeviceId = this.deviceId;\n    const oldMode = this.mode;\n\n    // Only read from DOM if settings screen is active\n    if (settingsScreen && settingsScreen.classList.contains('active')) {\n      const deviceIdInput = document.getElementById('deviceId');\n      const modeToggle = document.getElementById('modeToggle');\n\n      if (deviceIdInput) {\n        this.deviceId = deviceIdInput.value || '001';\n      }\n      if (modeToggle) {\n        this.mode = modeToggle.checked ? 'blackmarket' : 'detective';\n      }\n    }\n\n    // Save to localStorage\n    localStorage.setItem('deviceId', this.deviceId);\n    localStorage.setItem('mode', this.mode);\n\n    // Update display\n    const deviceIdDisplay = document.getElementById('deviceIdDisplay');\n    if (deviceIdDisplay) {\n      deviceIdDisplay.textContent = this.deviceId;\n    }\n\n    // Emit settings:saved event\n    this.dispatchEvent(new CustomEvent('settings:saved', {\n      detail: {\n        deviceId: this.deviceId,\n        mode: this.mode\n      }\n    }));\n\n    // Emit settings:changed if values actually changed\n    if (oldDeviceId !== this.deviceId || oldMode !== this.mode) {\n      this.dispatchEvent(new CustomEvent('settings:changed', {\n        detail: {\n          deviceId: this.deviceId,\n          mode: this.mode,\n          oldDeviceId,\n          oldMode\n        }\n      }));\n    }\n  }\n}\n\n// Create singleton instance\nconst settings = new Settings();\n\nexport default settings;\nexport { Settings };\n","/**\n * Token Manager - Token Database and Group Inventory\n * ES6 Module Export\n *\n * Responsibilities:\n * - Load token database from external JSON\n * - Fuzzy token ID matching (case-insensitive, with/without colons)\n * - Build group inventory for bonus calculations\n * - Demo data fallback\n */\n\nimport Debug from '../utils/debug.js';\n\n/**\n * TokenManager Class\n * Manages token database and provides lookup functionality\n */\nclass TokenManagerClass {\n  constructor() {\n    this.database = {};\n    this.groupInventory = null;\n    this._dataManagerHelpers = null; // Injected dependency\n  }\n\n  /**\n   * Inject DataManager helper methods (dependency injection)\n   * @param {Object} helpers - Object with parseGroupInfo and normalizeGroupName methods\n   */\n  setDataManagerHelpers(helpers) {\n    this._dataManagerHelpers = helpers;\n  }\n\n  /**\n   * Load token database from external JSON file\n   * @returns {Promise<boolean>} Success status\n   */\n  async loadDatabase() {\n    try {\n      // Try loading from submodule path first\n      let response = await fetch('data/tokens.json');\n      if (!response.ok) {\n        Debug.log('Trying root directory for tokens.json');\n        // Fallback to root directory for backward compatibility\n        response = await fetch('tokens.json');\n        if (!response.ok) {\n          throw new Error('Failed to load tokens.json from data/ or root');\n        }\n      }\n      this.database = await response.json();\n      Debug.log(`‚úÖ Loaded ${Object.keys(this.database).length} tokens from ${response.url}`);\n      Debug.log(`Sample keys: ${Object.keys(this.database).slice(0, 3).join(', ')}`);\n\n      // Build group inventory for bonus calculations\n      this.groupInventory = this.buildGroupInventory();\n      this.logGroupStats();\n\n      return true;\n    } catch (error) {\n      Debug.log(`Token database error: ${error.message}`, true);\n      // CRITICAL: Fail hard if database cannot be loaded.\n      // Do NOT load demo data.\n      return false;\n    }\n  }\n\n  /**\n   * Build inventory of all groups and their tokens\n   * @returns {Object} Group inventory map\n   */\n  buildGroupInventory() {\n    const groups = {};\n    const issues = [];\n\n    Object.entries(this.database).forEach(([rfid, token]) => {\n      // Use injected helpers or fallback to inline parsing\n      const groupInfo = this._dataManagerHelpers\n        ? this._dataManagerHelpers.parseGroupInfo(token.SF_Group)\n        : this._parseGroupInfoFallback(token.SF_Group);\n\n      const normalizedName = this._dataManagerHelpers\n        ? this._dataManagerHelpers.normalizeGroupName(groupInfo.name)\n        : this._normalizeGroupNameFallback(groupInfo.name);\n\n      if (!groups[normalizedName]) {\n        groups[normalizedName] = {\n          displayName: groupInfo.name,\n          normalizedName: normalizedName,\n          multiplier: groupInfo.multiplier,\n          tokens: new Set(),\n          rawGroupNames: new Set(),\n          memoryTypes: new Set()\n        };\n      }\n\n      // Add token to group\n      groups[normalizedName].tokens.add(rfid);\n      groups[normalizedName].rawGroupNames.add(token.SF_Group);\n      groups[normalizedName].memoryTypes.add(token.SF_MemoryType);\n\n      // Check for multiplier consistency\n      if (groups[normalizedName].multiplier !== groupInfo.multiplier) {\n        issues.push(`Group \"${groupInfo.name}\" has inconsistent multipliers`);\n        // Keep the higher multiplier\n        groups[normalizedName].multiplier = Math.max(\n          groups[normalizedName].multiplier,\n          groupInfo.multiplier\n        );\n      }\n\n      // Update display name if this one is \"better\"\n      if (groupInfo.name.length > groups[normalizedName].displayName.length ||\n        (groupInfo.name.length === groups[normalizedName].displayName.length &&\n          groupInfo.name > groups[normalizedName].displayName)) {\n        groups[normalizedName].displayName = groupInfo.name;\n      }\n    });\n\n    // Log any issues found\n    if (issues.length > 0) {\n      Debug.log('=== Group Inventory Issues ===', true);\n      issues.forEach(issue => Debug.log(issue, true));\n    }\n\n    return groups;\n  }\n\n  /**\n   * Fallback group info parser (until DataManager is converted)\n   * Format: \"Group Name (xN)\" where N is multiplier\n   */\n  _parseGroupInfoFallback(groupString) {\n    if (!groupString) {\n      return { name: '', multiplier: 1 };\n    }\n\n    const match = groupString.match(/^(.+?)\\s*\\(x(\\d+)\\)$/i);\n    if (match) {\n      return {\n        name: match[1].trim(),\n        multiplier: parseInt(match[2], 10)\n      };\n    }\n\n    return { name: groupString.trim(), multiplier: 1 };\n  }\n\n  /**\n   * Fallback group name normalizer (until DataManager is converted)\n   * Lowercase, trim, remove extra whitespace\n   */\n  _normalizeGroupNameFallback(name) {\n    return name.toLowerCase().trim().replace(/\\s+/g, ' ');\n  }\n\n  /**\n   * Log group statistics for debugging\n   */\n  logGroupStats() {\n    if (!this.groupInventory) return;\n\n    Debug.log('=== Group Inventory Summary ===');\n    const groups = Object.values(this.groupInventory);\n\n    Debug.log(`Total Groups: ${groups.length}`);\n\n    const completableGroups = groups.filter(g => g.multiplier > 1 && g.tokens.size > 1);\n    const singleTokenGroups = groups.filter(g => g.tokens.size === 1);\n\n    Debug.log(`Completable Groups: ${completableGroups.length}`);\n    Debug.log(`Single Token Groups: ${singleTokenGroups.length}`);\n\n    // Log details for each group\n    groups.sort((a, b) => b.tokens.size - a.tokens.size).forEach(group => {\n      Debug.log(`\"${group.displayName}\": ${group.tokens.size} tokens, ${group.multiplier}x`);\n\n      if (group.tokens.size === 1 && group.multiplier > 1) {\n        Debug.log(`  ‚ö†Ô∏è Only 1 token but ${group.multiplier}x multiplier`, true);\n      }\n    });\n  }\n\n  /**\n   * Get group inventory with caching\n   * @returns {Object} Group inventory\n   */\n  getGroupInventory() {\n    if (!this.groupInventory) {\n      this.groupInventory = this.buildGroupInventory();\n    }\n    return this.groupInventory;\n  }\n\n  /**\n   * Get all tokens from database\n   * @returns {Array} Array of all token objects\n   */\n  getAllTokens() {\n    return Object.values(this.database);\n  }\n\n  /**\n   * Find token in database with fuzzy matching\n   * Handles: case variations, with/without colons, with/without hyphens\n   * @param {string} id - Token ID to find\n   * @returns {Object|null} Token data and matched ID, or null if not found\n   */\n  findToken(id) {\n    Debug.log(`üîç findToken called with: \"${id}\"`);\n    Debug.log(`Database has ${Object.keys(this.database).length} tokens`);\n    Debug.log(`First 5 keys: ${Object.keys(this.database).slice(0, 5).join(', ')}`);\n\n    // Direct match\n    if (this.database[id]) {\n      Debug.log(`‚úÖ Direct match: ${id}`);\n      return { token: this.database[id], matchedId: id };\n    }\n\n    // Normalize input: remove colons/hyphens, lowercase\n    const normalizedInput = id.replace(/[:-]/g, '').toLowerCase();\n\n    // Try matching against normalized database keys\n    for (const [dbKey, token] of Object.entries(this.database)) {\n      const normalizedDbKey = dbKey.replace(/[:-]/g, '').toLowerCase();\n\n      if (normalizedInput === normalizedDbKey) {\n        Debug.log(`‚úÖ Fuzzy match: \"${id}\" -> \"${dbKey}\"`);\n        return { token, matchedId: dbKey };\n      }\n    }\n\n    Debug.log(`No match found for: ${id}`, true);\n    return null;\n  }\n}\n\n// Create singleton instance\nconst TokenManager = new TokenManagerClass();\n\nexport default TokenManager;\nexport { TokenManagerClass };\n","/**\n * IStorageStrategy - Interface for data storage strategies\n * Implemented by NetworkedStorage and LocalStorage\n *\n * @interface IStorageStrategy\n */\n\n/**\n * @typedef {Object} Transaction\n * @property {string} id - Unique transaction ID\n * @property {string} tokenId - Token identifier (from NFC/manual entry)\n * @property {string} teamId - Team identifier\n * @property {string} mode - Transaction mode ('blackmarket' | 'detective')\n * @property {number} [points] - Score value (blackmarket mode only)\n * @property {number} [valueRating] - Token star rating (1-5)\n * @property {string} [memoryType] - Token type ('Personal' | 'Business' | 'Technical')\n * @property {string} [group] - Group name with multiplier, e.g., \"Server Logs (x5)\"\n * @property {boolean} [isUnknown] - True if token not found in database\n * @property {string} timestamp - ISO timestamp of transaction\n */\n\n/**\n * @typedef {Object} TransactionResult\n * @property {boolean} success - Whether operation succeeded\n * @property {boolean} [pending] - True if operation is pending backend confirmation (NetworkedStorage)\n * @property {Transaction} [transaction] - The processed transaction\n * @property {Object} [teamScore] - Updated team score\n * @property {number} [teamScore.score] - Current total score\n * @property {number} [teamScore.baseScore] - Score from tokens only\n * @property {number} [teamScore.bonusPoints] - Score from group completions\n * @property {number} [teamScore.tokensScanned] - Number of tokens scanned\n * @property {Object} [groupBonusInfo] - Group completion info if applicable\n * @property {string} [groupBonusInfo.groupName] - Name of completed group\n * @property {number} [groupBonusInfo.bonus] - Bonus points awarded\n * @property {string} [error] - Error message if failed\n */\n\n/**\n * @typedef {Object} SessionInfo\n * @property {string} sessionId - Session identifier\n * @property {string} [name] - Session name\n * @property {string} startTime - ISO timestamp\n * @property {string} [status] - Session status ('active' | 'paused' | 'ended')\n */\n\n/**\n * Storage strategy interface - defines contract for data persistence\n *\n * Implementations:\n * - NetworkedStorage: WebSocket communication with backend\n * - LocalStorage: Browser localStorage persistence\n *\n * Extends EventTarget to allow strategies to emit events that can be\n * forwarded by UnifiedDataManager to consumers.\n */\nexport class IStorageStrategy extends EventTarget {\n  constructor() {\n    super();\n  }\n  /**\n   * Initialize the storage strategy\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    throw new Error('IStorageStrategy.initialize() must be implemented');\n  }\n\n  /**\n   * Add a transaction\n   * @param {Transaction} transaction - Transaction data\n   * @returns {Promise<TransactionResult>}\n   */\n  async addTransaction(transaction) {\n    throw new Error('IStorageStrategy.addTransaction() must be implemented');\n  }\n\n  /**\n   * Remove a transaction\n   * @param {string} transactionId - Transaction ID to remove\n   * @returns {Promise<TransactionResult>}\n   */\n  async removeTransaction(transactionId) {\n    throw new Error('IStorageStrategy.removeTransaction() must be implemented');\n  }\n\n  /**\n   * Get all transactions\n   * @returns {Array} Array of transactions\n   */\n  getTransactions() {\n    throw new Error('IStorageStrategy.getTransactions() must be implemented');\n  }\n\n  /**\n   * Get team scores\n   * @returns {Array} Array of team score objects\n   */\n  getTeamScores() {\n    throw new Error('IStorageStrategy.getTeamScores() must be implemented');\n  }\n\n  /**\n   * Adjust team score (admin operation)\n   * @param {string} teamId - Team identifier\n   * @param {number} delta - Score adjustment amount\n   * @param {string} reason - Reason for adjustment\n   * @returns {Promise<TransactionResult>}\n   */\n  async adjustTeamScore(teamId, delta, reason) {\n    throw new Error('IStorageStrategy.adjustTeamScore() must be implemented');\n  }\n\n  /**\n   * Get game activity (player discoveries + GM transactions)\n   * @returns {Object} { tokens: Array, stats: Object }\n   */\n  getGameActivity() {\n    throw new Error('IStorageStrategy.getGameActivity() must be implemented');\n  }\n\n  /**\n   * Create a new session\n   * @param {string} name - Session name\n   * @param {Array} teams - Initial teams array\n   * @returns {Promise<SessionInfo>}\n   */\n  async createSession(name, teams) {\n    throw new Error('IStorageStrategy.createSession() must be implemented');\n  }\n\n  /**\n   * End the current session\n   * @returns {Promise<void>}\n   */\n  async endSession() {\n    throw new Error('IStorageStrategy.endSession() must be implemented');\n  }\n\n  /**\n   * Pause the current session\n   * @returns {Promise<{success: boolean, error?: string}>}\n   */\n  async pauseSession() {\n    throw new Error('IStorageStrategy.pauseSession() must be implemented');\n  }\n\n  /**\n   * Resume a paused session\n   * @returns {Promise<{success: boolean, error?: string}>}\n   */\n  async resumeSession() {\n    throw new Error('IStorageStrategy.resumeSession() must be implemented');\n  }\n\n  /**\n   * Reset all team scores to zero (keeps transactions for audit)\n   * @returns {Promise<{success: boolean}>}\n   */\n  async resetScores() {\n    throw new Error('IStorageStrategy.resetScores() must be implemented');\n  }\n\n  /**\n   * Get current session info\n   * @returns {SessionInfo|null}\n   */\n  getCurrentSession() {\n    throw new Error('IStorageStrategy.getCurrentSession() must be implemented');\n  }\n\n  /**\n   * Check if storage is ready/connected\n   * @returns {boolean}\n   */\n  isReady() {\n    throw new Error('IStorageStrategy.isReady() must be implemented');\n  }\n\n  /**\n   * Dispose of resources\n   */\n  dispose() {\n    // Optional cleanup - default no-op\n  }\n}\n","/**\n * Scoring Module - Shared Scoring Configuration and Utilities\n * ES6 Module Export\n *\n * Loads scoring configuration from shared ALN-TokenData submodule.\n * This ensures frontend and backend use identical scoring values.\n *\n * @module core/scoring\n */\n\n// Import shared config from data submodule (Vite resolves at build time)\nimport sharedConfig from '../../data/scoring-config.json';\n\n/**\n * Scoring configuration for Black Market mode\n * Maps value ratings and memory types to point values\n *\n * NOTE: Values loaded from ALN-TokenData/scoring-config.json\n */\nexport const SCORING_CONFIG = {\n    BASE_VALUES: Object.fromEntries(\n        Object.entries(sharedConfig.baseValues).map(([k, v]) => [parseInt(k), v])\n    ),\n    TYPE_MULTIPLIERS: { ...sharedConfig.typeMultipliers }\n};\n\n/**\n * Parse group info from group name string\n * Extracts group name and multiplier from format: \"Group Name (xN)\"\n *\n * @param {string} groupName - Group name with optional multiplier suffix\n * @returns {Object} Parsed group info with name and multiplier\n *\n * @example\n * parseGroupInfo(\"Marcus Sucks (x2)\")  // { name: \"Marcus Sucks\", multiplier: 2 }\n * parseGroupInfo(\"Ungrouped Token\")    // { name: \"Ungrouped Token\", multiplier: 1 }\n */\nexport function parseGroupInfo(groupName) {\n    if (!groupName) {\n        return { name: 'Unknown', multiplier: 1 };\n    }\n\n    // Trim input first to handle leading/trailing whitespace\n    const trimmed = groupName.trim();\n\n    // Match pattern: \"Group Name (xN)\"\n    const match = trimmed.match(/^(.+?)\\s*\\(x(\\d+)\\)$/i);\n\n    if (match) {\n        const name = match[1].trim();\n        const multiplier = parseInt(match[2]) || 1;\n\n        if (multiplier < 1) {\n            console.warn(`[scoring] Invalid multiplier ${multiplier} for \"${name}\", using 1`);\n            return { name, multiplier: 1 };\n        }\n\n        return { name, multiplier };\n    }\n\n    return { name: trimmed, multiplier: 1 };\n}\n\n/**\n * Normalize group name for consistent matching\n * Handles case insensitivity, whitespace normalization, and apostrophe variants\n *\n * @param {string} name - Group name to normalize\n * @returns {string} Normalized group name\n *\n * @example\n * normalizeGroupName(\"Marcus's Notes\")  // \"marcus's notes\"\n * normalizeGroupName(\"  Spaced  Out  \") // \"spaced out\"\n */\nexport function normalizeGroupName(name) {\n    if (!name) return '';\n\n    return name\n        .trim()\n        .toLowerCase()\n        .replace(/\\s+/g, ' ')\n        .replace(/['\\u2018\\u2019]/g, \"'\");  // Normalize curly apostrophes to straight\n}\n\n/**\n * Calculate base value of a token\n *\n * @param {Object} transaction - Transaction data\n * @param {number} transaction.valueRating - Star rating (1-5)\n * @param {string} transaction.memoryType - Memory type (Personal/Business/Technical)\n * @param {boolean} [transaction.isUnknown] - Whether token is unknown\n * @returns {number} Token value in points\n */\nexport function calculateTokenValue(transaction) {\n    if (transaction.isUnknown) return 0;\n\n    const baseValue = SCORING_CONFIG.BASE_VALUES[transaction.valueRating] || 0;\n    // Use UNKNOWN multiplier (0) for unknown types - matches backend behavior\n    const multiplier = SCORING_CONFIG.TYPE_MULTIPLIERS[transaction.memoryType]\n        ?? SCORING_CONFIG.TYPE_MULTIPLIERS.UNKNOWN\n        ?? 0;\n\n    return baseValue * multiplier;\n}\n","/**\n * LocalStorage Strategy - Browser localStorage persistence\n * Implements IStorageStrategy for standalone mode operation\n *\n * @module core/storage/LocalStorage\n */\n\nimport { IStorageStrategy } from './IStorageStrategy.js';\nimport {\n  SCORING_CONFIG,\n  parseGroupInfo,\n  calculateTokenValue\n} from '../scoring.js';\n\nexport class LocalStorage extends IStorageStrategy {\n  /**\n   * Create LocalStorage instance\n   * @param {Object} options - Dependencies\n   * @param {Object} options.tokenManager - TokenManager instance\n   * @param {Object} [options.debug] - Debug instance\n   */\n  constructor({ tokenManager, debug } = {}) {\n    super();\n\n    this.tokenManager = tokenManager;\n    this.debug = debug;\n    this.SCORING_CONFIG = SCORING_CONFIG;\n\n    // Initialize session data\n    this.sessionData = {\n      sessionId: this._generateSessionId(),\n      startTime: new Date().toISOString(),\n      transactions: [],\n      teams: {},\n      mode: 'standalone'\n    };\n\n    // Track scanned tokens for duplicate detection\n    this.scannedTokens = new Set();\n\n    // Player scans (for getGameActivity parity)\n    this.playerScans = [];\n  }\n\n  /**\n   * Generate unique local session ID\n   * @private\n   */\n  _generateSessionId() {\n    return `LOCAL_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;\n  }\n\n  /**\n   * Check if storage is ready\n   * @returns {boolean} Always true for localStorage\n   */\n  isReady() {\n    return true;\n  }\n\n  /**\n   * Initialize storage (load from localStorage)\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    this._loadSession();\n  }\n\n  /**\n   * Load session from localStorage\n   * @private\n   */\n  _loadSession() {\n    const saved = localStorage.getItem('standaloneSession');\n    if (saved) {\n      try {\n        const parsed = JSON.parse(saved);\n        const sessionDate = new Date(parsed.startTime).toDateString();\n        const today = new Date().toDateString();\n\n        if (sessionDate === today) {\n          this.sessionData = parsed;\n          this._repopulateScannedTokens();\n          this.debug?.log(`Loaded session: ${parsed.sessionId}`);\n        }\n      } catch (e) {\n        this.debug?.log('Failed to load session', true);\n      }\n    }\n  }\n\n  /**\n   * Repopulate scannedTokens Set from loaded transactions\n   * @private\n   */\n  _repopulateScannedTokens() {\n    this.scannedTokens.clear();\n    this.sessionData.transactions.forEach(tx => {\n      const tokenId = tx.tokenId || tx.rfid;\n      if (tokenId) {\n        this.scannedTokens.add(tokenId);\n      }\n    });\n  }\n\n  /**\n   * Save session to localStorage\n   * @private\n   */\n  _saveSession() {\n    localStorage.setItem('standaloneSession', JSON.stringify(this.sessionData));\n  }\n\n  /**\n   * Get all transactions\n   * @returns {Array} Array of transactions\n   */\n  getTransactions() {\n    return this.sessionData.transactions;\n  }\n\n  /**\n   * Get team scores\n   * @returns {Array} Array of team score objects\n   */\n  getTeamScores() {\n    return Object.values(this.sessionData.teams)\n      .map(team => ({\n        teamId: team.teamId,\n        score: team.score,\n        baseScore: team.baseScore,\n        bonusScore: team.bonusPoints,\n        tokenCount: team.tokensScanned,\n        completedGroups: team.completedGroups?.length || 0,\n        isFromBackend: false\n      }))\n      .sort((a, b) => b.score - a.score);\n  }\n\n  /**\n   * Get current session info\n   * @returns {SessionInfo}\n   */\n  getCurrentSession() {\n    return {\n      sessionId: this.sessionData.sessionId,\n      name: this.sessionData.name,\n      startTime: this.sessionData.startTime,\n      status: this.sessionData.status || 'active'\n    };\n  }\n\n  /**\n   * Create a new session\n   * @param {string} name - Session name\n   * @param {Array} teams - Initial teams array\n   * @returns {Promise<SessionInfo>}\n   */\n  async createSession(name, teams) {\n    this.sessionData = {\n      sessionId: this._generateSessionId(),\n      name: name,\n      status: 'active',\n      startTime: new Date().toISOString(),\n      transactions: [],\n      teams: {},\n      mode: 'standalone'\n    };\n    this.scannedTokens.clear();\n    this._saveSession();\n\n    return this.getCurrentSession();\n  }\n\n  /**\n   * End the current session\n   * @returns {Promise<void>}\n   */\n  async endSession() {\n    this._saveSession();\n  }\n\n  /**\n   * Pause the current session\n   * Blocks scanning while paused\n   * @returns {Promise<{success: boolean, error?: string}>}\n   */\n  async pauseSession() {\n    // Check for explicit session with status (created via createSession)\n    if (!this.sessionData?.sessionId || !this.sessionData?.status) {\n      return { success: false, error: 'No active session to pause' };\n    }\n\n    if (this.sessionData.status === 'paused') {\n      return { success: false, error: 'Session already paused' };\n    }\n\n    this.sessionData.status = 'paused';\n    this.sessionData.pausedAt = new Date().toISOString();\n    this._saveSession();\n\n    // Emit event for UI updates\n    this.dispatchEvent(new CustomEvent('session:updated', {\n      detail: { session: this.getCurrentSession() }\n    }));\n\n    return { success: true };\n  }\n\n  /**\n   * Resume a paused session\n   * @returns {Promise<{success: boolean, error?: string}>}\n   */\n  async resumeSession() {\n    // Check for explicit session with status (created via createSession)\n    if (!this.sessionData?.sessionId || !this.sessionData?.status) {\n      return { success: false, error: 'No session to resume' };\n    }\n\n    if (this.sessionData.status !== 'paused') {\n      return { success: false, error: 'Session is not paused' };\n    }\n\n    this.sessionData.status = 'active';\n    delete this.sessionData.pausedAt;\n    this._saveSession();\n\n    // Emit event for UI updates\n    this.dispatchEvent(new CustomEvent('session:updated', {\n      detail: { session: this.getCurrentSession() }\n    }));\n\n    return { success: true };\n  }\n\n  /**\n   * Reset all team scores to zero\n   * Keeps transactions for audit trail\n   * @returns {Promise<{success: boolean}>}\n   */\n  async resetScores() {\n    // Zero all team scores\n    Object.keys(this.sessionData.teams).forEach(teamId => {\n      const team = this.sessionData.teams[teamId];\n      team.score = 0;\n      team.baseScore = 0;\n      team.bonusPoints = 0;\n      team.adminAdjustments = [];\n    });\n\n    this._saveSession();\n\n    // Emit event for UI updates\n    this.dispatchEvent(new CustomEvent('scores:cleared', {\n      detail: {}\n    }));\n\n    return { success: true };\n  }\n\n  /**\n   * Add transaction to local storage\n   * @param {Transaction} transaction - Transaction data\n   * @returns {Promise<TransactionResult>}\n   */\n  async addTransaction(transaction) {\n    // Check if session is paused\n    if (this.sessionData?.status === 'paused') {\n      return {\n        success: false,\n        error: 'Cannot add transaction: session is paused'\n      };\n    }\n\n    // Validate required fields\n    if (!transaction || !transaction.teamId) {\n      return {\n        success: false,\n        error: 'Transaction must have teamId'\n      };\n    }\n\n    // Add to transactions array\n    this.sessionData.transactions.push(transaction);\n\n    // Mark token as scanned\n    const tokenId = transaction.tokenId || transaction.rfid;\n    if (tokenId) {\n      this.scannedTokens.add(tokenId);\n    }\n\n    // Update team scores\n    this._updateTeamScore(transaction);\n\n    // Persist\n    this._saveSession();\n\n    return {\n      success: true,\n      transaction,\n      teamScore: this.sessionData.teams[transaction.teamId]\n    };\n  }\n\n  /**\n   * Update team score from transaction\n   * @private\n   */\n  _updateTeamScore(transaction) {\n    const teamId = transaction.teamId;\n\n    if (!this.sessionData.teams[teamId]) {\n      this.sessionData.teams[teamId] = {\n        teamId,\n        score: 0,\n        baseScore: 0,\n        bonusPoints: 0,\n        tokensScanned: 0,\n        completedGroups: [],\n        lastScanTime: null\n      };\n    }\n\n    const team = this.sessionData.teams[teamId];\n\n    // Only score blackmarket mode\n    if (transaction.mode === 'blackmarket' && transaction.points) {\n      team.baseScore += transaction.points;\n      team.score = team.baseScore + team.bonusPoints;\n    }\n\n    team.tokensScanned++;\n    team.lastScanTime = transaction.timestamp;\n\n    // Check group completion\n    if (transaction.mode === 'blackmarket' && transaction.group) {\n      this._checkGroupCompletion(teamId, transaction.group);\n    }\n  }\n\n  /**\n   * Check and award group completion bonus\n   * @private\n   */\n  _checkGroupCompletion(teamId, groupName) {\n    const groupInfo = parseGroupInfo(groupName);\n    if (groupInfo.multiplier <= 1) return;\n\n    const team = this.sessionData.teams[teamId];\n    if (team.completedGroups.includes(groupInfo.name)) return;\n\n    // Get all team transactions for this group\n    const teamTxs = this.sessionData.transactions.filter(tx =>\n      tx.teamId === teamId && tx.mode === 'blackmarket'\n    );\n\n    const groupTxs = teamTxs.filter(tx => {\n      const txGroupInfo = parseGroupInfo(tx.group);\n      return txGroupInfo.name === groupInfo.name;\n    });\n\n    // Check if all group tokens collected (requires tokenManager)\n    if (!this.tokenManager) return;\n\n    const allTokens = this.tokenManager.getAllTokens();\n    const groupTokens = allTokens.filter(token => {\n      if (!token.SF_Group) return false;\n      const tokenGroupInfo = parseGroupInfo(token.SF_Group);\n      return tokenGroupInfo.name === groupInfo.name;\n    });\n\n    const scannedIds = groupTxs.map(tx => tx.tokenId);\n    const allGroupIds = groupTokens.map(t => t.SF_RFID);\n    const allScanned = allGroupIds.every(id => scannedIds.includes(id));\n\n    if (allScanned && groupTokens.length > 0) {\n      const groupBaseScore = groupTxs.reduce((sum, tx) => sum + (tx.points || 0), 0);\n      const bonus = (groupInfo.multiplier - 1) * groupBaseScore;\n\n      team.bonusPoints += bonus;\n      team.score = team.baseScore + team.bonusPoints;\n      team.completedGroups.push(groupInfo.name);\n\n      this.debug?.log(`Group completed: ${groupInfo.name}, bonus: ${bonus}`);\n    }\n  }\n\n  /**\n   * Remove transaction and recalculate team scores\n   * @param {string} transactionId - Transaction ID\n   * @returns {Promise<TransactionResult>}\n   */\n  async removeTransaction(transactionId) {\n    const index = this.sessionData.transactions.findIndex(tx => tx.id === transactionId);\n\n    if (index === -1) {\n      return {\n        success: false,\n        error: `Transaction not found: ${transactionId}`\n      };\n    }\n\n    const removedTx = this.sessionData.transactions.splice(index, 1)[0];\n    const tokenId = removedTx.tokenId || removedTx.rfid;\n    const teamId = removedTx.teamId;\n\n    // Allow re-scanning if no other transactions have this token\n    const tokenStillExists = this.sessionData.transactions.some(\n      tx => (tx.tokenId || tx.rfid) === tokenId\n    );\n    if (!tokenStillExists && tokenId) {\n      this.scannedTokens.delete(tokenId);\n    }\n\n    // Recalculate team scores from scratch\n    if (teamId && this.sessionData.teams[teamId]) {\n      this._recalculateTeamScores(teamId);\n    }\n\n    this._saveSession();\n\n    return {\n      success: true,\n      transaction: removedTx\n    };\n  }\n\n  /**\n   * Recalculate team scores from remaining transactions\n   * @private\n   */\n  _recalculateTeamScores(teamId) {\n    const team = this.sessionData.teams[teamId];\n\n    // Reset\n    team.baseScore = 0;\n    team.bonusPoints = 0;\n    team.score = 0;\n    team.tokensScanned = 0;\n    team.completedGroups = [];\n\n    // Replay transactions\n    this.sessionData.transactions\n      .filter(tx => tx.teamId === teamId)\n      .forEach(tx => this._updateTeamScore(tx));\n  }\n\n  /**\n   * Adjust team score (admin operation)\n   * @param {string} teamId - Team identifier\n   * @param {number} delta - Score adjustment\n   * @param {string} reason - Reason for adjustment\n   * @returns {Promise<TransactionResult>}\n   */\n  async adjustTeamScore(teamId, delta, reason = 'Manual adjustment') {\n    if (!this.sessionData.teams[teamId]) {\n      return {\n        success: false,\n        error: `Team not found: ${teamId}`\n      };\n    }\n\n    const team = this.sessionData.teams[teamId];\n\n    if (!team.adminAdjustments) {\n      team.adminAdjustments = [];\n    }\n\n    const adjustment = {\n      delta: parseInt(delta),\n      reason,\n      timestamp: new Date().toISOString()\n    };\n\n    team.adminAdjustments.push(adjustment);\n    team.score += adjustment.delta;\n\n    this._saveSession();\n\n    return {\n      success: true,\n      teamScore: { ...team }\n    };\n  }\n\n  /**\n   * Get unified game activity\n   * Matches DataManager.getGameActivity() API for parity\n   *\n   * Note: LocalStorage doesn't have player scans (no backend to receive them)\n   * but we maintain the same structure for API compatibility.\n   *\n   * @returns {Object} { tokens: Array, stats: Object }\n   */\n  getGameActivity() {\n    const tokenMap = new Map();\n\n    // Process player scans (empty in standalone, but maintain structure)\n    this.playerScans.forEach(scan => {\n      if (!tokenMap.has(scan.tokenId)) {\n        tokenMap.set(scan.tokenId, {\n          tokenId: scan.tokenId,\n          tokenData: scan.tokenData || {},\n          potentialValue: calculateTokenValue({\n            valueRating: scan.tokenData?.SF_ValueRating,\n            memoryType: scan.tokenData?.SF_MemoryType\n          }),\n          events: [{\n            type: 'discovery',\n            timestamp: scan.timestamp,\n            deviceId: scan.deviceId\n          }],\n          status: 'available',\n          discoveredByPlayers: true\n        });\n      } else {\n        tokenMap.get(scan.tokenId).events.push({\n          type: 'scan',\n          timestamp: scan.timestamp,\n          deviceId: scan.deviceId\n        });\n      }\n    });\n\n    // Process GM transactions (claims)\n    this.sessionData.transactions.forEach(tx => {\n      let activity = tokenMap.get(tx.tokenId);\n\n      if (!activity) {\n        // Look up token data\n        const lookedUpToken = this.tokenManager?.findToken(tx.tokenId);\n        const tokenData = lookedUpToken ? {\n          SF_MemoryType: lookedUpToken.SF_MemoryType,\n          SF_ValueRating: lookedUpToken.SF_ValueRating,\n          SF_Group: lookedUpToken.SF_Group || null,\n          summary: lookedUpToken.summary || null\n        } : {\n          SF_MemoryType: tx.memoryType,\n          SF_ValueRating: tx.valueRating\n        };\n\n        activity = {\n          tokenId: tx.tokenId,\n          tokenData,\n          potentialValue: calculateTokenValue({\n            valueRating: tokenData.SF_ValueRating,\n            memoryType: tokenData.SF_MemoryType\n          }),\n          events: [],\n          status: 'claimed',\n          discoveredByPlayers: false\n        };\n        tokenMap.set(tx.tokenId, activity);\n      }\n\n      // Add claim event\n      activity.events.push({\n        type: 'claim',\n        timestamp: tx.timestamp,\n        mode: tx.mode,\n        teamId: tx.teamId,\n        points: tx.points || 0,\n        summary: tx.summary || activity.tokenData?.summary || null\n      });\n      activity.status = 'claimed';\n    });\n\n    // Sort events within each token\n    tokenMap.forEach(activity => {\n      activity.events.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));\n    });\n\n    const tokens = Array.from(tokenMap.values());\n\n    const stats = {\n      totalTokens: tokens.length,\n      available: tokens.filter(t => t.status === 'available').length,\n      claimed: tokens.filter(t => t.status === 'claimed').length,\n      claimedWithoutDiscovery: tokens.filter(t => t.status === 'claimed' && !t.discoveredByPlayers).length,\n      totalPlayerScans: this.playerScans.length\n    };\n\n    return { tokens, stats };\n  }\n\n  /**\n   * Dispose of resources\n   * LocalStorage has no resources requiring cleanup\n   */\n  dispose() {\n    // No-op for LocalStorage - localStorage persists automatically\n  }\n}\n","/**\n * NetworkedStorage Strategy - WebSocket backend communication\n * Implements IStorageStrategy for networked mode operation\n *\n * @module core/storage/NetworkedStorage\n */\n\nimport { IStorageStrategy } from './IStorageStrategy.js';\nimport { calculateTokenValue } from '../scoring.js';\n\nexport class NetworkedStorage extends IStorageStrategy {\n  /**\n   * Create NetworkedStorage instance\n   * @param {Object} options - Dependencies\n   * @param {Object} options.socket - Socket.io client\n   * @param {Object} options.tokenManager - TokenManager instance\n   * @param {Object} [options.debug] - Debug instance\n   */\n  constructor({ socket, tokenManager, debug } = {}) {\n    super();\n\n    this.socket = socket;\n    this.tokenManager = tokenManager;\n    this.debug = debug;\n\n    // Local cache (synced from backend)\n    this.transactions = [];\n    this.backendScores = new Map();\n    this.scannedTokens = new Set();\n    this.playerScans = [];\n    this.currentSessionId = null;\n  }\n\n  /**\n   * Check if storage is ready/connected\n   * @returns {boolean}\n   */\n  isReady() {\n    return this.socket?.connected === true;\n  }\n\n  /**\n   * Initialize storage\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    // Setup event listeners for sync\n    this._setupEventListeners();\n  }\n\n  /**\n   * Setup event listeners\n   * Note: These are typically set up by NetworkedSession which owns the socket\n   * This is a pass-through storage that delegates to backend\n   * @private\n   */\n  _setupEventListeners() {\n    if (!this.socket) return;\n    // Event listeners handled by NetworkedSession\n  }\n\n  /**\n   * Add transaction - delegates to backend\n   * @param {Transaction} transaction - Transaction data\n   * @returns {Promise<TransactionResult>}\n   */\n  async addTransaction(transaction) {\n    // Validate required fields\n    if (!transaction || !transaction.teamId) {\n      return {\n        success: false,\n        error: 'Transaction must have teamId'\n      };\n    }\n\n    // Check socket connection\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot add transaction: socket not connected', true);\n      return {\n        success: false,\n        error: 'Socket not connected'\n      };\n    }\n\n    this.debug?.log(`[NetworkedStorage] Submitting transaction: ${transaction.tokenId} for team ${transaction.teamId}`);\n\n    this.socket.emit('transaction:submit', {\n      tokenId: transaction.tokenId,\n      teamId: transaction.teamId,\n      deviceId: transaction.deviceId,\n      deviceType: 'gm',\n      mode: transaction.mode,\n      timestamp: transaction.timestamp || new Date().toISOString()\n    });\n\n    // Mark locally for duplicate prevention\n    if (transaction.tokenId) {\n      this.scannedTokens.add(transaction.tokenId);\n    }\n\n    // Return pending - actual result comes via WebSocket broadcast\n    return {\n      success: true,\n      pending: true\n    };\n  }\n\n  /**\n   * Remove transaction - delegates to backend\n   * @param {string} transactionId - Transaction ID\n   * @returns {Promise<TransactionResult>}\n   */\n  async removeTransaction(transactionId) {\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot remove transaction: socket not connected', true);\n      return { success: false, error: 'Socket not connected' };\n    }\n\n    this.debug?.log(`[NetworkedStorage] Removing transaction: ${transactionId}`);\n\n    this.socket.emit('gm:command', {\n      event: 'gm:command',\n      data: {\n        action: 'transaction:delete',\n        payload: { transactionId }\n      },\n      timestamp: new Date().toISOString()\n    });\n\n    return { success: true, pending: true };\n  }\n\n  /**\n   * Get all transactions from local cache\n   * @returns {Array}\n   */\n  getTransactions() {\n    return this.transactions;\n  }\n\n  /**\n   * Get team scores from backend cache\n   * @returns {Array}\n   */\n  getTeamScores() {\n    if (this.backendScores.size === 0) {\n      return [];\n    }\n\n    return Array.from(this.backendScores.entries())\n      .map(([teamId, score]) => ({\n        teamId,\n        score: score.currentScore,\n        baseScore: score.baseScore,\n        bonusScore: score.bonusPoints,\n        tokenCount: score.tokensScanned,\n        completedGroups: score.completedGroups?.length || 0,\n        isFromBackend: true\n      }))\n      .sort((a, b) => b.score - a.score);\n  }\n\n  /**\n   * Adjust team score - delegates to backend\n   * @param {string} teamId - Team identifier\n   * @param {number} delta - Score adjustment\n   * @param {string} reason - Reason for adjustment\n   * @returns {Promise<TransactionResult>}\n   */\n  async adjustTeamScore(teamId, delta, reason) {\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot adjust score: socket not connected', true);\n      return { success: false, error: 'Socket not connected' };\n    }\n\n    this.debug?.log(`[NetworkedStorage] Adjusting score for team ${teamId}: ${delta > 0 ? '+' : ''}${delta} (${reason})`);\n\n    this.socket.emit('gm:command', {\n      event: 'gm:command',\n      data: {\n        action: 'score:adjust',\n        payload: { teamId, delta, reason }\n      },\n      timestamp: new Date().toISOString()\n    });\n\n    return { success: true, pending: true };\n  }\n\n  /**\n   * Get unified game activity\n   * Matches LocalStorage.getGameActivity() API for parity\n   * @returns {Object} { tokens: Array, stats: Object }\n   */\n  getGameActivity() {\n    const tokenMap = new Map();\n\n    // Process player scans (discoveries)\n    this.playerScans.forEach(scan => {\n      if (!tokenMap.has(scan.tokenId)) {\n        const tokenData = scan.tokenData || {};\n        tokenMap.set(scan.tokenId, {\n          tokenId: scan.tokenId,\n          tokenData,\n          potentialValue: calculateTokenValue({\n            valueRating: tokenData.SF_ValueRating,\n            memoryType: tokenData.SF_MemoryType\n          }),\n          events: [{\n            type: 'discovery',\n            timestamp: scan.timestamp,\n            deviceId: scan.deviceId\n          }],\n          status: 'available',\n          discoveredByPlayers: true\n        });\n      } else {\n        tokenMap.get(scan.tokenId).events.push({\n          type: 'scan',\n          timestamp: scan.timestamp,\n          deviceId: scan.deviceId\n        });\n      }\n    });\n\n    // Process transactions (claims)\n    this.transactions.forEach(tx => {\n      if (tx.status && tx.status !== 'accepted') return;\n\n      let activity = tokenMap.get(tx.tokenId);\n\n      if (!activity) {\n        const lookedUpToken = this.tokenManager?.findToken(tx.tokenId);\n        const tokenData = lookedUpToken ? {\n          SF_MemoryType: lookedUpToken.SF_MemoryType,\n          SF_ValueRating: lookedUpToken.SF_ValueRating,\n          SF_Group: lookedUpToken.SF_Group,\n          summary: lookedUpToken.summary\n        } : {\n          SF_MemoryType: tx.memoryType,\n          SF_ValueRating: tx.valueRating\n        };\n\n        activity = {\n          tokenId: tx.tokenId,\n          tokenData,\n          potentialValue: calculateTokenValue({\n            valueRating: tokenData.SF_ValueRating,\n            memoryType: tokenData.SF_MemoryType\n          }),\n          events: [],\n          status: 'claimed',\n          discoveredByPlayers: false\n        };\n        tokenMap.set(tx.tokenId, activity);\n      }\n\n      activity.events.push({\n        type: 'claim',\n        timestamp: tx.timestamp,\n        mode: tx.mode,\n        teamId: tx.teamId,\n        // Use stored points (from backend) if available, fall back to recalculation\n        points: tx.points || calculateTokenValue({\n          valueRating: tx.valueRating,\n          memoryType: tx.memoryType\n        }),\n        summary: tx.summary || activity.tokenData?.summary\n      });\n      activity.status = 'claimed';\n    });\n\n    // Sort events within each token\n    tokenMap.forEach(activity => {\n      activity.events.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));\n    });\n\n    const tokens = Array.from(tokenMap.values());\n\n    return {\n      tokens,\n      stats: {\n        totalTokens: tokens.length,\n        available: tokens.filter(t => t.status === 'available').length,\n        claimed: tokens.filter(t => t.status === 'claimed').length,\n        claimedWithoutDiscovery: tokens.filter(t => !t.discoveredByPlayers && t.status === 'claimed').length,\n        totalPlayerScans: this.playerScans.length\n      }\n    };\n  }\n\n  /**\n   * Create a new session - delegates to backend\n   * @param {string} name - Session name\n   * @param {Array} teams - Initial teams\n   * @returns {Promise<Object>}\n   */\n  async createSession(name, teams) {\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot create session: socket not connected', true);\n      return { success: false, error: 'Socket not connected' };\n    }\n\n    this.debug?.log(`[NetworkedStorage] Creating session: ${name}`);\n\n    this.socket.emit('gm:command', {\n      event: 'gm:command',\n      data: {\n        action: 'session:create',\n        payload: { name, teams }\n      },\n      timestamp: new Date().toISOString()\n    });\n\n    return { pending: true };\n  }\n\n  /**\n   * End the current session - delegates to backend\n   * @returns {Promise<void>}\n   */\n  async endSession() {\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot end session: socket not connected', true);\n      return;\n    }\n\n    this.debug?.log('[NetworkedStorage] Ending session');\n\n    this.socket.emit('gm:command', {\n      event: 'gm:command',\n      data: { action: 'session:end', payload: {} },\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  /**\n   * Get current session info\n   * @returns {SessionInfo|null}\n   */\n  getCurrentSession() {\n    return this.currentSessionId ? {\n      sessionId: this.currentSessionId,\n      status: 'active'\n    } : null;\n  }\n\n  /**\n   * Pause the current session - delegates to backend\n   * @returns {Promise<Object>}\n   */\n  async pauseSession() {\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot pause session: socket not connected', true);\n      return { success: false, error: 'Socket not connected' };\n    }\n\n    this.debug?.log('[NetworkedStorage] Pausing session');\n\n    this.socket.emit('gm:command', {\n      event: 'gm:command',\n      data: { action: 'session:pause', payload: {} },\n      timestamp: new Date().toISOString()\n    });\n\n    return { success: true, pending: true };\n  }\n\n  /**\n   * Resume the current session - delegates to backend\n   * @returns {Promise<Object>}\n   */\n  async resumeSession() {\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot resume session: socket not connected', true);\n      return { success: false, error: 'Socket not connected' };\n    }\n\n    this.debug?.log('[NetworkedStorage] Resuming session');\n\n    this.socket.emit('gm:command', {\n      event: 'gm:command',\n      data: { action: 'session:resume', payload: {} },\n      timestamp: new Date().toISOString()\n    });\n\n    return { success: true, pending: true };\n  }\n\n  /**\n   * Reset all scores - delegates to backend\n   * @returns {Promise<Object>}\n   */\n  async resetScores() {\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot reset scores: socket not connected', true);\n      return { success: false, error: 'Socket not connected' };\n    }\n\n    this.debug?.log('[NetworkedStorage] Resetting all scores');\n\n    this.socket.emit('gm:command', {\n      event: 'gm:command',\n      data: { action: 'scores:reset', payload: {} },\n      timestamp: new Date().toISOString()\n    });\n\n    return { success: true, pending: true };\n  }\n\n  // ========================================\n  // Cache update methods for NetworkedSession\n  // ========================================\n\n  /**\n   * Set transactions from sync:full\n   * @param {Array} transactions\n   */\n  setTransactions(transactions) {\n    this.transactions = transactions;\n  }\n\n  /**\n   * Add transaction from broadcast (prevents duplicates)\n   * @param {Object} tx\n   */\n  addTransactionFromBroadcast(tx) {\n    const exists = this.transactions.some(t => t.id === tx.id);\n    if (!exists) {\n      this.transactions.push(tx);\n    }\n  }\n\n  /**\n   * Set backend scores for a team\n   * @param {string} teamId\n   * @param {Object} scoreData\n   */\n  setBackendScores(teamId, scoreData) {\n    this.backendScores.set(teamId, scoreData);\n  }\n\n  /**\n   * Clear all backend scores\n   */\n  clearBackendScores() {\n    this.backendScores.clear();\n  }\n\n  /**\n   * Set scanned tokens from sync\n   * @param {Array} tokens\n   */\n  setScannedTokens(tokens) {\n    this.scannedTokens = new Set(tokens);\n  }\n\n  /**\n   * Set player scans from sync:full\n   * @param {Array} scans\n   */\n  setPlayerScans(scans) {\n    this.playerScans = scans;\n  }\n\n  /**\n   * Add player scan from broadcast (prevents duplicates)\n   * @param {Object} scan\n   */\n  addPlayerScan(scan) {\n    const exists = this.playerScans.some(s => s.id === scan.id);\n    if (!exists) {\n      this.playerScans.push(scan);\n    }\n  }\n\n  /**\n   * Set current session ID\n   * @param {string} sessionId\n   */\n  setSessionId(sessionId) {\n    this.currentSessionId = sessionId;\n  }\n\n  /**\n   * Dispose of resources\n   */\n  dispose() {\n    // NetworkedStorage doesn't own the socket, just references it\n    // Cleanup is handled by NetworkedSession\n  }\n}\n","/**\n * DataManagerUtils - Shared utilities for data management\n * Extracted from DataManager and StandaloneDataManager to eliminate duplication\n *\n * @module core/dataManagerUtils\n */\n\nexport class DataManagerUtils {\n  /**\n   * Check if token has been scanned (duplicate detection)\n   * @param {Set} scannedTokens - Set of scanned token IDs\n   * @param {string} tokenId - Token ID to check\n   * @returns {boolean} True if token already scanned\n   */\n  static isTokenScanned(scannedTokens, tokenId) {\n    return scannedTokens.has(tokenId);\n  }\n\n  /**\n   * Mark token as scanned (for duplicate detection)\n   * @param {Set} scannedTokens - Set of scanned token IDs\n   * @param {string} tokenId - Token ID to mark\n   */\n  static markTokenAsScanned(scannedTokens, tokenId) {\n    scannedTokens.add(tokenId);\n  }\n\n  /**\n   * Unmark token as scanned (allow re-scanning after delete)\n   * @param {Set} scannedTokens - Set of scanned token IDs\n   * @param {string} tokenId - Token ID to unmark\n   * @returns {boolean} True if token was removed, false if not present\n   */\n  static unmarkTokenAsScanned(scannedTokens, tokenId) {\n    return scannedTokens.delete(tokenId);\n  }\n\n  /**\n   * Calculate global statistics from transactions\n   * @param {Array} transactions - Array of transaction objects\n   * @param {Function} calculateTokenValue - Function to calculate token value\n   * @returns {Object} Global stats object\n   */\n  static calculateGlobalStats(transactions, calculateTokenValue) {\n    const total = transactions.length;\n    const teams = [...new Set(transactions.map(t => t.teamId))].length;\n    const known = transactions.filter(t => !t.isUnknown);\n\n    const blackMarketTransactions = known.filter(t => t.mode === 'blackmarket');\n\n    const blackMarketScore = blackMarketTransactions.reduce((sum, t) => {\n      return sum + calculateTokenValue(t);\n    }, 0);\n\n    // totalValue derived from blackMarketScore only - detective mode has no scoring\n    const totalValue = Math.floor(blackMarketScore / 1000);\n    const avgValue = known.length > 0 ? parseFloat((totalValue / known.length).toFixed(1)) : 0;\n\n    return { total, teams, totalValue, avgValue, blackMarketScore };\n  }\n}\n","/**\n * UnifiedDataManager - Single entry point for data operations\n * Delegates to LocalStorage or NetworkedStorage based on session mode\n *\n * @module core/unifiedDataManager\n */\n\nimport { LocalStorage } from './storage/LocalStorage.js';\nimport { NetworkedStorage } from './storage/NetworkedStorage.js';\nimport { DataManagerUtils } from './dataManagerUtils.js';\nimport {\n  SCORING_CONFIG,\n  calculateTokenValue as calcTokenValue,\n  parseGroupInfo as parseGroup,\n  normalizeGroupName as sharedNormalizeGroupName\n} from './scoring.js';\n\nexport class UnifiedDataManager extends EventTarget {\n  /**\n   * Create UnifiedDataManager instance\n   * @param {Object} options - Dependencies\n   * @param {Object} options.tokenManager - TokenManager instance\n   * @param {Object} options.sessionModeManager - SessionModeManager instance\n   * @param {Object} [options.debug] - Debug instance\n   */\n  constructor({ tokenManager, sessionModeManager, debug } = {}) {\n    super();\n\n    this.tokenManager = tokenManager;\n    this.sessionModeManager = sessionModeManager;\n    this.debug = debug;\n\n    // Strategy instances (created on mode selection)\n    this._localStrategy = null;\n    this._networkedStrategy = null;\n    this._activeStrategy = null;\n\n    // Store event listener references for cleanup\n    this._strategyListeners = new Map();\n\n    // Expose scannedTokens for backward compatibility\n    // NOTE: This is a shared reference to the strategy's Set\n    this.scannedTokens = new Set();\n\n    // Expose SCORING_CONFIG for UIManager.renderTokenCard()\n    // This follows the pattern from DataManager and LocalStorage\n    this.SCORING_CONFIG = SCORING_CONFIG;\n\n    // Session tracking for boundary detection\n    this.currentSessionId = null;\n  }\n\n  /**\n   * Initialize standalone mode (LocalStorage strategy)\n   * @returns {Promise<void>}\n   */\n  async initializeStandaloneMode() {\n    this._log('Initializing standalone mode');\n\n    this._localStrategy = new LocalStorage({\n      tokenManager: this.tokenManager,\n      debug: this.debug\n    });\n\n    await this._localStrategy.initialize();\n    this._activeStrategy = this._localStrategy;\n\n    // Sync scannedTokens from strategy\n    this._syncScannedTokens();\n\n    // Wire up event forwarding\n    this._wireStrategyEvents(this._localStrategy);\n\n    this._log('Standalone mode initialized');\n  }\n\n  /**\n   * Initialize networked mode (NetworkedStorage strategy)\n   * @param {Object} socket - Socket.io client instance (or object with .socket property)\n   * @returns {Promise<void>}\n   */\n  async initializeNetworkedMode(socket) {\n    this._log('Initializing networked mode');\n\n    // Handle both direct socket and networkedSession-like objects\n    const actualSocket = socket?.socket || socket;\n\n    this._networkedStrategy = new NetworkedStorage({\n      tokenManager: this.tokenManager,\n      socket: actualSocket,\n      debug: this.debug\n    });\n\n    await this._networkedStrategy.initialize();\n    this._activeStrategy = this._networkedStrategy;\n\n    // Sync scannedTokens from strategy\n    this._syncScannedTokens();\n\n    // Wire up event forwarding\n    this._wireStrategyEvents(this._networkedStrategy);\n\n    this._log('Networked mode initialized');\n  }\n\n  /**\n   * Check if manager is ready\n   * @returns {boolean}\n   */\n  isReady() {\n    return this._activeStrategy?.isReady() ?? false;\n  }\n\n  /**\n   * Get active strategy type\n   * @returns {string|null} 'local' | 'networked' | null\n   */\n  getActiveStrategyType() {\n    if (!this._activeStrategy) return null;\n    if (this._activeStrategy === this._localStrategy) return 'local';\n    if (this._activeStrategy === this._networkedStrategy) return 'networked';\n    return null;\n  }\n\n  /**\n   * Sync scannedTokens from active strategy\n   * NOTE: Creates a shared reference for backward compatibility.\n   * The scannedTokens Set is owned by the strategy - if strategy\n   * replaces its Set, call this method again to re-sync.\n   * @private\n   */\n  _syncScannedTokens() {\n    if (this._activeStrategy?.scannedTokens) {\n      this.scannedTokens = this._activeStrategy.scannedTokens;\n    }\n  }\n\n  /**\n   * Wire event forwarding from strategy to manager\n   * Stores listener references for cleanup via _unwireStrategyEvents\n   * @private\n   * @param {IStorageStrategy} strategy\n   */\n  _wireStrategyEvents(strategy) {\n    const events = [\n      'transaction:added',\n      'transaction:deleted',\n      'team-score:updated',\n      'scores:cleared',\n      'data:cleared',\n      'game-state:updated',\n      'player-scan:added',\n      'session:updated'\n    ];\n\n    const listeners = [];\n    events.forEach(eventName => {\n      const handler = (event) => {\n        this.dispatchEvent(new CustomEvent(eventName, { detail: event.detail }));\n      };\n      strategy.addEventListener(eventName, handler);\n      listeners.push({ eventName, handler });\n    });\n\n    this._strategyListeners.set(strategy, listeners);\n  }\n\n  /**\n   * Remove event listeners from strategy\n   * @private\n   * @param {IStorageStrategy} strategy\n   */\n  _unwireStrategyEvents(strategy) {\n    const listeners = this._strategyListeners.get(strategy);\n    if (listeners) {\n      listeners.forEach(({ eventName, handler }) => {\n        strategy.removeEventListener(eventName, handler);\n      });\n      this._strategyListeners.delete(strategy);\n    }\n  }\n\n  /**\n   * Log message if debug available\n   * @private\n   */\n  _log(message) {\n    if (this.debug?.log) {\n      this.debug.log(`[UnifiedDataManager] ${message}`);\n    }\n  }\n\n  // ============================================================================\n  // DELEGATED OPERATIONS - Core IStorageStrategy methods\n  // ============================================================================\n\n  /**\n   * Add a transaction\n   * @param {Object} transaction - Transaction data\n   * @returns {Promise<Object>} Transaction result\n   */\n  async addTransaction(transaction) {\n    this._requireActiveStrategy();\n    return this._activeStrategy.addTransaction(transaction);\n  }\n\n  /**\n   * Remove a transaction\n   * @param {string} transactionId - Transaction ID\n   * @returns {Promise<Object>} Result\n   */\n  async removeTransaction(transactionId) {\n    this._requireActiveStrategy();\n    return this._activeStrategy.removeTransaction(transactionId);\n  }\n\n  /**\n   * Add transaction from broadcast (networked mode only)\n   * Used when receiving transaction:new events from backend\n   * @param {Object} tx - Transaction from broadcast\n   */\n  addTransactionFromBroadcast(tx) {\n    // Only NetworkedStorage has this method\n    if (typeof this._activeStrategy?.addTransactionFromBroadcast === 'function') {\n      this._activeStrategy.addTransactionFromBroadcast(tx);\n      // Emit event so UI can update\n      this.dispatchEvent(new CustomEvent('transaction:added', {\n        detail: { transaction: tx }\n      }));\n    }\n  }\n\n  /**\n   * Get all transactions\n   * @returns {Array} Transactions\n   */\n  getTransactions() {\n    this._requireActiveStrategy();\n    return this._activeStrategy.getTransactions();\n  }\n\n  /**\n   * Get team scores\n   * @returns {Array} Team scores sorted by score descending\n   */\n  getTeamScores() {\n    this._requireActiveStrategy();\n    return this._activeStrategy.getTeamScores();\n  }\n\n  /**\n   * Adjust team score\n   * @param {string} teamId - Team ID\n   * @param {number} delta - Score adjustment\n   * @param {string} reason - Reason for adjustment\n   * @returns {Promise<Object>} Result\n   */\n  async adjustTeamScore(teamId, delta, reason) {\n    this._requireActiveStrategy();\n    return this._activeStrategy.adjustTeamScore(teamId, delta, reason);\n  }\n\n  /**\n   * Get game activity\n   * @returns {Object} { tokens, stats }\n   */\n  getGameActivity() {\n    this._requireActiveStrategy();\n    return this._activeStrategy.getGameActivity();\n  }\n\n  /**\n   * Get current session info\n   * @returns {Object|null}\n   */\n  getCurrentSession() {\n    return this._activeStrategy?.getCurrentSession() ?? null;\n  }\n\n  /**\n   * Create a new session\n   * @param {string} name - Session name\n   * @param {Array} teams - Initial teams\n   * @returns {Promise<Object>}\n   */\n  async createSession(name, teams) {\n    this._requireActiveStrategy();\n    return this._activeStrategy.createSession(name, teams);\n  }\n\n  /**\n   * End current session\n   * @returns {Promise<void>}\n   */\n  async endSession() {\n    this._requireActiveStrategy();\n    return this._activeStrategy.endSession();\n  }\n\n  /**\n   * Pause the current session\n   * @returns {Promise<{success: boolean, error?: string}>}\n   */\n  async pauseSession() {\n    this._requireActiveStrategy();\n    return this._activeStrategy.pauseSession();\n  }\n\n  /**\n   * Resume a paused session\n   * @returns {Promise<{success: boolean, error?: string}>}\n   */\n  async resumeSession() {\n    this._requireActiveStrategy();\n    return this._activeStrategy.resumeSession();\n  }\n\n  /**\n   * Reset all team scores to zero\n   * @returns {Promise<{success: boolean}>}\n   */\n  async resetScores() {\n    this._requireActiveStrategy();\n    return this._activeStrategy.resetScores();\n  }\n\n  /**\n   * Dispose of resources - clean up event listeners and strategies\n   * Call when manager is no longer needed to prevent memory leaks\n   */\n  dispose() {\n    // Unwire event listeners from all strategies\n    if (this._localStrategy) {\n      this._unwireStrategyEvents(this._localStrategy);\n      this._localStrategy.dispose();\n    }\n    if (this._networkedStrategy) {\n      this._unwireStrategyEvents(this._networkedStrategy);\n      this._networkedStrategy.dispose();\n    }\n\n    // Clear references\n    this._activeStrategy = null;\n    this._localStrategy = null;\n    this._networkedStrategy = null;\n    this._strategyListeners.clear();\n    this.scannedTokens = new Set();\n\n    this._log('Disposed');\n  }\n\n  /**\n   * Ensure active strategy exists\n   * @private\n   */\n  _requireActiveStrategy() {\n    if (!this._activeStrategy) {\n      throw new Error('UnifiedDataManager: No active strategy. Call initializeStandaloneMode() or initializeNetworkedMode() first.');\n    }\n  }\n\n  // ============================================================================\n  // UTILITY METHODS - Backward compatibility with DataManager/StandaloneDataManager\n  // ============================================================================\n\n  /**\n   * Check if token has been scanned\n   * @param {string} tokenId\n   * @returns {boolean}\n   */\n  isTokenScanned(tokenId) {\n    return DataManagerUtils.isTokenScanned(this.scannedTokens, tokenId);\n  }\n\n  /**\n   * Mark token as scanned\n   * @param {string} tokenId\n   */\n  markTokenAsScanned(tokenId) {\n    DataManagerUtils.markTokenAsScanned(this.scannedTokens, tokenId);\n  }\n\n  /**\n   * Unmark token as scanned (for re-scanning after deletion)\n   * @param {string} tokenId\n   */\n  unmarkTokenAsScanned(tokenId) {\n    DataManagerUtils.unmarkTokenAsScanned(this.scannedTokens, tokenId);\n  }\n\n  /**\n   * Calculate token value based on rating and type\n   * @param {Object} transaction - Transaction with valueRating and memoryType\n   * @returns {number}\n   */\n  calculateTokenValue(transaction) {\n    return calcTokenValue(transaction);\n  }\n\n  /**\n   * Get transactions for a specific team\n   * @param {string} teamId\n   * @returns {Array}\n   */\n  getTeamTransactions(teamId) {\n    const transactions = this.getTransactions();\n    return transactions.filter(tx => tx.teamId === teamId);\n  }\n\n  // ============================================================================\n  // ADVANCED METHODS - Group completion, session reset, etc.\n  // ============================================================================\n\n  /**\n   * Parse group info from group string\n   * @param {string} groupString - e.g., \"Server Logs (x5)\"\n   * @returns {Object} { name, multiplier }\n   */\n  parseGroupInfo(groupString) {\n    return parseGroup(groupString);\n  }\n\n  /**\n   * Normalize group name for comparison\n   * Delegates to shared scoring.js implementation for consistency\n   * @param {string} groupName\n   * @returns {string}\n   */\n  normalizeGroupName(groupName) {\n    return sharedNormalizeGroupName(groupName);\n  }\n\n  /**\n   * Reset for new session - clears scannedTokens and emits data:cleared\n   * @param {string|null} sessionId - New session ID (null to clear)\n   */\n  resetForNewSession(sessionId = null) {\n    this.currentSessionId = sessionId;\n    this.scannedTokens.clear();\n\n    if (this._localStrategy) {\n      this._localStrategy.scannedTokens?.clear();\n    }\n    if (this._networkedStrategy) {\n      this._networkedStrategy.scannedTokens?.clear();\n      this._networkedStrategy.transactions = [];\n      this._networkedStrategy.playerScans = [];\n      this._networkedStrategy.backendScores?.clear();\n      this._networkedStrategy.setSessionId?.(sessionId);\n    }\n\n    this._log(`Reset for new session: ${sessionId || 'none'}`);\n    this.dispatchEvent(new CustomEvent('data:cleared'));\n  }\n\n  /**\n   * Clear all data - same as resetForNewSession\n   */\n  clearAllData() {\n    this.resetForNewSession();\n  }\n\n  /**\n   * Get team completed groups\n   * @param {string} teamId\n   * @returns {Array} Completed group names\n   */\n  getTeamCompletedGroups(teamId) {\n    // Delegate to strategy if available\n    if (this._activeStrategy?.getTeamCompletedGroups) {\n      return this._activeStrategy.getTeamCompletedGroups(teamId);\n    }\n    return [];\n  }\n\n  /**\n   * Get enhanced team transactions with grouping for team details display\n   * @param {string} teamId - Team ID\n   * @returns {Object} Grouped transaction data with completed/incomplete groups\n   */\n  getEnhancedTeamTransactions(teamId) {\n    const transactions = this.getTeamTransactions(teamId);\n    const groupInventory = this.tokenManager?.getGroupInventory() || {};\n    const completedGroups = this.getTeamCompletedGroups(teamId);\n    const completedGroupNames = new Set(completedGroups.map(g => g.normalizedName));\n\n    // Calculate bonus values\n    const groupBonusData = {};\n    completedGroups.forEach(group => {\n      groupBonusData[group.normalizedName] = {\n        displayName: group.name,\n        multiplier: group.multiplier,\n        tokens: [],\n        totalBaseValue: 0,\n        bonusValue: 0\n      };\n    });\n\n    // Organize transactions\n    const completedGroupTokens = {};\n    const incompleteGroupTokens = {};\n    const ungroupedTokens = [];\n    const unknownTokens = [];\n\n    transactions.forEach(t => {\n      if (t.isUnknown) {\n        unknownTokens.push(t);\n        return;\n      }\n\n      const groupInfo = this.parseGroupInfo(t.group);\n      const normalizedGroupName = this.normalizeGroupName(groupInfo.name);\n      const groupData = groupInventory[normalizedGroupName];\n\n      if (!groupData || groupData.tokens.size <= 1) {\n        ungroupedTokens.push(t);\n        return;\n      }\n\n      const tokenValue = this.calculateTokenValue(t);\n\n      if (completedGroupNames.has(normalizedGroupName)) {\n        // Completed group\n        if (!completedGroupTokens[normalizedGroupName]) {\n          completedGroupTokens[normalizedGroupName] = [];\n        }\n        completedGroupTokens[normalizedGroupName].push(t);\n\n        if (groupBonusData[normalizedGroupName]) {\n          groupBonusData[normalizedGroupName].tokens.push(t);\n          groupBonusData[normalizedGroupName].totalBaseValue += tokenValue;\n          groupBonusData[normalizedGroupName].bonusValue += tokenValue * (groupInfo.multiplier - 1);\n        }\n      } else {\n        // Incomplete group\n        if (!incompleteGroupTokens[normalizedGroupName]) {\n          incompleteGroupTokens[normalizedGroupName] = {\n            displayName: groupData.displayName,\n            multiplier: groupData.multiplier,\n            tokens: [],\n            totalTokens: groupData.tokens.size,\n            collectedTokens: 0\n          };\n        }\n        incompleteGroupTokens[normalizedGroupName].tokens.push(t);\n      }\n    });\n\n    // Calculate progress\n    Object.keys(incompleteGroupTokens).forEach(normalizedName => {\n      const group = incompleteGroupTokens[normalizedName];\n      group.collectedTokens = group.tokens.length;\n      group.progress = `${group.collectedTokens}/${group.totalTokens}`;\n      group.percentage = Math.round((group.collectedTokens / group.totalTokens) * 100);\n    });\n\n    // Convert to arrays and sort\n    const completedGroupsArray = Object.entries(completedGroupTokens).map(([normalizedName, tokens]) => ({\n      ...groupBonusData[normalizedName],\n      normalizedName,\n      tokens\n    })).sort((a, b) => b.bonusValue - a.bonusValue);\n\n    const incompleteGroupsArray = Object.values(incompleteGroupTokens)\n      .sort((a, b) => b.percentage - a.percentage);\n\n    return {\n      completedGroups: completedGroupsArray,\n      incompleteGroups: incompleteGroupsArray,\n      ungroupedTokens,\n      unknownTokens,\n      hasCompletedGroups: completedGroupsArray.length > 0,\n      hasIncompleteGroups: incompleteGroupsArray.length > 0,\n      hasUngroupedTokens: ungroupedTokens.length > 0,\n      hasUnknownTokens: unknownTokens.length > 0\n    };\n  }\n\n  /**\n   * Calculate team score with group completion bonuses\n   * @param {string} teamId - Team ID\n   * @returns {Object} Score breakdown\n   */\n  calculateTeamScoreWithBonuses(teamId) {\n    const transactions = this.getTeamTransactions(teamId).filter(t =>\n      t.mode === 'blackmarket' && !t.isUnknown\n    );\n\n    const completedGroups = this.getTeamCompletedGroups(teamId);\n    const completedGroupNames = new Set(\n      completedGroups.map(g => g.normalizedName)\n    );\n\n    let baseScore = 0;\n    let bonusScore = 0;\n    const groupBreakdown = {};\n\n    // Initialize breakdown for completed groups\n    completedGroups.forEach(group => {\n      groupBreakdown[group.name] = {\n        tokens: 0,\n        baseValue: 0,\n        bonusValue: 0,\n        multiplier: group.multiplier\n      };\n    });\n\n    // Calculate scores for each transaction\n    transactions.forEach(t => {\n      const tokenBaseValue = this.calculateTokenValue(t);\n      baseScore += tokenBaseValue;\n\n      // Check if this token's group is completed\n      const groupInfo = this.parseGroupInfo(t.group);\n      const normalizedGroupName = this.normalizeGroupName(groupInfo.name);\n\n      if (completedGroupNames.has(normalizedGroupName)) {\n        // Apply bonus (multiplier - 1) √ó base value\n        const bonusAmount = tokenBaseValue * (groupInfo.multiplier - 1);\n        bonusScore += bonusAmount;\n\n        // Track in breakdown\n        if (groupBreakdown[groupInfo.name]) {\n          groupBreakdown[groupInfo.name].tokens++;\n          groupBreakdown[groupInfo.name].baseValue += tokenBaseValue;\n          groupBreakdown[groupInfo.name].bonusValue += bonusAmount;\n        }\n      }\n    });\n\n    this._log(`Team ${teamId}: Base=$${baseScore}, Bonus=$${bonusScore}`);\n\n    return {\n      baseScore,\n      bonusScore,\n      totalScore: baseScore + bonusScore,\n      completedGroups: completedGroups.length,\n      groupBreakdown\n    };\n  }\n\n  /**\n   * Get session stats for the current team\n   * @returns {Object} { count, totalValue, totalScore }\n   */\n  getSessionStats() {\n    const currentTeamId = this.app?.currentTeamId;\n\n    if (!currentTeamId) {\n      return { count: 0, totalValue: 0, totalScore: 0 };\n    }\n\n    const teamTransactions = this.getTeamTransactions(currentTeamId);\n    const count = teamTransactions.length;\n    const knownTokens = teamTransactions.filter(t => !t.isUnknown);\n    const totalValue = knownTokens.reduce((sum, t) => sum + (t.valueRating || 0), 0);\n\n    // Get team score from teamScores\n    const scores = this.getTeamScores();\n    const teamScore = scores.find(s => s.teamId === currentTeamId);\n    const totalScore = teamScore?.score || 0;\n\n    return { count, totalValue, totalScore };\n  }\n\n  /**\n   * Get global stats across all teams\n   * @returns {Object} { total, teams, totalValue, avgValue, blackMarketScore }\n   */\n  getGlobalStats() {\n    const transactions = this.getTransactions();\n    const total = transactions.length;\n\n    // Count unique teams\n    const teamIds = [...new Set(transactions.map(t => t.teamId))];\n    const teams = teamIds.length;\n\n    // Calculate black market score from team scores\n    const teamScores = this.getTeamScores();\n    const blackMarketScore = teamScores.reduce((sum, ts) => sum + (ts.score || 0), 0);\n\n    // totalValue derived from blackMarketScore (display format)\n    const totalValue = Math.floor(blackMarketScore / 1000);\n    const known = transactions.filter(t => !t.isUnknown);\n    const avgValue = known.length > 0 ? (totalValue / known.length).toFixed(1) : 0;\n\n    return { total, teams, totalValue, avgValue, blackMarketScore };\n  }\n\n  // ============================================================================\n  // WEBSOCKET EVENT HANDLERS - Facade methods for NetworkedSession\n  // These delegate storage updates to the active strategy and emit UI events\n  // ============================================================================\n\n  /**\n   * Update team score from backend WebSocket event\n   * Called by NetworkedSession on 'score:updated' and 'sync:full'\n   * @param {Object} scoreData - Score data from backend\n   */\n  updateTeamScoreFromBackend(scoreData) {\n    if (!this._networkedStrategy) {\n      this._log('updateTeamScoreFromBackend called but no networked strategy active', true);\n      return;\n    }\n\n    // Delegate storage update to strategy\n    this._networkedStrategy.setBackendScores(scoreData.teamId, {\n      currentScore: scoreData.currentScore,\n      baseScore: scoreData.baseScore,\n      bonusPoints: scoreData.bonusPoints,\n      tokensScanned: scoreData.tokensScanned,\n      completedGroups: scoreData.completedGroups,\n      adminAdjustments: scoreData.adminAdjustments || [],\n      lastUpdate: scoreData.lastUpdate\n    });\n\n    // Emit event for UI updates\n    this.dispatchEvent(new CustomEvent('team-score:updated', {\n      detail: {\n        teamId: scoreData.teamId,\n        scoreData,\n        transactions: this.getTeamTransactions(scoreData.teamId)\n      }\n    }));\n\n    this._log(`Score updated from backend for team ${scoreData.teamId}: $${scoreData.currentScore}`);\n  }\n\n  /**\n   * Handle player scan event from WebSocket broadcast\n   * Called by NetworkedSession on 'player:scan'\n   * @param {Object} payload - Player scan event payload\n   */\n  handlePlayerScan(payload) {\n    if (!this._networkedStrategy) {\n      this._log('handlePlayerScan called but no networked strategy active', true);\n      return;\n    }\n\n    const playerScan = {\n      id: payload.scanId,\n      tokenId: payload.tokenId,\n      deviceId: payload.deviceId,\n      timestamp: payload.timestamp,\n      memoryType: payload.memoryType || null,\n      videoQueued: payload.videoQueued || false,\n      tokenData: payload.tokenData || null\n    };\n\n    // Delegate storage update to strategy\n    this._networkedStrategy.addPlayerScan(playerScan);\n\n    // Emit event for UI updates\n    this.dispatchEvent(new CustomEvent('player-scan:added', {\n      detail: { playerScan }\n    }));\n\n    this._log(`Player scan added: ${payload.tokenId} from ${payload.deviceId}`);\n  }\n\n  /**\n   * Set player scans from sync:full payload\n   * Called by NetworkedSession on reconnect to restore state\n   * @param {Array} playerScans - Array of player scan records from server\n   */\n  setPlayerScansFromServer(playerScans) {\n    if (!this._networkedStrategy) {\n      this._log('setPlayerScansFromServer called but no networked strategy active', true);\n      return;\n    }\n\n    if (!Array.isArray(playerScans)) {\n      this._log('setPlayerScansFromServer: invalid input (not array)', true);\n      return;\n    }\n\n    this._networkedStrategy.setPlayerScans(playerScans);\n    this._log(`Synced ${playerScans.length} player scans from server`);\n\n    // Emit event for UI updates\n    this.dispatchEvent(new CustomEvent('player-scans:synced', {\n      detail: { count: playerScans.length }\n    }));\n  }\n\n  /**\n   * Set scanned tokens from sync:full payload\n   * Called by NetworkedSession on reconnect to restore duplicate tracking\n   * @param {Array} tokens - Array of token IDs that have been scanned\n   */\n  setScannedTokensFromServer(tokens) {\n    if (!this._networkedStrategy) {\n      this._log('setScannedTokensFromServer called but no networked strategy active', true);\n      return;\n    }\n\n    if (!Array.isArray(tokens)) {\n      this._log('setScannedTokensFromServer: invalid input (not array)', true);\n      return;\n    }\n\n    this._networkedStrategy.setScannedTokens(tokens);\n    // Sync local reference\n    this._syncScannedTokens();\n    this._log(`Synced ${tokens.length} scanned tokens from server`);\n  }\n\n  /**\n   * Clear all backend scores\n   * Called by NetworkedSession on 'scores:reset'\n   */\n  clearBackendScores() {\n    if (!this._networkedStrategy) {\n      this._log('clearBackendScores called but no networked strategy active', true);\n      return;\n    }\n\n    this._networkedStrategy.clearBackendScores();\n    this._log('Backend scores cleared');\n\n    // Emit event for UI updates\n    this.dispatchEvent(new CustomEvent('scores:cleared'));\n  }\n}\n","/**\n * TeamRegistry - Unified Team Management\n * ES6 Module Export\n *\n * Provides a unified interface for team management across both networked\n * and standalone modes. This enables UI PARITY - identical team selection\n * experience regardless of mode.\n *\n * Architecture:\n * - Networked mode: populated from sync:full / session:update WebSocket events\n * - Standalone mode: populated from StandaloneDataManager.sessionData.teams\n *\n * Events:\n * - 'teams:updated' - Team list changed (add/remove/clear)\n * - 'team:added' - Single team added\n *\n * @module core/teamRegistry\n */\n\nclass TeamRegistry extends EventTarget {\n    constructor() {\n        super();\n\n        /**\n         * Map of team ID to team info\n         * @type {Map<string, {teamId: string, score: number, tokensScanned: number}>}\n         */\n        this.teams = new Map();\n\n        /**\n         * Current mode for context\n         * @type {'networked'|'standalone'|null}\n         */\n        this.mode = null;\n\n        /**\n         * SessionModeManager for mode detection\n         * @type {Object|null}\n         */\n        this.sessionModeManager = null;\n\n        /**\n         * OrchestratorClient for networked team creation\n         * @type {Object|null}\n         */\n        this.orchestratorClient = null;\n    }\n\n    /**\n     * Set the current mode\n     * @param {'networked'|'standalone'} mode\n     */\n    setMode(mode) {\n        this.mode = mode;\n    }\n\n    /**\n     * Get all teams as an array\n     * @returns {Array<{teamId: string, score: number, tokensScanned: number}>}\n     */\n    getTeams() {\n        return Array.from(this.teams.values());\n    }\n\n    /**\n     * Get a single team by ID\n     * @param {string} teamId\n     * @returns {Object|undefined}\n     */\n    getTeam(teamId) {\n        return this.teams.get(teamId);\n    }\n\n    /**\n     * Check if a team exists\n     * @param {string} teamId\n     * @returns {boolean}\n     */\n    hasTeam(teamId) {\n        return this.teams.has(teamId);\n    }\n\n    /**\n     * Add a team to the registry\n     * Does NOT send to backend - that's the caller's responsibility\n     * @param {string} teamId - Team identifier\n     * @param {Object} [teamInfo={}] - Optional team metadata\n     */\n    addTeam(teamId, teamInfo = {}) {\n        if (!teamId || typeof teamId !== 'string') {\n            console.warn('[TeamRegistry] Invalid teamId:', teamId);\n            return false;\n        }\n\n        const normalizedId = teamId.trim();\n        if (!normalizedId) {\n            console.warn('[TeamRegistry] Empty teamId after trim');\n            return false;\n        }\n\n        const existingTeam = this.teams.get(normalizedId);\n        if (existingTeam) {\n            // Update existing team info\n            this.teams.set(normalizedId, { ...existingTeam, ...teamInfo, teamId: normalizedId });\n        } else {\n            // Add new team\n            this.teams.set(normalizedId, {\n                teamId: normalizedId,\n                score: 0,\n                tokensScanned: 0,\n                ...teamInfo\n            });\n\n            // Emit team:added for new teams only\n            this.dispatchEvent(new CustomEvent('team:added', {\n                detail: { teamId: normalizedId, teamInfo: this.teams.get(normalizedId) }\n            }));\n        }\n\n        // Always emit teams:updated\n        this.dispatchEvent(new CustomEvent('teams:updated', {\n            detail: { teams: this.getTeams() }\n        }));\n\n        return true;\n    }\n\n    /**\n     * Remove a team from the registry\n     * @param {string} teamId\n     * @returns {boolean} True if team was removed\n     */\n    removeTeam(teamId) {\n        const removed = this.teams.delete(teamId);\n        if (removed) {\n            this.dispatchEvent(new CustomEvent('teams:updated', {\n                detail: { teams: this.getTeams() }\n            }));\n        }\n        return removed;\n    }\n\n    /**\n     * Clear all teams (e.g., on session end)\n     */\n    clear() {\n        this.teams.clear();\n        this.dispatchEvent(new CustomEvent('teams:updated', {\n            detail: { teams: [] }\n        }));\n    }\n\n    /**\n     * Populate from session data (networked mode)\n     * Called on sync:full or session:update\n     * @param {Object} sessionData - Session object from backend\n     */\n    populateFromSession(sessionData) {\n        if (!sessionData) return;\n\n        // Clear existing and repopulate\n        this.teams.clear();\n\n        // Extract teams from session scores\n        if (sessionData.scores && Array.isArray(sessionData.scores)) {\n            sessionData.scores.forEach(scoreData => {\n                this.teams.set(scoreData.teamId, {\n                    teamId: scoreData.teamId,\n                    score: scoreData.currentScore || scoreData.score || 0,\n                    tokensScanned: scoreData.tokensScanned || 0,\n                    baseScore: scoreData.baseScore || 0,\n                    bonusPoints: scoreData.bonusPoints || 0\n                });\n            });\n        }\n\n        // Also check for teams array (some events have this)\n        if (sessionData.teams && Array.isArray(sessionData.teams)) {\n            sessionData.teams.forEach(teamId => {\n                if (!this.teams.has(teamId)) {\n                    this.teams.set(teamId, {\n                        teamId,\n                        score: 0,\n                        tokensScanned: 0\n                    });\n                }\n            });\n        }\n\n        this.dispatchEvent(new CustomEvent('teams:updated', {\n            detail: { teams: this.getTeams() }\n        }));\n    }\n\n    /**\n     * Populate from standalone session data\n     * Called when StandaloneDataManager loads session\n     * @param {Object} standaloneSessionData - Session object from localStorage\n     */\n    populateFromStandaloneSession(standaloneSessionData) {\n        if (!standaloneSessionData?.teams) return;\n\n        this.teams.clear();\n\n        Object.entries(standaloneSessionData.teams).forEach(([teamId, teamData]) => {\n            this.teams.set(teamId, {\n                teamId,\n                score: teamData.score || 0,\n                tokensScanned: teamData.tokensScanned || 0,\n                baseScore: teamData.baseScore || 0,\n                bonusPoints: teamData.bonusPoints || 0\n            });\n        });\n\n        this.dispatchEvent(new CustomEvent('teams:updated', {\n            detail: { teams: this.getTeams() }\n        }));\n    }\n\n    /**\n     * Populate a select element with team options\n     * Used for dropdown UI\n     * @param {HTMLSelectElement} selectElement - Select element to populate\n     * @param {Object} [options={}] - Options\n     * @param {string} [options.placeholder='Select Team...'] - Placeholder text\n     * @param {string} [options.selectedTeamId] - Currently selected team ID\n     */\n    populateDropdown(selectElement, options = {}) {\n        if (!selectElement) return;\n\n        const { placeholder = 'Select Team...', selectedTeamId = null } = options;\n\n        // Clear existing options\n        selectElement.innerHTML = '';\n\n        // Add placeholder option\n        const placeholderOption = document.createElement('option');\n        placeholderOption.value = '';\n        placeholderOption.textContent = placeholder;\n        placeholderOption.disabled = true;\n        placeholderOption.selected = !selectedTeamId;\n        selectElement.appendChild(placeholderOption);\n\n        // Add team options\n        const teams = this.getTeams().sort((a, b) =>\n            a.teamId.localeCompare(b.teamId)\n        );\n\n        teams.forEach(team => {\n            const option = document.createElement('option');\n            option.value = team.teamId;\n            option.textContent = team.teamId;\n            if (team.teamId === selectedTeamId) {\n                option.selected = true;\n            }\n            selectElement.appendChild(option);\n        });\n    }\n\n    // ============================================================================\n    // UNIFIED API - Mode-agnostic team operations\n    // ============================================================================\n\n    /**\n     * Select/create a team - UNIFIED API\n     * Standalone: Adds to localStorage recent history\n     * Networked: Sends session:addTeam if new, then selects\n     * @param {string} teamName\n     * @returns {Promise<{success: boolean, error?: string}>}\n     */\n    async selectTeam(teamName) {\n        if (!teamName?.trim()) {\n            return { success: false, error: 'Team name required' };\n        }\n\n        const normalized = teamName.trim();\n\n        if (this.sessionModeManager?.isStandalone()) {\n            // Standalone: track in recent history\n            this._addToRecentTeams(normalized);\n            return { success: true };\n        } else {\n            // Networked: create on backend if new\n            if (!this.hasTeam(normalized)) {\n                const result = await this._createTeamOnBackend(normalized);\n                if (!result.success) return result;\n            }\n            return { success: true };\n        }\n    }\n\n    /**\n     * Get teams for display - UNIFIED API\n     * Standalone: Returns recent teams from localStorage\n     * Networked: Returns teams from session (internal Map)\n     * @returns {Array<string>} Team names\n     */\n    getTeamsForDisplay() {\n        if (this.sessionModeManager?.isStandalone()) {\n            return this._getRecentTeams();\n        } else {\n            return this.getTeams().map(t => t.teamId);\n        }\n    }\n\n    /**\n     * Get label for team list - UNIFIED API\n     * @returns {string} Label text\n     */\n    getTeamListLabel() {\n        return this.sessionModeManager?.isStandalone()\n            ? 'Recent Teams:'\n            : 'Session Teams:';\n    }\n\n    // ============================================================================\n    // PRIVATE: localStorage recent teams (standalone mode)\n    // ============================================================================\n\n    /**\n     * Get recent teams from localStorage\n     * @returns {Array<string>} Recent team names (most recent first)\n     * @private\n     */\n    _getRecentTeams() {\n        try {\n            return JSON.parse(localStorage.getItem('aln_recent_teams') || '[]');\n        } catch {\n            return [];\n        }\n    }\n\n    /**\n     * Add team to recent history in localStorage\n     * Keeps max 10 teams, dedupes, most-recent-first\n     * @param {string} teamName\n     * @private\n     */\n    _addToRecentTeams(teamName) {\n        const recent = this._getRecentTeams().filter(t => t !== teamName);\n        recent.unshift(teamName);\n        const limited = recent.slice(0, 10);\n        localStorage.setItem('aln_recent_teams', JSON.stringify(limited));\n    }\n\n    // ============================================================================\n    // PRIVATE: Backend team creation (networked mode)\n    // ============================================================================\n\n    /**\n     * Create team on backend via session:addTeam command\n     * @param {string} teamName\n     * @returns {Promise<{success: boolean, error?: string}>}\n     * @private\n     */\n    async _createTeamOnBackend(teamName) {\n        if (!this.orchestratorClient) {\n            return { success: false, error: 'Not connected' };\n        }\n\n        try {\n            const response = await this.orchestratorClient.sendCommand(\n                'session:addTeam',\n                { teamId: teamName }\n            );\n\n            if (response.success) {\n                this.addTeam(teamName); // Update local registry\n                return { success: true };\n            } else {\n                return { success: false, error: response.message || 'Failed to create team' };\n            }\n        } catch (e) {\n            return { success: false, error: e.message };\n        }\n    }\n}\n\n// Export class (instance created in main.js)\nexport default TeamRegistry;\nexport { TeamRegistry };\n","/**\n * NFC Handler Module\n * Manages NFC scanning using Web NFC API\n * ES6 Module Export\n */\n\nimport Debug from './debug.js';\n\nclass NFCHandlerClass {\n  constructor() {\n    this.reader = null;\n    this.isScanning = false;\n    this.lastRead = null;       // { id: string, timestamp: number }\n    this.debounceMs = 2000;     // Ignore same tag within 2 seconds\n  }\n\n  /**\n   * Initialize NFC and check for support\n   * @returns {Promise<boolean>} Whether NFC is supported\n   */\n  async init() {\n    return 'NDEFReader' in window;\n  }\n\n  /**\n   * Start NFC scanning\n   * @param {Function} onRead - Callback for successful reads\n   * @param {Function} onError - Callback for errors\n   */\n  async startScan(onRead, onError) {\n    if (!('NDEFReader' in window)) {\n      throw new Error('NFC not supported');\n    }\n\n    try {\n      this.reader = new NDEFReader();\n\n      // CRITICAL: Attach event listeners BEFORE calling scan()\n      // Otherwise events may fire before listeners are registered\n      this.reader.addEventListener(\"reading\", ({ message, serialNumber }) => {\n        try {\n          const result = this.extractTokenId(message, serialNumber);\n          const now = Date.now();\n\n          // Debounce check - use tokenId for success, serialNumber for errors\n          const debounceKey = result.id || serialNumber;\n          if (debounceKey) {\n            if (this.lastRead &&\n                this.lastRead.id === debounceKey &&\n                (now - this.lastRead.timestamp) < this.debounceMs) {\n              Debug.log(`Debounced duplicate ${result.id ? 'read' : 'error'}: ${debounceKey}`);\n              return; // Silently ignore\n            }\n\n            // Update last read\n            this.lastRead = { id: debounceKey, timestamp: now };\n          }\n\n          onRead(result);\n        } catch (error) {\n          console.error('Exception in NFC reading handler:', error);\n          Debug.log(`Exception in NFC reading handler: ${error.message}`, true);\n        }\n      });\n\n      this.reader.addEventListener(\"readingerror\", (event) => {\n        Debug.log(`NFC Read Error: ${event}`, true);\n        if (onError) onError(event);\n      });\n\n      // NOW start scanning - listeners are ready to catch events\n      await this.reader.scan();\n      this.isScanning = true;\n\n    } catch (error) {\n      Debug.log(`Error starting NFC: ${error.message}`, true);\n      throw error;\n    }\n  }\n\n  /**\n   * Extract token ID from NFC message\n   * Uses Web NFC API's built-in NDEF parsing\n   * @param {NDEFMessage} message - NFC message\n   * @param {string} serialNumber - Tag serial number\n   * @returns {Object} Token ID and metadata, or error object\n   */\n  extractTokenId(message, serialNumber) {\n    Debug.log('‚ïê‚ïê‚ïê NFC TAG DETECTED ‚ïê‚ïê‚ïê');\n    Debug.log(`Serial: ${serialNumber}`);\n    Debug.log(`Records: ${message.records?.length || 0}`);\n\n    // No records? Return error instead of serial fallback\n    if (!message.records || message.records.length === 0) {\n      Debug.log('No NDEF records found - returning error');\n      return {\n        id: null,\n        source: 'error',\n        error: 'no-ndef-records',\n        raw: serialNumber\n      };\n    }\n\n    // Process records using the Web NFC API\n    for (const record of message.records) {\n      Debug.log(`Record type: ${record.recordType}`);\n\n      if (record.recordType === \"text\") {\n        const decoder = new TextDecoder(record.encoding || \"utf-8\");\n        const text = decoder.decode(record.data);\n        Debug.log(`‚úÖ Text record: ${text}`);\n        return {\n          id: text.trim(),\n          source: 'text-record',\n          raw: text\n        };\n      }\n\n      if (record.recordType === \"url\") {\n        const decoder = new TextDecoder();\n        const url = decoder.decode(record.data);\n        Debug.log(`‚úÖ URL record: ${url}`);\n        return {\n          id: url,\n          source: 'url-record',\n          raw: url\n        };\n      }\n\n      // Try generic text decoding for other types\n      if (record.data) {\n        try {\n          const text = new TextDecoder().decode(record.data);\n          if (text && text.trim()) {\n            Debug.log(`‚úÖ Generic decode: ${text}`);\n            return {\n              id: text.trim(),\n              source: 'generic-decode',\n              raw: text\n            };\n          }\n        } catch (e) {\n          Debug.log(`Decode failed: ${e.message}`);\n        }\n      }\n    }\n\n    // No readable records? Return error instead of serial fallback\n    Debug.log('No readable records found - returning error');\n    return {\n      id: null,\n      source: 'error',\n      error: 'unreadable-records',\n      raw: serialNumber\n    };\n  }\n\n  /**\n   * Stop NFC scanning\n   * Note: Web NFC doesn't have explicit stop - scan continues until page closes\n   */\n  stopScan() {\n    this.isScanning = false;\n  }\n\n  /**\n   * Simulate NFC scan for testing\n   * @returns {Object} Simulated token data\n   */\n  simulateScan() {\n    const testIds = [\n      'a1b2c3d4',\n      'deadbeef',\n      'cafe1234',\n      'babe2468',\n      'feed5678',\n      'unknown_' + Math.random().toString(36).substr(2, 9)\n    ];\n    const randomId = testIds[Math.floor(Math.random() * testIds.length)];\n\n    return {\n      id: randomId,\n      source: 'simulated',\n      raw: randomId\n    };\n  }\n}\n\n// Create singleton instance\nconst NFCHandler = new NFCHandlerClass();\n\nexport default NFCHandler;\nexport { NFCHandlerClass };\n","/**\n * StateValidationService - Validates system state before mode restoration\n *\n * Problem solved: Users must clear cache when reconnecting after session ends.\n * This service validates the entire system state before restoring networked mode,\n * ensuring a clean UX without manual cache clearing.\n *\n * Validation checks:\n * 1. JWT token exists and is not expired (with 1-minute buffer)\n * 2. Orchestrator is reachable (GET /health)\n * 3. Session exists on backend (GET /api/session)\n *\n * If ANY check fails, the service signals that stale state should be cleared\n * and the user should be shown the mode selection screen.\n */\n\nimport Debug from '../utils/debug.js';\n\n/**\n * @typedef {Object} ValidationResult\n * @property {boolean} valid - True if all validations passed\n * @property {string|null} reason - Failure reason (null if valid)\n * @property {Object} details - Detailed validation results\n * @property {boolean} details.tokenValid - JWT token is valid\n * @property {boolean} details.orchestratorReachable - Backend health check passed\n * @property {boolean} details.sessionExists - Backend has active session\n */\n\nclass StateValidationService {\n  /**\n   * @param {Object} options - Configuration options\n   * @param {number} [options.timeout=5000] - Request timeout in ms\n   */\n  constructor(options = {}) {\n    this.timeout = options.timeout || 5000;\n  }\n\n  /**\n   * Validate all system state for networked mode restoration\n   *\n   * @param {string} orchestratorUrl - Backend URL (e.g., \"https://10.0.0.1:3000\")\n   * @returns {Promise<ValidationResult>} Validation result\n   */\n  async validateAll(orchestratorUrl) {\n    Debug.log('[StateValidation] Starting full validation...');\n\n    const result = {\n      valid: false,\n      reason: null,\n      details: {\n        tokenValid: false,\n        orchestratorReachable: false,\n        sessionExists: false\n      }\n    };\n\n    // 1. Validate JWT token\n    const token = localStorage.getItem('aln_auth_token');\n    if (!token) {\n      result.reason = 'No authentication token found';\n      Debug.log(`[StateValidation] FAIL: ${result.reason}`);\n      return result;\n    }\n\n    if (!this.isTokenValid(token)) {\n      result.reason = 'Authentication token expired';\n      Debug.log(`[StateValidation] FAIL: ${result.reason}`);\n      return result;\n    }\n    result.details.tokenValid = true;\n    Debug.log('[StateValidation] Token valid');\n\n    // 2. Validate orchestrator reachability\n    if (!orchestratorUrl) {\n      result.reason = 'No orchestrator URL configured';\n      Debug.log(`[StateValidation] FAIL: ${result.reason}`);\n      return result;\n    }\n\n    const healthOk = await this.checkOrchestratorHealth(orchestratorUrl);\n    if (!healthOk) {\n      result.reason = 'Orchestrator unreachable';\n      Debug.log(`[StateValidation] FAIL: ${result.reason}`);\n      return result;\n    }\n    result.details.orchestratorReachable = true;\n    Debug.log('[StateValidation] Orchestrator reachable');\n\n    // 3. Validate session exists\n    const sessionExists = await this.checkSessionExists(orchestratorUrl);\n    if (!sessionExists) {\n      result.reason = 'No active session on orchestrator';\n      Debug.log(`[StateValidation] FAIL: ${result.reason}`);\n      return result;\n    }\n    result.details.sessionExists = true;\n    Debug.log('[StateValidation] Session exists');\n\n    // All validations passed\n    result.valid = true;\n    Debug.log('[StateValidation] All validations PASSED');\n    return result;\n  }\n\n  /**\n   * Check if JWT token is valid (not expired, with 1-minute buffer)\n   * @param {string} token - JWT token string\n   * @returns {boolean} True if valid\n   */\n  isTokenValid(token) {\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) return false;\n\n      // Use atob for browser, Buffer for Node.js (tests)\n      const decode = typeof atob !== 'undefined'\n        ? (str) => atob(str)\n        : (str) => Buffer.from(str, 'base64').toString();\n\n      const payload = JSON.parse(decode(parts[1]));\n      const expiry = payload.exp;\n      if (!expiry) return false;\n\n      const now = Math.floor(Date.now() / 1000);\n      const buffer = 60; // 1-minute safety buffer\n      return (expiry - buffer) > now;\n    } catch (error) {\n      Debug.log(`[StateValidation] Token parse error: ${error.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * Check if orchestrator is reachable via health endpoint\n   * @param {string} orchestratorUrl - Backend URL\n   * @returns {Promise<boolean>} True if reachable\n   */\n  async checkOrchestratorHealth(orchestratorUrl) {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n      const response = await fetch(`${orchestratorUrl}/health`, {\n        method: 'GET',\n        signal: controller.signal\n      });\n\n      clearTimeout(timeoutId);\n      return response.ok;\n    } catch (error) {\n      Debug.log(`[StateValidation] Health check error: ${error.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * Check if session exists on backend\n   * @param {string} orchestratorUrl - Backend URL\n   * @returns {Promise<boolean>} True if session exists\n   */\n  async checkSessionExists(orchestratorUrl) {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n      const response = await fetch(`${orchestratorUrl}/api/session`, {\n        method: 'GET',\n        signal: controller.signal\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        return false;\n      }\n\n      const data = await response.json();\n      // Session exists if we get a valid session object (not null/empty)\n      return !!(data && data.id);\n    } catch (error) {\n      Debug.log(`[StateValidation] Session check error: ${error.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * Clear all stale state from localStorage\n   * Called when validation fails to ensure clean state\n   */\n  clearStaleState() {\n    Debug.log('[StateValidation] Clearing stale state...');\n\n    // Clear auth token\n    localStorage.removeItem('aln_auth_token');\n\n    // Clear saved orchestrator URL (optional - user might want to keep this)\n    // localStorage.removeItem('aln_orchestrator_url');\n\n    // Clear game session mode\n    localStorage.removeItem('aln_game_session_mode');\n\n    // Clear any cached session data\n    localStorage.removeItem('aln_session_data');\n\n    Debug.log('[StateValidation] Stale state cleared');\n  }\n}\n\n// Export singleton instance and class\nconst stateValidationService = new StateValidationService();\nexport { StateValidationService };\nexport default stateValidationService;\n","/**\n * Initialization Steps - Application Bootstrap Sequence\n * ES6 Module\n *\n * Provides 11-phase initialization sequence for ALNScanner application.\n * Coordinates loading of all app modules with proper dependency ordering.\n *\n * Phase 0: Show loading screen\n * Phase 1A: Token Database Loading\n * Phase 1B: URL Parameter Mode Override\n * Phase 1C: Connection Restoration Logic (with State Validation)\n * Phase 1D: Initialize UIManager\n * Phase 1E: Create SessionModeManager\n * Phase 1F: Initialize view controller\n * Phase 1G: Load settings\n * Phase 1H: Load DataManager\n * Phase 1I: Detect NFC support\n * Phase 1J: Register service worker\n */\n\nimport Debug from '../utils/debug.js';\nimport stateValidationService from '../services/StateValidationService.js';\n\n/**\n * Initialize UIManager\n * Simple wrapper for UIManager.init()\n *\n * @param {Object} uiManager - UIManager instance\n */\nexport function initializeUIManager(uiManager) {\n  uiManager.init();\n}\n\n/**\n * Create SessionModeManager singleton\n * Returns instance for storage on app object (no window global assignment)\n * CRITICAL: Must be called before viewController.init()\n *\n * @param {Function} SessionModeManagerClass - SessionModeManager constructor\n * @returns {Object} The created SessionModeManager instance\n */\nexport function createSessionModeManager(SessionModeManagerClass) {\n  const instance = new SessionModeManagerClass();\n  Debug.log('SessionModeManager initialized');\n  return instance;\n}\n\n/**\n * Initialize view controller\n * Depends on window.sessionModeManager existing\n *\n * @param {Object} viewController - ViewController instance\n */\nexport function initializeViewController(viewController) {\n  viewController.init();\n}\n\n/**\n * Load settings from localStorage\n *\n * @param {Object} settings - Settings object\n */\nexport function loadSettings(settings) {\n  settings.load();\n}\n\n/**\n * Initialize DataManager (no data loading)\n *\n * CRITICAL: Don't load transactions from localStorage on initialization.\n * Backend is the authoritative source for all modes:\n * - Networked: sync:full provides ALL transactions (MonitoringDisplay.updateAllDisplays)\n * - Standalone: loadLocalSession() restores same-day session\n *\n * This prevents phantom data from old sessions while ensuring complete\n * state restoration from backend after page refresh.\n *\n * @param {Object} dataManager - DataManager instance\n * @param {Object} uiManager - UIManager instance\n */\nexport function loadDataManager(dataManager, uiManager) {\n  // No data loading - sync:full will populate everything\n  // Initialize UI with empty state\n  uiManager.updateHistoryBadge();\n}\n\n/**\n * Detect NFC support\n *\n * @param {Object} nfcHandler - NFCHandler instance\n * @returns {Promise<boolean>} True if NFC is supported\n */\nexport async function detectNFCSupport(nfcHandler) {\n  const supported = await nfcHandler.init();\n  Debug.log(`NFC support: ${supported}`);\n  return supported;\n}\n\n/**\n * Register service worker for PWA functionality\n *\n * @param {Object} navigatorObj - Navigator object\n * @param {Object} uiManager - UIManager instance\n * @returns {Promise<boolean>} True if registration succeeded\n */\nexport async function registerServiceWorker(navigatorObj, uiManager) {\n  if (!('serviceWorker' in navigatorObj)) {\n    return false;\n  }\n\n  try {\n    // Use dynamic base path to support orchestrator subdirectory serving\n    // If served from https://IP:3000/gm-scanner/, this resolves to /gm-scanner/sw.js\n    // If served locally, resolves to /sw.js or ./sw.js\n    const swPath = new URL('sw.js', window.location.href).pathname;\n\n    const registration = await navigatorObj.serviceWorker.register(swPath);\n    Debug.log('Service Worker registered successfully');\n    console.log('Service Worker registration successful:', registration.scope);\n    return true;\n  } catch (error) {\n    // Check if this is an SSL certificate error (expected with self-signed certs)\n    const isSSLError = error.name === 'SecurityError' &&\n      error.message.includes('SSL certificate error');\n\n    if (isSSLError) {\n      // SSL errors are expected when using self-signed certificates\n      // Service Worker provides offline PWA functionality, not critical for networked mode\n      Debug.log('Service Worker registration skipped due to SSL certificate (self-signed cert)');\n      console.warn('Service Worker not available due to self-signed certificate. Offline features disabled.');\n      return false;\n    } else {\n      // Other errors should still be reported\n      Debug.log('Service Worker registration failed');\n      console.error('Service Worker registration failed:', error);\n      uiManager.showError('Service Worker registration failed. Offline features may not work.');\n      return false;\n    }\n  }\n}\n\n/**\n * Load token database from TokenManager\n *\n * @param {Object} tokenManager - TokenManager instance\n * @param {Object} uiManager - UIManager instance\n * @returns {Promise<boolean>} True if database loaded successfully\n * @throws {Error} If database load fails\n */\nexport async function loadTokenDatabase(tokenManager, uiManager) {\n  const dbLoaded = await tokenManager.loadDatabase();\n\n  if (!dbLoaded) {\n    const errorMsg = 'CRITICAL: Token database failed to load. Cannot initialize scanner.';\n    Debug.log(errorMsg, true);\n    uiManager.showError(errorMsg);\n    throw new Error('Token database initialization failed');\n  }\n\n  Debug.log('Token database loaded successfully');\n  return true;\n}\n\n/**\n * Apply URL parameter mode override\n * Checks for ?mode=blackmarket or ?mode=black-market and sets station mode\n *\n * @param {string} locationSearch - window.location.search (query string)\n * @param {Object} settings - Settings object with mode and save()\n * @returns {boolean} True if mode was applied, false otherwise\n */\nexport function applyURLModeOverride(locationSearch, settings) {\n  const urlParams = new URLSearchParams(locationSearch);\n  const modeParam = urlParams.get('mode');\n\n  if (modeParam === 'blackmarket' || modeParam === 'black-market') {\n    settings.mode = 'blackmarket';\n    settings.save();\n    Debug.log('Station mode set to blackmarket via URL parameter');\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Determine initial screen based on connection restoration logic\n * Pure function - no side effects, only decision logic\n *\n * NOTE: For networked mode, use validateAndDetermineInitialScreen() instead\n * to perform full state validation (token + orchestrator + session).\n *\n * @param {Object} sessionModeManager - SessionModeManager instance\n * @returns {Object} Decision object with {screen, action, savedMode}\n */\nexport function determineInitialScreen(sessionModeManager) {\n  const savedMode = sessionModeManager.restoreMode();\n\n  // Case 1: No saved mode (first-time user)\n  if (!savedMode) {\n    return { screen: 'gameModeScreen', action: null, savedMode: null };\n  }\n\n  // Case 2: Standalone mode - initialize and go to team entry\n  if (savedMode === 'standalone') {\n    return { screen: 'teamEntry', action: 'initStandalone', savedMode };\n  }\n\n  // Case 3: Networked mode - check if we have valid token for auto-connect\n  if (savedMode === 'networked') {\n    const token = localStorage.getItem('aln_auth_token');\n\n    if (token && isTokenValid(token)) {\n      // Valid token - try auto-connect\n      return { screen: 'loading', action: 'autoConnect', savedMode };\n    } else {\n      // No valid token - need to show wizard\n      return { screen: 'gameModeScreen', action: 'clearModeAndShowWizard', savedMode };\n    }\n  }\n\n  // Fallback\n  return { screen: 'gameModeScreen', action: null, savedMode: null };\n}\n\n/**\n * Validate system state and determine initial screen for networked mode\n * Async version that performs full validation before deciding action.\n *\n * Phase 4.1 enhancement: Validates orchestrator + session in addition to token.\n * If any validation fails, clears stale state and shows mode selection screen.\n *\n * @param {Object} sessionModeManager - SessionModeManager instance\n * @returns {Promise<Object>} Decision object with {screen, action, savedMode, validationResult}\n */\nexport async function validateAndDetermineInitialScreen(sessionModeManager) {\n  const savedMode = sessionModeManager.restoreMode();\n\n  // Case 1: No saved mode (first-time user)\n  if (!savedMode) {\n    return { screen: 'gameModeScreen', action: null, savedMode: null, validationResult: null };\n  }\n\n  // Case 2: Standalone mode - no validation needed\n  if (savedMode === 'standalone') {\n    return { screen: 'teamEntry', action: 'initStandalone', savedMode, validationResult: null };\n  }\n\n  // Case 3: Networked mode - perform full validation\n  if (savedMode === 'networked') {\n    const orchestratorUrl = localStorage.getItem('aln_orchestrator_url');\n\n    // Validate full system state: token + orchestrator + session\n    Debug.log('[InitSteps] Performing full state validation for networked mode...');\n    const validationResult = await stateValidationService.validateAll(orchestratorUrl);\n\n    if (validationResult.valid) {\n      // All validations passed - try auto-connect\n      Debug.log('[InitSteps] Validation passed - attempting auto-connect');\n      return { screen: 'loading', action: 'autoConnect', savedMode, validationResult };\n    } else {\n      // Validation failed - clear stale state and show wizard\n      Debug.log(`[InitSteps] Validation failed: ${validationResult.reason}`);\n      stateValidationService.clearStaleState();\n      return {\n        screen: 'gameModeScreen',\n        action: 'clearModeAndShowWizard',\n        savedMode,\n        validationResult\n      };\n    }\n  }\n\n  // Fallback\n  return { screen: 'gameModeScreen', action: null, savedMode: null, validationResult: null };\n}\n\n/**\n * Check if JWT token is valid (not expired, with 1-minute buffer)\n * @param {string} token - JWT token string\n * @returns {boolean} True if valid\n * @private\n */\nfunction isTokenValid(token) {\n  try {\n    const parts = token.split('.');\n    if (parts.length !== 3) return false;\n\n    // Use atob for browser, Buffer for Node.js\n    let decode;\n    if (typeof atob !== 'undefined') {\n      decode = (str) => atob(str);\n    } else if (typeof Buffer !== 'undefined') {\n      decode = (str) => Buffer.from(str, 'base64').toString();\n    } else {\n      // Fallback or fail if neither is available\n      return false;\n    }\n\n    const payload = JSON.parse(decode(parts[1]));\n    const expiry = payload.exp;\n    if (!expiry) return false;\n\n    const now = Math.floor(Date.now() / 1000);\n    const buffer = 60; // 1-minute safety buffer\n    return (expiry - buffer) > now;\n  } catch (error) {\n    console.error('Token validation error:', error);\n    return false;\n  }\n}\n\n/**\n * Apply initial screen decision (executes side effects)\n * Handles UI changes, mode clearing, wizard display, and auto-connect\n *\n * @param {Object} decision - Decision from determineInitialScreen()\n * @param {Object} sessionModeManager - SessionModeManager instance\n * @param {Object} uiManager - UIManager instance\n * @param {Function} showWizardFn - showConnectionWizard function\n * @param {Function} initNetworkedModeFn - Async function to initialize networked mode (from app._initializeNetworkedMode)\n */\nexport async function applyInitialScreenDecision(decision, sessionModeManager, uiManager, showWizardFn, initNetworkedModeFn = null) {\n  Debug.log(`Applying screen decision: screen=${decision.screen}, action=${decision.action}`);\n\n  if (decision.action === 'clearModeAndShowWizard') {\n    // Networked mode restored but no valid token - clear and show wizard\n    Debug.log('Networked mode restored but no valid token - showing wizard');\n    sessionModeManager.clearMode();\n    uiManager.showScreen(decision.screen);\n    showWizardFn();\n\n  } else if (decision.action === 'initStandalone') {\n    // Standalone mode - lock mode and show team entry\n    Debug.log('Restoring standalone mode');\n    sessionModeManager.setMode('standalone');\n    uiManager.showScreen(decision.screen);\n\n  } else if (decision.action === 'autoConnect') {\n    // Networked mode with valid token - attempt auto-connect\n    Debug.log('Valid token found - attempting auto-connect');\n    uiManager.showScreen(decision.screen); // Show loading screen\n\n    try {\n      // Lock networked mode and initialize NetworkedSession\n      sessionModeManager.setMode('networked');\n\n      if (initNetworkedModeFn) {\n        await initNetworkedModeFn();\n        Debug.log('Auto-connect successful - showing team entry');\n        uiManager.showScreen('teamEntry');\n      } else {\n        throw new Error('initNetworkedModeFn not provided for auto-connect');\n      }\n    } catch (error) {\n      Debug.log('Auto-connect failed - showing wizard');\n      console.error('Auto-connect error:', error);\n      sessionModeManager.clearMode();\n      uiManager.showScreen('gameModeScreen');\n      showWizardFn();\n    }\n\n  } else {\n    // Simple screen change, no special action needed\n    Debug.log(`Showing initial screen: ${decision.screen}`);\n    uiManager.showScreen(decision.screen);\n  }\n}\n\n/**\n * Show loading screen with paint delay\n * Ensures loading screen is visible before JavaScript continues executing\n *\n * @param {Object} uiManager - UIManager instance\n * @returns {Promise<void>}\n */\nexport async function showLoadingScreen(uiManager) {\n  uiManager.showScreen('loading');\n  // Ensure browser paints the loading screen before continuing\n  await new Promise(resolve => setTimeout(resolve, 100));\n  Debug.log('Loading screen displayed');\n}\n\n// Default export for convenience\nexport default {\n  initializeUIManager,\n  createSessionModeManager,\n  initializeViewController,\n  loadSettings,\n  loadDataManager,\n  detectNFCSupport,\n  registerServiceWorker,\n  loadTokenDatabase,\n  applyURLModeOverride,\n  determineInitialScreen,\n  validateAndDetermineInitialScreen,\n  applyInitialScreenDecision,\n  showLoadingScreen\n};\n","/**\n * SessionModeManager - Mode Locking and Persistence\n * ES6 Module - Simple State Manager\n *\n * Manages the dual operation modes (networked/standalone) with locking mechanism.\n * Once a mode is set, it cannot be changed until page reload.\n *\n * Key responsibilities:\n * - Mode locking (networked vs standalone)\n * - Mode persistence (localStorage)\n * - Mode detection and validation\n *\n * Does NOT:\n * - Initialize networked sessions (that's NetworkedSession's job)\n * - Handle UI (that's UIManager's job)\n * - Manage connections (that's ConnectionManager's job)\n */\n\nexport class SessionModeManager {\n  constructor() {\n    this.mode = null; // 'networked' | 'standalone' | null\n    this.locked = false; // Once set, cannot change during session\n  }\n\n  /**\n   * Set the session mode and lock it\n   * @param {string} mode - 'networked' or 'standalone'\n   * @throws {Error} If mode is already locked or invalid mode provided\n   */\n  setMode(mode) {\n    if (this.locked) {\n      throw new Error('Cannot change session mode after it is locked');\n    }\n\n    if (mode !== 'networked' && mode !== 'standalone') {\n      throw new Error(`Invalid session mode: ${mode}. Must be 'networked' or 'standalone'`);\n    }\n\n    this.mode = mode;\n    this.locked = true;\n    this._persistMode(mode);\n  }\n\n  /**\n   * Check if current mode is networked\n   * @returns {boolean}\n   */\n  isNetworked() {\n    return this.mode === 'networked';\n  }\n\n  /**\n   * Check if current mode is standalone\n   * @returns {boolean}\n   */\n  isStandalone() {\n    return this.mode === 'standalone';\n  }\n\n  /**\n   * Restore mode from localStorage without locking\n   * Allows user to change mode on fresh start\n   * @returns {string|null} Restored mode or null\n   */\n  restoreMode() {\n    const savedMode = this._getPersistedMode();\n    if (savedMode && (savedMode === 'networked' || savedMode === 'standalone')) {\n      this.mode = savedMode;\n      // Don't lock it yet - allow user to change on fresh start\n      return savedMode;\n    }\n    return null;\n  }\n\n  /**\n   * Clear the current mode and unlock\n   * Removes mode from localStorage\n   */\n  clearMode() {\n    this.mode = null;\n    this.locked = false;\n    this._clearPersistedMode();\n  }\n\n  /**\n   * Get the current mode\n   * @returns {string|null}\n   */\n  getMode() {\n    return this.mode;\n  }\n\n  /**\n   * Check if mode is locked\n   * @returns {boolean}\n   */\n  isLocked() {\n    return this.locked;\n  }\n\n  /**\n   * Persist mode to localStorage\n   * @private\n   */\n  _persistMode(mode) {\n    try {\n      localStorage.setItem('gameSessionMode', mode);\n    } catch (error) {\n      console.error('Failed to persist session mode:', error);\n    }\n  }\n\n  /**\n   * Get persisted mode from localStorage\n   * @private\n   * @returns {string|null}\n   */\n  _getPersistedMode() {\n    try {\n      return localStorage.getItem('gameSessionMode');\n    } catch (error) {\n      console.error('Failed to read persisted session mode:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Clear persisted mode from localStorage\n   * @private\n   */\n  _clearPersistedMode() {\n    try {\n      localStorage.removeItem('gameSessionMode');\n    } catch (error) {\n      console.error('Failed to clear persisted session mode:', error);\n    }\n  }\n}\n\n// Create singleton instance\nconst sessionModeManager = new SessionModeManager();\n\n// Export both named class and singleton instance\nexport default sessionModeManager;\n","/**\n * OrchestratorClient - WebSocket Communication Layer\n * ES6 Module - Browser Only\n *\n * Responsibilities:\n * - Create/destroy Socket.io connection\n * - Send messages with AsyncAPI envelope wrapper\n * - Forward all received messages as events\n * - Clean connection lifecycle (connect, disconnect)\n *\n * Does NOT handle:\n * - Token validation (ConnectionManager)\n * - Retry logic (ConnectionManager)\n * - Reconnection handling (ConnectionManager)\n * - Health checks (ConnectionManager)\n * - Message processing (consumers listen to events)\n * - Admin module initialization (AdminController)\n */\n\nexport class OrchestratorClient extends EventTarget {\n  constructor(config = {}) {\n    super();\n\n    this.config = {\n      url: config.url || 'https://localhost:3000',\n      deviceId: config.deviceId || 'GM_STATION_UNKNOWN',\n      version: '1.0.0',\n      transports: ['websocket']\n    };\n\n    this.socket = null;\n    this.isConnected = false;\n    this.connectionTimeout = null; // Track timeout for cleanup\n  }\n\n  /**\n   * Connect to orchestrator WebSocket\n   * @param {string} token - JWT authentication token\n   * @param {Object} auth - Authentication payload { deviceId, deviceType }\n   * @returns {Promise<void>}\n   * @emits socket:connected - Connection established\n   * @emits socket:error - Connection failed\n   */\n  async connect(token, auth) {\n    // Cleanup old socket first (allows reconnection)\n    if (this.socket?.connected) {\n      console.warn('OrchestratorClient: Already connected, cleaning up old socket');\n    }\n\n    this._cleanup();\n\n    this.socket = io(this.config.url, {\n      transports: this.config.transports,\n      reconnection: false, // ConnectionManager handles reconnection\n      timeout: 10000,\n      auth: {\n        token: token,\n        deviceId: auth.deviceId,\n        deviceType: auth.deviceType,\n        version: this.config.version\n      }\n    });\n\n    this._setupSocketHandlers();\n\n    return new Promise((resolve, reject) => {\n      const onConnect = () => {\n        if (this.connectionTimeout) {\n          clearTimeout(this.connectionTimeout);\n          this.connectionTimeout = null;\n        }\n        // No need to manually remove 'once' listeners - they auto-remove after firing\n        this.isConnected = true;\n        this.dispatchEvent(new CustomEvent('socket:connected'));\n        resolve();\n      };\n\n      const onError = (error) => {\n        if (this.connectionTimeout) {\n          clearTimeout(this.connectionTimeout);\n          this.connectionTimeout = null;\n        }\n        // No need to manually remove 'once' listeners - they auto-remove after firing\n        this.dispatchEvent(new CustomEvent('socket:error', { detail: { error } }));\n        reject(error);\n      };\n\n      // Setup timeout handler\n      this.connectionTimeout = setTimeout(() => {\n        // Guard against socket being null (e.g., if destroy() called during connection)\n        if (this.socket) {\n          this.socket.off('connect', onConnect);\n          this.socket.off('connect_error', onError);\n        }\n        this.connectionTimeout = null;\n        reject(new Error('Connection timeout'));\n      }, 10000);\n\n      this.socket.once('connect', onConnect);\n      this.socket.once('connect_error', onError);\n    });\n  }\n\n  /**\n   * Send message to orchestrator with AsyncAPI envelope\n   * @param {string} eventType - Event name (e.g., 'transaction:submit')\n   * @param {Object} data - Event payload\n   * @throws {Error} If socket not connected\n   */\n  send(eventType, data) {\n    if (!this.socket?.connected) {\n      throw new Error('Socket not connected');\n    }\n\n    this.socket.emit(eventType, {\n      event: eventType,\n      data: data,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  /**\n   * Send gm:command and wait for acknowledgment\n   * Follows AsyncAPI contract for admin commands\n   *\n   * @param {string} action - Command action (e.g., 'session:addTeam')\n   * @param {Object} payload - Command payload\n   * @param {number} timeout - Timeout in ms (default 5000)\n   * @returns {Promise<{success: boolean, message: string}>}\n   * @throws {Error} If socket not connected or command times out\n   */\n  async sendCommand(action, payload = {}, timeout = 5000) {\n    if (!this.socket?.connected) {\n      throw new Error('Socket not connected');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        cleanup();\n        reject(new Error(`Command ${action} timed out`));\n      }, timeout);\n\n      const handler = (envelope) => {\n        const data = envelope.data || envelope;\n        if (data.action === action) {\n          cleanup();\n          resolve({\n            success: data.success,\n            message: data.message || ''\n          });\n        }\n      };\n\n      const cleanup = () => {\n        clearTimeout(timeoutId);\n        this.socket.off('gm:command:ack', handler);\n      };\n\n      this.socket.on('gm:command:ack', handler);\n\n      // Send with proper gm:command envelope (NOT raw action name)\n      this.socket.emit('gm:command', {\n        event: 'gm:command',\n        data: { action, payload },\n        timestamp: new Date().toISOString()\n      });\n    });\n  }\n\n  /**\n   * Disconnect from orchestrator\n   * @returns {Promise<void>}\n   * @emits socket:disconnected - Disconnection complete\n   */\n  async disconnect() {\n    if (!this.socket) return;\n\n    return new Promise((resolve) => {\n      if (!this.socket.connected) {\n        this._cleanup();\n        resolve();\n        return;\n      }\n\n      this.socket.once('disconnect', (reason) => {\n        this.dispatchEvent(new CustomEvent('socket:disconnected', { detail: { reason } }));\n        this._cleanup();\n        resolve();\n      });\n\n      this.socket.disconnect();\n\n      // Timeout fallback\n      setTimeout(() => {\n        this._cleanup();\n        resolve();\n      }, 1000);\n    });\n  }\n\n  /**\n   * Destroy client (cleanup without graceful disconnect)\n   */\n  destroy() {\n    this._cleanup();\n  }\n\n  /**\n   * Setup Socket.io event handlers\n   * @private\n   */\n  _setupSocketHandlers() {\n    if (!this.socket) return;\n\n    // Connection lifecycle events\n    this.socket.on('connect', () => {\n      this.isConnected = true;\n      this.dispatchEvent(new CustomEvent('socket:connected'));\n    });\n\n    this.socket.on('disconnect', (reason) => {\n      this.isConnected = false;\n      this.dispatchEvent(new CustomEvent('socket:disconnected', { detail: { reason } }));\n    });\n\n    this.socket.on('connect_error', (error) => {\n      this.dispatchEvent(new CustomEvent('socket:error', { detail: { error } }));\n    });\n\n    // Forward all AsyncAPI message types\n\n    this._setupMessageHandlers();\n  }\n\n  /**\n   * Setup message forwarding for all AsyncAPI event types\n   * @private\n   */\n  _setupMessageHandlers() {\n    const messageTypes = [\n      'sync:full',\n      'transaction:result',\n      'transaction:new',\n      'transaction:deleted',\n      'score:updated',\n      'scores:reset',\n      'video:status',\n      'session:update',\n      'session:overtime',\n      'device:connected',\n      'device:disconnected',\n      'group:completed',\n      'display:mode',  // Phase 4.2: Display control events\n      'gm:command:ack',\n      'offline:queue:processed',\n      'batch:ack',\n      'error',\n      'player:scan'  // Phase 3: Unified Game Activity - player scan broadcasts\n    ];\n\n    messageTypes.forEach(type => {\n      this.socket.on(type, (envelope) => {\n        // Extract payload from AsyncAPI envelope\n        const payload = envelope.data || envelope;\n\n\n\n        // Forward as generic message:received event\n        this.dispatchEvent(new CustomEvent('message:received', {\n          detail: { type, payload }\n        }));\n      });\n    });\n  }\n\n  /**\n   * Cleanup socket and listeners\n   * @private\n   */\n  _cleanup() {\n    // Clear connection timeout if still pending\n    if (this.connectionTimeout) {\n      clearTimeout(this.connectionTimeout);\n      this.connectionTimeout = null;\n    }\n\n    if (this.socket) {\n      this.socket.removeAllListeners();\n      if (this.socket.connected) {\n        this.socket.disconnect();\n      }\n      this.socket = null;\n    }\n    this.isConnected = false;\n  }\n}\n\n// Default export for convenience\nexport default OrchestratorClient;\n","/**\n * ConnectionManager - Connection Lifecycle Manager\n * ES6 Module - Browser Only\n *\n * Responsibilities:\n * - Token validation (JWT expiry check with 1-minute buffer)\n * - Health checks (orchestrator reachability)\n * - Retry logic with exponential backoff\n * - Reconnection handling (on server-initiated disconnect)\n * - Auth:required event emission (token expiry, max retries)\n *\n * Does NOT handle:\n * - WebSocket connection (OrchestratorClient)\n * - Message sending (OrchestratorClient)\n * - Message processing (consumers)\n * - Admin operations (AdminController)\n */\n\nimport OrchestratorClient from './orchestratorClient.js';\n\nexport class ConnectionManager extends EventTarget {\n  constructor(config = {}) {\n    super();\n\n    this.config = {\n      url: config.url || 'https://localhost:3000',\n      deviceId: config.deviceId || 'GM_STATION_UNKNOWN',\n      deviceType: 'gm'\n    };\n\n    this.client = config.client; // OrchestratorClient instance\n    this.token = config.token || null;\n    this.state = 'disconnected'; // disconnected, connecting, connected\n    this.retryCount = 0;\n    this.maxRetries = config.maxRetries || 5;\n    this.retryTimer = null;\n    this.disconnectHandler = null;\n\n    // Wire global connection status indicator updates\n    this.addEventListener('connecting', () => this._updateGlobalConnectionStatus('connecting'));\n    this.addEventListener('connected', () => this._updateGlobalConnectionStatus('connected'));\n    this.addEventListener('disconnected', () => this._updateGlobalConnectionStatus('disconnected'));\n  }\n\n  /**\n   * Validate JWT token expiry with 1-minute buffer\n   * @returns {boolean}\n   */\n  isTokenValid() {\n    if (!this.token) return false;\n\n    try {\n      // Parse JWT (format: header.payload.signature)\n      const parts = this.token.split('.');\n      if (parts.length !== 3) return false;\n\n      const payload = JSON.parse(atob(parts[1]));\n      const expiry = payload.exp; // Unix timestamp (seconds)\n\n      if (!expiry) return false;\n\n      // Check with 1-minute buffer\n      const now = Math.floor(Date.now() / 1000);\n      const buffer = 60; // 1 minute\n\n      return (expiry - buffer) > now;\n    } catch {\n      // Token parsing failed - consider invalid\n      return false;\n    }\n  }\n\n  /**\n   * Check orchestrator health\n   * @returns {Promise<boolean>}\n   */\n  async checkHealth() {\n    try {\n      const controller = new AbortController();\n      const timeout = setTimeout(() => controller.abort(), 5000);\n\n      const response = await fetch(`${this.config.url}/health`, {\n        method: 'GET',\n        mode: 'cors',\n        signal: controller.signal\n      });\n\n      clearTimeout(timeout);\n      return response.ok;\n    } catch {\n      // Health check failed - orchestrator unreachable\n      return false;\n    }\n  }\n\n  /**\n   * Connect to orchestrator\n   * @returns {Promise<void>}\n   * @emits connecting - Connection attempt started\n   * @emits connected - Connection established\n   * @emits auth:required - Token invalid/expired\n   * @throws {Error} If validation or connection fails\n   */\n  async connect() {\n    // Validate token\n    if (!this.isTokenValid()) {\n      this.dispatchEvent(new CustomEvent('auth:required', {\n        detail: { reason: 'invalid_token' }\n      }));\n      throw new Error('Invalid or expired token');\n    }\n\n    // Check health\n    const healthy = await this.checkHealth();\n    if (!healthy) {\n      throw new Error('Orchestrator unreachable');\n    }\n\n    // Clear any pending retry timer\n    this._clearRetryTimer();\n\n    // Update state\n    this.state = 'connecting';\n    this.dispatchEvent(new CustomEvent('connecting'));\n\n    try {\n      // Delegate WebSocket connection to OrchestratorClient\n      await this.client.connect(this.token, {\n        deviceId: this.config.deviceId,\n        deviceType: this.config.deviceType\n      });\n\n      // Connection successful\n      this.state = 'connected';\n      this.retryCount = 0;\n      this.dispatchEvent(new CustomEvent('connected'));\n\n      // Setup reconnection handler\n      this._setupReconnectionHandler();\n\n    } catch (error) {\n      this.state = 'disconnected';\n\n      // Schedule retry\n      this.retryCount++;\n      if (this.retryCount < this.maxRetries) {\n        this._scheduleRetry();\n      } else {\n        this.dispatchEvent(new CustomEvent('auth:required', {\n          detail: { reason: 'max_retries' }\n        }));\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Disconnect from orchestrator\n   * @returns {Promise<void>}\n   */\n  async disconnect() {\n    this._clearRetryTimer();\n    this._removeReconnectionHandler();\n\n    if (this.client) {\n      await this.client.disconnect();\n    }\n\n    this.state = 'disconnected';\n  }\n\n  /**\n   * Update authentication token\n   * @param {string} token - New JWT token\n   */\n  updateToken(token) {\n    this.token = token;\n  }\n\n  /**\n   * Setup reconnection handler for server-initiated disconnects\n   * @private\n   */\n  _setupReconnectionHandler() {\n    if (this.disconnectHandler) {\n      this._removeReconnectionHandler();\n    }\n\n    this.disconnectHandler = (event) => {\n      const reason = event.detail?.reason;\n\n      this.state = 'disconnected';\n      this.dispatchEvent(new CustomEvent('disconnected', { detail: { reason } }));\n\n      // Only auto-reconnect on server-initiated disconnect\n      if (reason === 'io server disconnect') {\n        // Check if token still valid\n        if (!this.isTokenValid()) {\n          this.dispatchEvent(new CustomEvent('auth:required', {\n            detail: { reason: 'token_expired' }\n          }));\n          return;\n        }\n\n        // Schedule reconnection\n        setTimeout(() => {\n          this.connect().catch(() => {\n            // Retry logic handles failures\n          });\n        }, 1000);\n      }\n    };\n\n    this.client.addEventListener('socket:disconnected', this.disconnectHandler);\n  }\n\n  /**\n   * Remove reconnection handler\n   * @private\n   */\n  _removeReconnectionHandler() {\n    if (this.disconnectHandler) {\n      this.client.removeEventListener('socket:disconnected', this.disconnectHandler);\n      this.disconnectHandler = null;\n    }\n  }\n\n  /**\n   * Schedule retry with exponential backoff\n   * @private\n   */\n  _scheduleRetry() {\n    const delay = this._calculateRetryDelay();\n\n    this.retryTimer = setTimeout(() => {\n      this.connect().catch(() => {\n        // Retry logic handles failures\n      });\n    }, delay);\n  }\n\n  /**\n   * Calculate retry delay with exponential backoff\n   * @returns {number} Delay in milliseconds\n   * @private\n   */\n  _calculateRetryDelay() {\n    const baseDelay = 1000; // 1 second\n    const maxDelay = 30000; // 30 seconds\n    const delay = baseDelay * Math.pow(2, this.retryCount);\n    return Math.min(delay, maxDelay);\n  }\n\n  /**\n   * Clear retry timer\n   * @private\n   */\n  _clearRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n\n  /**\n   * Update global connection status indicator in header\n   * @param {string} status - Connection status: 'connecting', 'connected', 'disconnected'\n   * @private\n   */\n  _updateGlobalConnectionStatus(status) {\n    const statusElement = document.getElementById('connectionStatus');\n    if (!statusElement) return;\n\n    // Remove all status classes\n    statusElement.classList.remove('connected', 'connecting', 'disconnected');\n\n    // Add current status class\n    statusElement.classList.add(status);\n\n    // Update text\n    const textElement = statusElement.querySelector('.status-text');\n    if (textElement) {\n      const statusText = {\n        connecting: 'Connecting...',\n        connected: 'Connected',\n        disconnected: 'Disconnected'\n      };\n      textElement.textContent = statusText[status] || 'Unknown';\n    }\n  }\n}\n\nexport default ConnectionManager;\n","/**\n * NetworkedQueueManager - Offline Transaction Queue Manager\n * ES6 Module - Browser Only\n *\n * Responsibilities:\n * - Offline transaction queue (localStorage persistence)\n * - Auto-sync on reconnect\n * - Queue management (add, retry, clear)\n * - Transaction replay via WebSocket for proper scoring\n *\n * Does NOT handle:\n * - WebSocket connection (OrchestratorClient)\n * - Event emission (managed by NetworkedSession)\n * - Transaction processing (backend)\n */\n\nimport OrchestratorClient from './orchestratorClient.js';\n\nexport class NetworkedQueueManager extends EventTarget {\n  constructor(config = {}) {\n    super();\n\n    this.client = config.client; // OrchestratorClient instance (dependency injection)\n    this.debug = config.debug || console; // Debug utility (dependency injection)\n    this.deviceId = config.deviceId || 'GM_STATION_UNKNOWN';\n\n    this.tempQueue = [];\n    this.syncing = false;\n    this.activeHandlers = new Map(); // Track active replay handlers for cleanup\n\n    // Load any persisted queue\n    this.loadQueue();\n\n    // Merge orphaned transactions from fallback queue\n    this.mergeOrphanedTransactions();\n  }\n\n  /**\n   * Merge transactions from fallback queue into main queue\n   *\n   * CONTEXT: This is a migration helper for Phase 0 development.\n   * During connection wizard testing, transactions were temporarily saved to\n   * 'pendingNetworkedTransactions' (a fallback queue used before NetworkedQueueManager existed).\n   *\n   * This method rescues those orphaned transactions by:\n   * 1. Loading transactions from 'pendingNetworkedTransactions' (if present)\n   * 2. Merging them into the main queue (networkedTempQueue)\n   * 3. Removing the fallback queue\n   *\n   * This ensures no transactions are lost during the migration to the new queue system.\n   * Once all devices have migrated, this logic becomes a no-op (fallback queue won't exist).\n   */\n  mergeOrphanedTransactions() {\n    try {\n      const fallbackQueue = localStorage.getItem('pendingNetworkedTransactions');\n      if (fallbackQueue) {\n        const orphaned = JSON.parse(fallbackQueue);\n        if (Array.isArray(orphaned) && orphaned.length > 0) {\n          this.debug.log('Merging orphaned transactions', { count: orphaned.length });\n\n          // Add to main queue\n          this.tempQueue.push(...orphaned);\n\n          // Clear fallback queue\n          localStorage.removeItem('pendingNetworkedTransactions');\n\n          // Save merged queue\n          this.saveQueue();\n\n          this.debug.log('Orphaned transactions merged successfully', {\n            totalQueueSize: this.tempQueue.length\n          });\n        }\n      }\n    } catch (error) {\n      this.debug.error?.('Failed to merge orphaned transactions', error);\n    }\n  }\n\n  /**\n   * Queue a transaction for submission\n   * @param {Object} transaction - Transaction to queue\n   * @emits queue:changed - Queue status updated\n   */\n  queueTransaction(transaction) {\n    // Check if we have a connection and it's connected\n    if (!this.client || !this.client.isConnected) {\n      // Not connected - add to temp queue\n      this.tempQueue.push(transaction);\n      this.saveQueue();\n      this.debug.log('Transaction queued for later submission', {\n        tokenId: transaction.tokenId,\n        queueSize: this.tempQueue.length\n      });\n\n      // Emit event for UI updates (event-driven, no polling needed)\n      this.dispatchEvent(new CustomEvent('queue:changed', {\n        detail: this.getStatus()\n      }));\n    } else {\n      // Connected - send immediately via OrchestratorClient\n      this.client.send('transaction:submit', transaction);\n\n      this.debug.log('Transaction sent immediately', {\n        tokenId: transaction.tokenId\n      });\n    }\n  }\n\n  /**\n   * Sync queued transactions when connection restored\n   * Replays each transaction via WebSocket for proper scoring/game mechanics\n   *\n   * NOTE: GM offline scans MUST use transaction:submit (not batch endpoint)\n   * Batch endpoint has NO SCORING OR GAME MECHANICS (player-only)\n   * Replay ensures duplicate detection, scoring, bonuses all work correctly\n   *\n   * @returns {Promise<void>}\n   */\n  async syncQueue() {\n    if (this.syncing || this.tempQueue.length === 0 || !this.client || !this.client.isConnected) {\n      return;\n    }\n\n    this.syncing = true;\n    this.debug.log('Starting queue sync via WebSocket replay', { queueSize: this.tempQueue.length });\n\n    const batch = [...this.tempQueue]; // Copy for sending\n    const results = [];\n\n    try {\n      // Replay each transaction via WebSocket (transaction:submit)\n      // This ensures proper scoring, duplicate detection, and game mechanics\n      for (let i = 0; i < batch.length; i++) {\n        const transaction = batch[i];\n\n        this.debug.log(`Replaying transaction ${i + 1}/${batch.length}`, {\n          tokenId: transaction.tokenId,\n          teamId: transaction.teamId\n        });\n\n        try {\n          // Replay via WebSocket (same path as live scans)\n          const result = await this.replayTransaction(transaction);\n          results.push({ success: true, transaction, result });\n        } catch (error) {\n          // Categorize error type for future retry logic (case-insensitive)\n          let errorType = 'unknown';\n          const message = error.message.toLowerCase();\n          if (message.includes('timeout')) {\n            errorType = 'timeout';\n          } else if (message.includes('validation') || message.includes('invalid')) {\n            errorType = 'validation';\n          } else if (message.includes('network') || message.includes('connection')) {\n            errorType = 'network';\n          }\n\n          this.debug.error?.(`Transaction replay failed (${errorType})`, {\n            tokenId: transaction.tokenId,\n            error: error.message,\n            errorType: errorType\n          });\n\n          results.push({\n            success: false,\n            transaction,\n            error: error.message,\n            errorType: errorType  // Enables future retry logic per error type\n          });\n        }\n      }\n\n      // Summary with error type breakdown\n      const successCount = results.filter(r => r.success).length;\n      const failCount = results.filter(r => !r.success).length;\n      const errorTypes = results\n        .filter(r => !r.success)\n        .reduce((acc, r) => {\n          acc[r.errorType] = (acc[r.errorType] || 0) + 1;\n          return acc;\n        }, {});\n\n      this.debug.log('Queue sync complete', {\n        total: batch.length,\n        success: successCount,\n        failed: failCount,\n        errorBreakdown: errorTypes  // e.g., { timeout: 2, validation: 1 }\n      });\n\n      // Clear queue after ALL transactions processed (even if some failed)\n      // Failed transactions are lost but logged - operator can manually re-scan\n      // This prevents infinite retry loops for permanently invalid transactions\n      this.tempQueue = [];\n      this.saveQueue();\n\n    } catch (error) {\n      this.debug.error?.('Queue sync failed - keeping queue for retry', {\n        error: error.message,\n        queueSize: this.tempQueue.length\n      });\n      // Queue preserved for retry on failure\n    } finally {\n      this.syncing = false;\n\n      // Emit event to update UI AFTER syncing flag is reset\n      this.dispatchEvent(new CustomEvent('queue:changed', {\n        detail: this.getStatus()\n      }));\n    }\n  }\n\n  /**\n   * Replay a single transaction via WebSocket\n   * Returns Promise that resolves with result or rejects on error/timeout\n   *\n   * @param {Object} transaction - Transaction to replay\n   * @returns {Promise<Object>} - Transaction result\n   * @private\n   */\n  replayTransaction(transaction) {\n    return new Promise((resolve, reject) => {\n      const handlerKey = `${transaction.tokenId}-${transaction.teamId}`;\n\n      // Helper to cleanup handler and timeout\n      const cleanup = (timeout, handler) => {\n        clearTimeout(timeout);\n        this.client.removeEventListener('message:received', handler);\n        this.activeHandlers.delete(handlerKey);\n      };\n\n      const timeout = setTimeout(() => {\n        const handler = this.activeHandlers.get(handlerKey);\n        if (handler) {\n          cleanup(timeout, handler);\n        }\n        reject(new Error(`Transaction replay timeout after 30s: ${transaction.tokenId}`));\n      }, 30000);\n\n      const handler = (event) => {\n        const { type, payload } = event.detail;\n\n        // Only process transaction:result events\n        if (type !== 'transaction:result') return;\n\n        // Check if this result matches our transaction\n        // (tokenId + teamId should be unique enough for matching)\n        if (payload.tokenId === transaction.tokenId &&\n            payload.teamId === transaction.teamId) {\n          cleanup(timeout, handler);\n\n          if (payload.status === 'error') {\n            reject(new Error(payload.message || 'Transaction failed'));\n          } else {\n            resolve(payload);\n          }\n        }\n        // If doesn't match, keep listening (might be from another concurrent scan)\n      };\n\n      // Track handler for cleanup\n      this.activeHandlers.set(handlerKey, handler);\n\n      // Register listener for transaction:result (via OrchestratorClient's message:received)\n      this.client.addEventListener('message:received', handler);\n\n      // Send transaction via OrchestratorClient\n      this.client.send('transaction:submit', transaction);\n\n      this.debug.log('Transaction submitted for replay', {\n        tokenId: transaction.tokenId,\n        teamId: transaction.teamId\n      });\n    });\n  }\n\n  // TODO P0.2: Implement batch upload with batch:ack pattern per AsyncAPI Phase 1.2\n  // Current implementation uses transaction replay (transaction:submit) which is correct\n  // for Phase 0. Batch upload will be added in Phase 1.2 for performance optimization.\n\n  /**\n   * Save queue to localStorage\n   */\n  saveQueue() {\n    try {\n      if (this.tempQueue.length > 0) {\n        localStorage.setItem('networkedTempQueue', JSON.stringify(this.tempQueue));\n      } else {\n        localStorage.removeItem('networkedTempQueue');\n      }\n    } catch (error) {\n      // Handle QuotaExceededError or other storage errors\n      if (error.name === 'QuotaExceededError') {\n        this.debug.error?.('localStorage quota exceeded - unable to save queue', {\n          queueSize: this.tempQueue.length,\n          error: error.message\n        });\n        // Attempt to clear oldest items or notify user\n        alert('Storage full: Unable to queue transactions offline. Please sync or clear data.');\n      } else {\n        this.debug.error?.('Failed to save queue to localStorage', error);\n      }\n    }\n  }\n\n  /**\n   * Load queue from localStorage\n   */\n  loadQueue() {\n    try {\n      const saved = localStorage.getItem('networkedTempQueue');\n      if (saved) {\n        this.tempQueue = JSON.parse(saved);\n        this.debug.log('Loaded queued transactions', { count: this.tempQueue.length });\n      }\n    } catch (error) {\n      this.debug.error?.('Failed to load queue', error);\n      this.tempQueue = [];\n    }\n  }\n\n  /**\n   * Clear the queue (only after successful sync)\n   */\n  clearQueue() {\n    this.tempQueue = [];\n    localStorage.removeItem('networkedTempQueue');\n    this.debug.log('Queue cleared');\n  }\n\n  /**\n   * Get queue status\n   * @returns {Object} Queue status { queuedCount, syncing }\n   */\n  getStatus() {\n    return {\n      queuedCount: this.tempQueue.length,\n      syncing: this.syncing\n    };\n  }\n\n  /**\n   * Cleanup handlers (call on destroy)\n   */\n  destroy() {\n    // Clear all active handlers\n    for (const [key, handler] of this.activeHandlers.entries()) {\n      this.client.removeEventListener('message:received', handler);\n    }\n    this.activeHandlers.clear();\n\n    // Remove all event listeners\n    this.client = null;\n  }\n}\n\n// Default export for convenience\nexport default NetworkedQueueManager;\n","/**\n * CommandSender - Shared WebSocket Command Utility\n * Eliminates duplicated _sendCommand code across admin modules\n *\n * Pattern: Send gm:command via WebSocket, wait for gm:command:ack\n * Timeout: 5 seconds (configurable)\n *\n * @module admin/utils/CommandSender\n */\n\n/**\n * Send an admin command via WebSocket and wait for acknowledgment\n *\n * @param {Object} connection - OrchestratorClient instance (EventTarget)\n * @param {string} action - Command action (e.g., 'session:create', 'video:play')\n * @param {Object} payload - Command payload data\n * @param {number} [timeout=5000] - Timeout in milliseconds\n * @returns {Promise<Object>} Resolves with response data on success\n * @throws {Error} On timeout or command failure\n *\n * @example\n * // Create a session\n * const response = await sendCommand(connection, 'session:create', { name: 'Game Night', teams: ['001', '002'] });\n *\n * @example\n * // Play video with custom timeout\n * const response = await sendCommand(connection, 'video:play', {}, 10000);\n */\nexport function sendCommand(connection, action, payload, timeout = 5000) {\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      connection.removeEventListener('message:received', ackHandler);\n      reject(new Error(`${action} timeout after ${timeout}ms`));\n    }, timeout);\n\n    // One-time handler for gm:command:ack\n    const ackHandler = (event) => {\n      const { type, payload: response } = event.detail;\n\n      // Only process gm:command:ack events\n      if (type !== 'gm:command:ack') return;\n\n      // Cleanup\n      clearTimeout(timeoutId);\n      connection.removeEventListener('message:received', ackHandler);\n\n      // Check response (response IS the data, already unwrapped by OrchestratorClient)\n      if (response.success) {\n        resolve(response);\n      } else {\n        reject(new Error(response.message || `Command failed: ${action}`));\n      }\n    };\n\n    // Register one-time listener\n    connection.addEventListener('message:received', ackHandler);\n\n    // Send command via OrchestratorClient (uses AsyncAPI envelope wrapper)\n    connection.send('gm:command', {\n      action: action,\n      payload: payload\n    });\n  });\n}\n\n/**\n * Create a bound command sender for a specific connection\n * Useful for modules that send many commands\n *\n * @param {Object} connection - OrchestratorClient instance\n * @returns {Function} Bound sendCommand function\n *\n * @example\n * const send = createCommandSender(this.connection);\n * await send('session:pause', {});\n */\nexport function createCommandSender(connection) {\n  return (action, payload, timeout) => sendCommand(connection, action, payload, timeout);\n}\n\nexport default { sendCommand, createCommandSender };\n","/**\n * SessionManager - Session Lifecycle Management\n * Handles create/pause/resume/end via WebSocket commands\n *\n * User Stories:\n * - GM creates new session with team configuration\n * - GM pauses session during breaks\n * - GM resumes session after breaks\n * - GM ends session when game concludes\n *\n * @module admin/SessionManager\n */\n\nimport { sendCommand } from './utils/CommandSender.js';\n\nexport class SessionManager {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (EventTarget)\n   */\n  constructor(connection) {\n    this.connection = connection;\n    this.currentSession = null;\n\n    // Bind handler for cleanup\n    this._messageHandler = this._handleMessage.bind(this);\n\n    // Listen to session-related broadcasts\n    this.connection.addEventListener('message:received', this._messageHandler);\n  }\n\n  /**\n   * Handle incoming session-related messages\n   * @private\n   */\n  _handleMessage(event) {\n    const { type, payload } = event.detail;\n\n    // Update local session state from broadcasts\n    if (type === 'session:update') {\n      this.currentSession = payload;\n    }\n\n    // Update from sync:full for initial state on connection\n    if (type === 'sync:full' && payload.session) {\n      this.currentSession = payload.session;\n    }\n  }\n\n  /**\n   * Create a new game session\n   * @param {string} name - Session name (e.g., \"Friday Night Game\")\n   * @param {string[]} [teams=[]] - Initial team IDs (teams are typically added dynamically)\n   * @returns {Promise<Object>} Session creation response\n   */\n  async createSession(name, teams = []) {\n    return sendCommand(this.connection, 'session:create', { name, teams });\n  }\n\n  /**\n   * Pause the current session\n   * @returns {Promise<Object>} Pause response\n   */\n  async pauseSession() {\n    if (!this.currentSession) return;\n    return sendCommand(this.connection, 'session:pause', {});\n  }\n\n  /**\n   * Resume a paused session\n   * @returns {Promise<Object>} Resume response\n   */\n  async resumeSession() {\n    if (!this.currentSession) return;\n    return sendCommand(this.connection, 'session:resume', {});\n  }\n\n  /**\n   * End the current session\n   * @returns {Promise<Object>} End response\n   */\n  async endSession() {\n    if (!this.currentSession) return;\n    return sendCommand(this.connection, 'session:end', {});\n  }\n\n  /**\n   * Get current session state\n   * @returns {Object|null} Current session or null\n   */\n  getSession() {\n    return this.currentSession;\n  }\n\n  /**\n   * Check if a session is active\n   * @returns {boolean}\n   */\n  isActive() {\n    return this.currentSession?.status === 'active';\n  }\n\n  /**\n   * Check if session is paused\n   * @returns {boolean}\n   */\n  isPaused() {\n    return this.currentSession?.status === 'paused';\n  }\n\n  /**\n   * Cleanup event listeners\n   */\n  destroy() {\n    if (this.connection && this._messageHandler) {\n      this.connection.removeEventListener('message:received', this._messageHandler);\n    }\n  }\n}\n\nexport default SessionManager;\n","/**\n * VideoController - Video Playback Control\n * Manages video queue and playback commands via WebSocket\n *\n * User Stories:\n * - GM plays/pauses/stops/skips video playback\n * - GM adds videos manually to the queue\n * - GM reorders or clears the video queue\n * - GM monitors current video and queue length\n *\n * @module admin/VideoController\n */\n\nimport { sendCommand } from './utils/CommandSender.js';\n\nexport class VideoController {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (EventTarget)\n   */\n  constructor(connection) {\n    this.connection = connection;\n    this.currentVideo = null;\n    this.queueLength = 0;\n  }\n\n  /**\n   * Start or resume video playback\n   * @returns {Promise<Object>} Play response\n   */\n  async playVideo() {\n    return sendCommand(this.connection, 'video:play', {});\n  }\n\n  /**\n   * Pause video playback\n   * @returns {Promise<Object>} Pause response\n   */\n  async pauseVideo() {\n    return sendCommand(this.connection, 'video:pause', {});\n  }\n\n  /**\n   * Stop video playback (returns to idle loop)\n   * @returns {Promise<Object>} Stop response\n   */\n  async stopVideo() {\n    return sendCommand(this.connection, 'video:stop', {});\n  }\n\n  /**\n   * Skip current video and play next in queue\n   * @returns {Promise<Object>} Skip response\n   */\n  async skipVideo() {\n    return sendCommand(this.connection, 'video:skip', {});\n  }\n\n  /**\n   * Add a video to the playback queue\n   * @param {string} videoFile - Video filename (e.g., \"jaw001.mp4\")\n   * @returns {Promise<Object>} Add response\n   */\n  async addToQueue(videoFile) {\n    return sendCommand(this.connection, 'video:queue:add', { videoFile });\n  }\n\n  /**\n   * Reorder videos in the queue\n   * @param {number} fromIndex - Current position\n   * @param {number} toIndex - New position\n   * @returns {Promise<Object>} Reorder response\n   */\n  async reorderQueue(fromIndex, toIndex) {\n    return sendCommand(this.connection, 'video:queue:reorder', { fromIndex, toIndex });\n  }\n\n  /**\n   * Clear all videos from the queue\n   * @returns {Promise<Object>} Clear response\n   */\n  async clearQueue() {\n    return sendCommand(this.connection, 'video:queue:clear', {});\n  }\n\n\n\n  /**\n   * Cleanup (no persistent listeners)\n   */\n  destroy() {\n    // VideoController uses one-time listeners per command via CommandSender\n    // No persistent listeners to cleanup\n  }\n}\n\nexport default VideoController;\n","/**\n * DisplayController - HDMI Display Mode Control\n * Manages display state machine (IDLE_LOOP <-> SCOREBOARD) via WebSocket\n *\n * User Stories:\n * - GM toggles between Idle Loop and Scoreboard\n * - GM sees current display status\n *\n * @module admin/DisplayController\n */\n\nimport { sendCommand } from './utils/CommandSender.js';\n\nexport class DisplayController {\n    /**\n     * @param {Object} connection - OrchestratorClient instance (EventTarget)\n     */\n    constructor(connection) {\n        this.connection = connection;\n    }\n\n    /**\n     * Set display to Idle Loop mode (VLC plays idle-loop.mp4)\n     * @returns {Promise<Object>} Response with { success, mode: 'IDLE_LOOP' }\n     */\n    async setIdleLoop() {\n        return sendCommand(this.connection, 'display:idle-loop', {});\n    }\n\n    /**\n     * Set display to Scoreboard mode (browser shows scoreboard.html)\n     * @returns {Promise<Object>} Response with { success, mode: 'SCOREBOARD' }\n     */\n    async setScoreboard() {\n        return sendCommand(this.connection, 'display:scoreboard', {});\n    }\n\n    /**\n     * Toggle between Idle Loop and Scoreboard modes\n     * @returns {Promise<Object>} Response with { success, mode: 'IDLE_LOOP'|'SCOREBOARD' }\n     */\n    async toggleDisplayMode() {\n        return sendCommand(this.connection, 'display:toggle', {});\n    }\n\n    /**\n     * Get current display status\n     * @returns {Promise<Object>} Response with { currentMode, previousMode, pendingVideo, timestamp }\n     */\n    async getDisplayStatus() {\n        return sendCommand(this.connection, 'display:status', {});\n    }\n\n    /**\n     * Cleanup\n     */\n    destroy() {\n        // No persistent listeners to cleanup\n    }\n}\n\nexport default DisplayController;\n","/**\n * SystemMonitor - Health Monitoring\n * Checks backend and VLC connectivity via HTTP\n *\n * User Stories:\n * - GM monitors orchestrator health status\n * - GM monitors VLC connection status\n * - System displays health indicators in admin panel\n *\n * Note: Uses HTTP fetch (not WebSocket) for health checks\n *\n * @module admin/SystemMonitor\n */\n\nexport class SystemMonitor {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (for config.url)\n   */\n  constructor(connection) {\n    this.connection = connection;\n    this.backendHealth = null;\n    this.vlcHealth = null;\n  }\n\n  /**\n   * Check backend health via HTTP\n   * @returns {Promise<string>} Health status: 'healthy' | 'unhealthy' | 'error'\n   */\n  async checkHealth() {\n    try {\n      const baseUrl = this.connection?.config?.url || 'http://localhost:3000';\n      const response = await fetch(`${baseUrl}/health`);\n      this.backendHealth = response.ok ? 'healthy' : 'unhealthy';\n      return this.backendHealth;\n    } catch (error) {\n      this.backendHealth = 'error';\n      throw error;\n    }\n  }\n\n  /**\n   * Get cached backend health status\n   * @returns {string|null} Last known health status\n   */\n  getBackendHealth() {\n    return this.backendHealth;\n  }\n\n  /**\n   * Get cached VLC health status\n   * @returns {string|null} Last known VLC status\n   */\n  getVlcHealth() {\n    return this.vlcHealth;\n  }\n\n  /**\n   * Update VLC health from sync:full data\n   * @param {string} status - VLC status from backend\n   */\n  setVlcHealth(status) {\n    this.vlcHealth = status;\n  }\n\n  /**\n   * Cleanup (no event listeners)\n   */\n  destroy() {\n    // SystemMonitor uses HTTP fetch only, no WebSocket listeners\n  }\n}\n\nexport default SystemMonitor;\n","/**\n * AdminOperations - System-Level Commands\n * Handles score management, transaction deletion, and system operations\n *\n * User Stories:\n * - GM resets all team scores to zero\n * - GM adjusts individual team scores (add/subtract points)\n * - GM deletes erroneous transactions\n * - GM restarts system or clears data (emergency operations)\n *\n * @module admin/AdminOperations\n */\n\nimport { sendCommand } from './utils/CommandSender.js';\nimport Debug from '../utils/debug.js';\n\nexport class AdminOperations {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (EventTarget)\n   */\n  constructor(connection) {\n    this.connection = connection;\n\n    // Bind handler for cleanup\n    this._messageHandler = this._handleMessage.bind(this);\n\n    // Listen for command acknowledgments and broadcasts\n    this.connection.addEventListener('message:received', this._messageHandler);\n  }\n\n  /**\n   * Handle incoming messages (informational logging)\n   * @private\n   */\n  _handleMessage(event) {\n    const { type } = event.detail;\n\n    // Handle scores:reset broadcast (informational)\n    if (type === 'scores:reset') {\n      Debug.log('[AdminOperations] Scores reset broadcast received');\n      // sync:full will follow automatically\n      // MonitoringDisplay handles the actual UI update\n    }\n  }\n\n  /**\n   * Restart the orchestrator system\n   * @returns {Promise<Object>} Restart response\n   */\n  async restartSystem() {\n    return sendCommand(this.connection, 'system:restart', {});\n  }\n\n  /**\n   * Clear all system data\n   * @returns {Promise<Object>} Clear response\n   */\n  async clearData() {\n    return sendCommand(this.connection, 'system:clear', {});\n  }\n\n  /**\n   * Reset all team scores to zero\n   * @returns {Promise<Object>} Reset response\n   */\n  async resetScores() {\n    return sendCommand(this.connection, 'score:reset', {});\n  }\n\n  /**\n   * Adjust a team's score by a delta amount\n   * @param {string} teamId - Team identifier (e.g., '001', '002')\n   * @param {number} delta - Score adjustment (positive or negative)\n   * @param {string} [reason='Admin adjustment'] - Reason for audit trail\n   * @returns {Promise<Object>} Adjustment response\n   */\n  async adjustScore(teamId, delta, reason = 'Admin adjustment') {\n    return sendCommand(this.connection, 'score:adjust', { teamId, delta, reason });\n  }\n\n  /**\n   * Delete a transaction by ID\n   * Reverses the transaction's score impact and removes from history\n   * @param {string} transactionId - Transaction ID to delete\n   * @returns {Promise<Object>} Deletion response\n   */\n  async deleteTransaction(transactionId) {\n    return sendCommand(this.connection, 'transaction:delete', { transactionId });\n  }\n\n  /**\n   * Cleanup event listeners\n   */\n  destroy() {\n    if (this.connection && this._messageHandler) {\n      this.connection.removeEventListener('message:received', this._messageHandler);\n    }\n  }\n}\n\nexport default AdminOperations;\n","/**\n * MonitoringDisplay - Event-Driven DOM Updates\n * Listens to WebSocket events and updates admin panel UI\n *\n * User Stories:\n * - GM sees real-time transaction log updates\n * - GM sees team scores update after each scan\n * - GM sees session status (active/paused/ended)\n * - GM sees video playback progress\n * - GM sees connected devices list\n * - GM sees system health indicators\n *\n * Architecture:\n * - Listens to WebSocket broadcasts via EventTarget pattern\n * - Updates DOM elements directly (admin panel specific)\n * - Coordinates with DataManager for scanner view updates\n *\n * @module admin/MonitoringDisplay\n */\n\nimport Debug from '../utils/debug.js';\n\nexport class MonitoringDisplay {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (EventTarget)\n   * @param {Object} dataManager - DataManager instance for cross-view data sync\n   * @param {Object} teamRegistry - TeamRegistry instance for team dropdown sync (optional)\n   */\n  constructor(client, dataManager, teamRegistry = null) {\n    this.client = client;\n    this.dataManager = dataManager;\n    this.teamRegistry = teamRegistry;\n    this.devices = [];\n    this.overtimeData = null;\n    this._currentSession = null;\n\n    // Display mode state (Phase 4.2)\n    this.isVideoPlaying = false;\n    this.currentIdleMode = 'IDLE_LOOP';\n\n    // Bind handler for cleanup\n    this._messageHandler = this._handleMessage.bind(this);\n    this.client.addEventListener('message:received', this._messageHandler);\n\n    // Load available videos for manual queue dropdown\n    this.loadAvailableVideos();\n\n    // Request initial state to eliminate race condition\n    this._requestInitialState();\n  }\n\n  /**\n   * Request initial state from backend\n   * @private\n   */\n  _sendMessage(type, payload) {\n    if (this.client?.socket?.connected) {\n      this.client.socket.emit(type, payload);\n    } else {\n      console.warn('[MonitoringDisplay] Cannot send message - disconnected');\n    }\n  }\n\n  /**\n   * Request initial state from backend\n   * @private\n   */\n  _requestInitialState() {\n    if (this.client?.socket?.connected) {\n      this.client.socket.emit('sync:request');\n      console.log('[MonitoringDisplay] Requested initial state via sync:request');\n    } else {\n      console.warn('[MonitoringDisplay] Cannot request state - socket not connected');\n    }\n  }\n\n  /**\n   * Handle incoming WebSocket messages\n   * Routes to appropriate display update method\n   * @private\n   */\n  _handleMessage(event) {\n    const { type, payload } = event.detail;\n\n    Debug.log(`[MonitoringDisplay] _handleMessage called: ${type}`);\n\n    switch (type) {\n      case 'transaction:new':\n        this._handleTransactionNew(payload);\n        break;\n\n      case 'score:updated':\n        this._handleScoreUpdated(payload);\n        break;\n\n      case 'session:update':\n        this._handleSessionUpdate(payload);\n        break;\n\n      case 'session:overtime':\n        this._handleSessionOvertime(payload);\n        break;\n\n      case 'video:status':\n        this.updateVideoDisplay(payload);\n        break;\n\n      case 'display:mode':\n        this._handleDisplayMode(payload);\n        break;\n\n      case 'video:progress':\n        this.updateVideoProgress(payload);\n        break;\n\n      case 'video:queue:update':\n        this.updateQueueDisplay(payload);\n        break;\n\n      case 'device:connected':\n        this._handleDeviceConnected(payload);\n        break;\n\n      case 'device:disconnected':\n        this._handleDeviceDisconnected(payload);\n        break;\n\n      case 'scores:reset':\n        this._handleScoresReset();\n        break;\n\n      case 'transaction:deleted':\n        this._handleTransactionDeleted(payload);\n        break;\n\n      case 'sync:full':\n        this.updateAllDisplays(payload);\n        break;\n\n      case 'gm:command:ack':\n        // Fallback: If display:mode event is missed, update UI based on ACK\n        if (payload.success && payload.action) {\n          if (payload.action === 'display:scoreboard') {\n            this._handleDisplayMode({ mode: 'SCOREBOARD' });\n          } else if (payload.action === 'display:idle-loop') {\n            this._handleDisplayMode({ mode: 'IDLE_LOOP' });\n          }\n        }\n        break;\n    }\n  }\n\n  // ============================================\n  // MESSAGE HANDLERS\n  // ============================================\n\n  _handleTransactionNew(payload) {\n    if (payload?.transaction) {\n      Debug.log('[MonitoringDisplay] transaction:new received (UI updates via ScreenUpdateManager)');\n      // NOTE: DataManager state update is handled by NetworkedSession global listener\n      // NOTE: Game Activity UI updates are handled by ScreenUpdateManager container handlers\n      // This method is now a no-op - the transaction:added event from DataManager triggers UI updates\n    }\n  }\n\n  _handleScoreUpdated(payload) {\n    Debug.log('[MonitoringDisplay] Score updated event received');\n    // NOTE: DataManager state update is handled by NetworkedSession global listener\n    // NOTE: Scoreboard UI updates are handled by container handlers in ScreenUpdateManager\n    // This method is now a no-op for score display (UI handled elsewhere)\n  }\n\n  _handleSessionUpdate(payload) {\n    // Update session display UI\n    this.updateSessionDisplay(payload);\n\n    // Update TeamRegistry with latest teams from session (enables cross-GM team sync)\n    if (this.teamRegistry) {\n      this.teamRegistry.populateFromSession(payload);\n    }\n\n    // Handle UI-specific session lifecycle transitions\n    // NOTE: DataManager state updates (resetForNewSession) are handled by NetworkedSession global listener\n    if (payload.status === 'ended') {\n      Debug.log('[MonitoringDisplay] Session ended, clearing admin panel displays');\n      this.overtimeData = null;\n      this._clearAdminPanelDisplays();\n    } else if (payload.status === 'active') {\n      // Request fresh state from server to populate UI with new session data\n      this.overtimeData = null;\n      this._requestInitialState();\n    }\n  }\n\n  /**\n   * Clear admin panel displays (game activity, score board)\n   * Called when session ends to ensure no stale data shown\n   * @private\n   */\n  _clearAdminPanelDisplays() {\n    const gameActivity = document.getElementById('admin-game-activity');\n    if (gameActivity) gameActivity.innerHTML = '';\n\n    const scoreBoard = document.getElementById('admin-score-board');\n    if (scoreBoard) scoreBoard.innerHTML = '';\n\n    Debug.log('[MonitoringDisplay] Admin panel displays cleared');\n  }\n\n  _handleSessionOvertime(payload) {\n    Debug.log('[MonitoringDisplay] Session overtime warning received:', payload);\n    this.overtimeData = payload;\n    this.updateSessionDisplay(this._currentSession || payload);\n  }\n\n  _handleDeviceConnected(payload) {\n    // Prevent duplicates (idempotent)\n    const existingIndex = this.devices.findIndex(d => d.deviceId === payload.deviceId);\n    if (existingIndex === -1) {\n      this.devices.push(payload);\n    }\n    this.updateDeviceList(this.devices);\n    this.updateSystemDisplay();\n  }\n\n  _handleDeviceDisconnected(payload) {\n    this.devices = this.devices.filter(d => d.deviceId !== payload.deviceId);\n    this.updateDeviceList(this.devices);\n    this.updateSystemDisplay();\n  }\n\n  _handleScoresReset() {\n    Debug.log('[MonitoringDisplay] Scores reset broadcast received');\n    // NOTE: DataManager state update is handled by NetworkedSession global listener\n    // NOTE: Scoreboard UI updates are handled by container handlers in ScreenUpdateManager\n    // Admin panel clearing is handled by container handler 'scores:cleared' event\n  }\n\n  _handleTransactionDeleted(payload) {\n    Debug.log('[MonitoringDisplay] Transaction deleted:', payload?.transactionId);\n    // NOTE: DataManager state update is handled by NetworkedSession global listener\n\n    // Remove from admin panel transaction log (UI-only update)\n    const transactionLog = document.getElementById('admin-transaction-log');\n    if (transactionLog && payload?.transactionId) {\n      const txElement = transactionLog.querySelector(`[data-transaction-id=\"${payload.transactionId}\"]`);\n      if (txElement) txElement.remove();\n    }\n  }\n\n  /**\n   * Handle display:mode event (Phase 4.2)\n   * Updates \"Now Showing\" display and idle mode toggle buttons\n   * @private\n   */\n  _handleDisplayMode(payload) {\n    if (!payload?.mode) return;\n\n    const nowShowingValue = document.getElementById('now-showing-value');\n    const nowShowingIcon = document.getElementById('now-showing-icon');\n    const returnsToContainer = document.getElementById('returns-to-container');\n    const btnIdleLoop = document.getElementById('btn-idle-loop');\n    const btnScoreboard = document.getElementById('btn-scoreboard');\n\n    // Update toggle button states\n    btnIdleLoop?.classList.toggle('active', payload.mode === 'IDLE_LOOP');\n    btnScoreboard?.classList.toggle('active', payload.mode === 'SCOREBOARD');\n\n    // Store current idle mode for \"returns to\" display\n    this.currentIdleMode = payload.mode;\n\n    // Update display if no video playing\n    if (!this.isVideoPlaying) {\n      if (payload.mode === 'IDLE_LOOP') {\n        if (nowShowingValue) nowShowingValue.textContent = 'Idle Loop';\n        if (nowShowingIcon) nowShowingIcon.textContent = 'üîÑ';\n      } else if (payload.mode === 'SCOREBOARD') {\n        if (nowShowingValue) nowShowingValue.textContent = 'Scoreboard';\n        if (nowShowingIcon) nowShowingIcon.textContent = 'üèÜ';\n      }\n      if (returnsToContainer) returnsToContainer.style.display = 'none';\n    }\n\n    Debug.log(`[MonitoringDisplay] Display mode updated: ${payload.mode}`);\n  }\n\n  // ============================================\n  // DISPLAY UPDATE METHODS\n  // ============================================\n\n  /**\n   * Update transaction log display\n   */\n  updateTransactionDisplay(transaction) {\n    if (!transaction) return;\n\n    const transactionLog = document.getElementById('admin-transaction-log');\n    if (!transactionLog) return;\n\n    const txTime = transaction.timestamp ? new Date(transaction.timestamp).toLocaleTimeString() : '-';\n    const memoryType = transaction.memoryType || 'UNKNOWN';\n    const isDuplicate = transaction.status === 'duplicate';\n    const duplicateClass = isDuplicate ? ' duplicate' : '';\n    const duplicateBadge = isDuplicate ? ' <span class=\"duplicate-badge-small\">DUP</span>' : '';\n\n    const txHtml = `\n      <div class=\"transaction-item${duplicateClass}\" data-transaction-id=\"${transaction.id || ''}\">\n        <span class=\"tx-time\">${txTime}</span>\n        <span class=\"tx-team\">${transaction.teamId || '-'}</span>\n        <span class=\"tx-token\">${transaction.tokenId || '-'}${duplicateBadge}</span>\n        <span class=\"tx-type\">${memoryType}</span>\n      </div>\n    `;\n\n    // Prepend new transaction (most recent first)\n    transactionLog.innerHTML = txHtml + transactionLog.innerHTML;\n\n    // Keep only last 10 transactions\n    const items = transactionLog.querySelectorAll('.transaction-item');\n    if (items.length > 10) {\n      for (let i = 10; i < items.length; i++) {\n        items[i].remove();\n      }\n    }\n  }\n\n  /**\n   * Update device list display\n   */\n  updateDeviceList(devices) {\n    if (!Array.isArray(devices)) return;\n\n    this.devices = devices;\n\n    const countElement = document.getElementById('device-count');\n    const listElement = document.getElementById('device-list');\n\n    if (countElement) {\n      countElement.textContent = String(devices.length);\n    }\n\n    if (listElement) {\n      if (devices.length === 0) {\n        listElement.innerHTML = '<p class=\"text-muted text-sm\">No devices connected</p>';\n      } else {\n        listElement.innerHTML = devices.map(device => `\n          <div class=\"device-item\">\n            <span>${device.deviceId || 'Unknown'}</span>\n            <span class=\"device-type\">${device.type || '-'}</span>\n          </div>\n        `).join('');\n      }\n    }\n  }\n\n  // NOTE: updateScoreDisplay() has been removed\n  // Scoreboard updates are now handled by:\n  // 1. NetworkedSession global listener updates DataManager.backendScores\n  // 2. DataManager emits 'team-score:updated'\n  // 3. ScreenUpdateManager container handlers render to #admin-score-board\n\n  /**\n   * Update session display with rich status UI\n   * Renders different UI for each session state: null, active, paused, ended\n   */\n  updateSessionDisplay(session) {\n    const container = document.getElementById('session-status-container');\n    if (!container) {\n      Debug.log('session-status-container not found in DOM', true);\n      return;\n    }\n\n    this._currentSession = session;\n\n    // No session state\n    if (!session) {\n      container.innerHTML = this._renderNoSession();\n      return;\n    }\n\n    // Ended session state\n    if (session.status === 'ended') {\n      container.innerHTML = this._renderEndedSession(session);\n      return;\n    }\n\n    // Paused session state\n    if (session.status === 'paused') {\n      container.innerHTML = this._renderPausedSession(session);\n      return;\n    }\n\n    // Active session state (default)\n    container.innerHTML = this._renderActiveSession(session);\n  }\n\n  _renderNoSession() {\n    return `\n      <div class=\"session-status session-status--empty\">\n        <p class=\"session-status__message\">No Active Session</p>\n        <p class=\"session-status__hint\">Create a new session to begin tracking gameplay</p>\n        <button class=\"btn btn-primary\" data-action=\"app.adminCreateSession\">\n          Create New Session\n        </button>\n      </div>\n    `;\n  }\n\n  _renderEndedSession(session) {\n    const endTime = session.endTime ? new Date(session.endTime).toLocaleString() : 'Unknown';\n    const duration = session.getDuration ? this.formatDuration(session.getDuration()) : 'Unknown';\n\n    return `\n      <div class=\"session-status session-status--ended\">\n        <h4 class=\"session-status__header\">\n          <span class=\"session-status__icon\">‚ö†Ô∏è</span>\n          <span>Previous Session Ended</span>\n        </h4>\n        <div class=\"session-status__details\">\n          <p class=\"session-status__name\">${this.escapeHtml(session.name || 'Unnamed Session')}</p>\n          <p class=\"session-status__meta\">Ended: ${this.escapeHtml(endTime)}</p>\n          <p class=\"session-status__meta\">Duration: ${this.escapeHtml(duration)}</p>\n          <p class=\"session-status__meta\">Total Scans: ${session.metadata?.totalScans || 0}</p>\n        </div>\n        <div class=\"session-status__actions\">\n          <button class=\"btn btn-primary\" data-action=\"app.adminResetAndCreateNew\">\n            Reset & Start New Session\n          </button>\n          <button class=\"btn btn-secondary\" data-action=\"app.adminViewSessionDetails\">\n            View Details\n          </button>\n        </div>\n        <p class=\"session-status__tip\">üí° Start a new session to continue gameplay</p>\n      </div>\n    `;\n  }\n\n  _renderPausedSession(session) {\n    const startTime = session.startTime ? new Date(session.startTime).toLocaleString() : 'Unknown';\n\n    return `\n      <div class=\"session-status session-status--paused\">\n        <h4 class=\"session-status__header\">\n          <span class=\"session-status__icon\">‚è∏Ô∏è</span>\n          <span>Session Paused</span>\n        </h4>\n        <div class=\"session-status__details\">\n          <p class=\"session-status__name\">${this.escapeHtml(session.name || 'Session')}</p>\n          <p class=\"session-status__meta\">Started: ${this.escapeHtml(startTime)}</p>\n          <p class=\"session-status__meta\">Scans: ${session.metadata?.totalScans || 0}</p>\n        </div>\n        <div class=\"session-status__actions\">\n          <button class=\"btn btn-primary\" data-action=\"app.adminResumeSession\">\n            Resume Session\n          </button>\n          <button class=\"btn btn-danger\" data-action=\"app.adminEndSession\">\n            End Session\n          </button>\n        </div>\n      </div>\n    `;\n  }\n\n  _renderActiveSession(session) {\n    const startTime = session.startTime ? new Date(session.startTime).toLocaleString() : 'Unknown';\n    const totalScans = session.metadata?.totalScans || 0;\n\n    // Build overtime warning if applicable\n    let overtimeHtml = '';\n    if (this.overtimeData) {\n      const expectedMin = this.overtimeData.expectedDuration || 120;\n      const actualMin = this.overtimeData.actualDuration || expectedMin;\n      const overtimeMin = this.overtimeData.overtimeDuration || 0;\n\n      overtimeHtml = `\n        <div class=\"session-overtime-warning\">\n          <div class=\"session-overtime-warning__content\">\n            <span class=\"session-overtime-warning__icon\">‚ö†Ô∏è</span>\n            <div class=\"session-overtime-warning__text\">\n              <strong>Session Running Overtime</strong>\n              <p>Expected: ${expectedMin} min | Actual: ${actualMin} min | Overtime: <strong>${overtimeMin} min</strong></p>\n            </div>\n          </div>\n        </div>\n      `;\n    }\n\n    return `\n      <div class=\"session-status session-status--active\">\n        <h4 class=\"session-status__header\">\n          <span class=\"session-status__icon\">‚úÖ</span>\n          <span>${this.escapeHtml(session.name || 'Active Session')}</span>\n        </h4>\n        ${overtimeHtml}\n        <div class=\"session-status__details\">\n          <p class=\"session-status__meta\">Started: ${this.escapeHtml(startTime)}</p>\n          <p class=\"session-status__meta\">Total Scans: ${totalScans}</p>\n          <p class=\"session-status__meta\">Status: <span class=\"status-active\">Active</span></p>\n        </div>\n        <div class=\"session-status__actions\">\n          <button class=\"btn btn-secondary\" data-action=\"app.adminPauseSession\">\n            Pause\n          </button>\n          <button class=\"btn btn-danger\" data-action=\"app.adminEndSession\">\n            End Session\n          </button>\n        </div>\n      </div>\n    `;\n  }\n\n  // ============================================\n  // VIDEO DISPLAY METHODS\n  // ============================================\n\n  /**\n   * Update video display status\n   * Also updates \"Now Showing\" display for Phase 4.2 integration\n   */\n  updateVideoDisplay(videoStatus) {\n    if (!videoStatus) return;\n\n    const currentVideoElem = document.getElementById('admin-current-video');\n    const queueLengthElem = document.getElementById('admin-queue-length');\n\n    // Phase 4.2: Integrated display status elements\n    const nowShowingValue = document.getElementById('now-showing-value');\n    const nowShowingIcon = document.getElementById('now-showing-icon');\n    const returnsToContainer = document.getElementById('returns-to-container');\n    const returnsToMode = document.getElementById('returns-to-mode');\n    const pendingQueueCount = document.getElementById('pending-queue-count');\n\n    if (currentVideoElem) {\n      if (videoStatus.status === 'playing' && videoStatus.tokenId) {\n        const progress = videoStatus.progress || 0;\n        currentVideoElem.textContent = `${videoStatus.tokenId} (${progress}%)`;\n      } else {\n        currentVideoElem.textContent = videoStatus.tokenId || 'None (idle loop)';\n      }\n    }\n\n    if (queueLengthElem) {\n      queueLengthElem.textContent = String(videoStatus.queueLength || 0);\n    }\n\n    // Phase 4.2: Update integrated display status\n    if (pendingQueueCount) {\n      pendingQueueCount.textContent = String(videoStatus.queueLength || 0);\n    }\n\n    if (videoStatus.status === 'playing' && videoStatus.tokenId) {\n      // Video is playing - update \"Now Showing\" to show video\n      this.isVideoPlaying = true;\n      if (nowShowingValue) nowShowingValue.textContent = `${videoStatus.tokenId}.mp4`;\n      if (nowShowingIcon) nowShowingIcon.textContent = '‚ñ∂Ô∏è';\n      if (returnsToContainer) returnsToContainer.style.display = 'block';\n      if (returnsToMode) {\n        returnsToMode.textContent = this.currentIdleMode === 'SCOREBOARD' ? 'Scoreboard' : 'Idle Loop';\n      }\n    } else if (videoStatus.status === 'idle') {\n      // Video ended - restore idle mode display\n      this.isVideoPlaying = false;\n      if (this.currentIdleMode === 'SCOREBOARD') {\n        if (nowShowingValue) nowShowingValue.textContent = 'Scoreboard';\n        if (nowShowingIcon) nowShowingIcon.textContent = 'üèÜ';\n      } else {\n        if (nowShowingValue) nowShowingValue.textContent = 'Idle Loop';\n        if (nowShowingIcon) nowShowingIcon.textContent = 'üîÑ';\n      }\n      if (returnsToContainer) returnsToContainer.style.display = 'none';\n    }\n  }\n\n  /**\n   * Update video progress bar (called every 1s during playback)\n   */\n  updateVideoProgress(progressData) {\n    if (!progressData) return;\n\n    const currentVideoElem = document.getElementById('admin-current-video');\n    const progressContainer = document.getElementById('video-progress-container');\n    const progressFill = document.getElementById('video-progress-fill');\n    const progressTime = document.getElementById('video-progress-time');\n\n    if (currentVideoElem && progressData.tokenId && progressData.progress !== undefined) {\n      const progress = Math.round(progressData.progress);\n      const position = Math.round(progressData.position);\n      const duration = Math.round(progressData.duration);\n      currentVideoElem.textContent = `${progressData.tokenId} (${progress}% - ${position}s/${duration}s)`;\n\n      if (progressContainer) progressContainer.style.display = 'block';\n      if (progressFill) progressFill.style.width = `${progress}%`;\n      if (progressTime) progressTime.textContent = `${position}s / ${duration}s`;\n    } else {\n      if (progressContainer) progressContainer.style.display = 'none';\n    }\n  }\n\n  /**\n   * Update queue display\n   */\n  updateQueueDisplay(queueData) {\n    if (!queueData) return;\n\n    const container = document.getElementById('video-queue-container');\n    const list = document.getElementById('video-queue-list');\n    const count = document.getElementById('queue-count');\n\n    if (!container || !list || !count) return;\n\n    if (!queueData.items || queueData.items.length === 0) {\n      container.style.display = 'none';\n      return;\n    }\n\n    container.style.display = 'block';\n    count.textContent = queueData.items.length;\n    list.innerHTML = queueData.items.map((item, idx) => `\n      <div class=\"queue-item\">\n        <span class=\"queue-item__index\">${idx + 1}.</span>\n        <span class=\"queue-item__name\">${item.tokenId}</span>\n        <span class=\"queue-item__duration\">(${item.duration}s)</span>\n      </div>\n    `).join('');\n  }\n\n  /**\n   * Load available videos from server for dropdown\n   */\n  async loadAvailableVideos() {\n    try {\n      const baseUrl = this.client?.config?.url || 'http://localhost:3000';\n      const response = await fetch(`${baseUrl}/api/tokens`);\n      const data = await response.json();\n\n      const datalist = document.getElementById('available-videos');\n      if (!datalist) return;\n\n      const videoOptions = Object.entries(data.tokens)\n        .filter(([, token]) => token.video)\n        .map(([id, token]) => `<option value=\"${token.video}\">${id} - ${token.video}</option>`)\n        .join('');\n\n      datalist.innerHTML = videoOptions;\n      Debug.log(`Loaded video options: ${Object.keys(data.tokens).filter(id => data.tokens[id].video).length}`);\n    } catch (error) {\n      Debug.log(`Failed to load available videos: ${error.message}`, true);\n    }\n  }\n\n  // ============================================\n  // SYSTEM DISPLAY METHODS\n  // ============================================\n\n  /**\n   * Update system status display\n   */\n  updateSystemDisplay() {\n    if (!this.client) return;\n\n    const orchestratorElem = document.getElementById('orchestrator-status');\n    if (orchestratorElem) {\n      const status = this.client.isConnected ? 'connected' : 'disconnected';\n      orchestratorElem.className = `status-dot status-dot--${status}`;\n      orchestratorElem.title = status;\n    }\n  }\n\n  // ============================================\n  // AGGREGATE UPDATE METHODS\n  // ============================================\n\n  /**\n   * Initialize all displays from sync:full event\n   * NOTE: DataManager state updates (resetForNewSession, setScannedTokensFromServer)\n   * are handled by NetworkedSession global listener\n   */\n  updateAllDisplays(syncData) {\n    if (!syncData) return;\n\n    // Update session display (UI only)\n    this.updateSessionDisplay(syncData.session || null);\n\n    // Update TeamRegistry from session data (enables cross-GM team sync on connect)\n    if (syncData.session && this.teamRegistry) {\n      this.teamRegistry.populateFromSession(syncData.session);\n    }\n\n    // Update video\n    if (syncData.videoStatus) {\n      this.updateVideoDisplay(syncData.videoStatus);\n    }\n\n    // NOTE: Score state updates are handled by NetworkedSession global listener\n    // NOTE: Scoreboard UI updates are handled by container handlers in ScreenUpdateManager\n\n    // Update transactions - UI only (state handled by NetworkedSession)\n    if (syncData.recentTransactions && Array.isArray(syncData.recentTransactions)) {\n      // NOTE: DataManager.addTransaction is handled by NetworkedSession global listener\n      // Here we only update the admin panel UI\n      const transactionLog = document.getElementById('admin-transaction-log');\n      if (transactionLog) {\n        transactionLog.innerHTML = '';\n        const recent = syncData.recentTransactions.slice(-10).reverse();\n        recent.forEach(tx => this.updateTransactionDisplay(tx));\n      }\n    }\n\n    // Update VLC status\n    if (syncData.systemStatus) {\n      const vlcElement = document.getElementById('vlc-status');\n      if (vlcElement) {\n        const vlcStatus = syncData.systemStatus.vlc;\n        vlcElement.className = `status-dot status-dot--${vlcStatus === 'connected' ? 'connected' : 'disconnected'}`;\n        vlcElement.title = vlcStatus;\n      }\n    }\n\n    // Update devices\n    if (syncData.devices && Array.isArray(syncData.devices)) {\n      this.updateDeviceList(syncData.devices);\n    }\n\n    this.updateSystemDisplay();\n  }\n\n  /**\n   * Manually refresh all displays from cached data\n   * NOTE: Game Activity is now rendered by app.updateAdminPanel() which calls\n   * UIManager.renderGameActivity() for the #admin-game-activity container.\n   * Score display is handled by ScreenUpdateManager container handlers.\n   */\n  refreshAllDisplays() {\n    Debug.log('[MonitoringDisplay] refreshAllDisplays called');\n\n    // Refresh session display\n    Debug.log(`[MonitoringDisplay] Refreshing session display. Current session: ${this._currentSession ? this._currentSession.id : 'null'}`);\n    this.updateSessionDisplay(this._currentSession);\n\n    // Refresh device list\n    if (this.devices?.length > 0) {\n      this.updateDeviceList(this.devices);\n    }\n\n    this.updateSystemDisplay();\n    this.loadAvailableVideos();\n  }\n\n  /**\n   * Resume monitoring (socket reconnected)\n   */\n  resume() {\n    console.log('[MonitoringDisplay] Resuming monitoring...');\n    this._requestInitialState();\n  }\n\n  // ============================================\n  // UTILITY METHODS\n  // ============================================\n\n  /**\n   * Escape HTML to prevent XSS\n   */\n  escapeHtml(text) {\n    if (!text) return '';\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n\n  /**\n   * Format duration in ms to human readable\n   */\n  formatDuration(ms) {\n    if (!ms || ms < 0) return 'Unknown';\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n\n    if (hours > 0) {\n      return `${hours}h ${minutes % 60}m`;\n    } else if (minutes > 0) {\n      return `${minutes}m ${seconds % 60}s`;\n    } else {\n      return `${seconds}s`;\n    }\n  }\n\n  /**\n   * Cleanup event listeners\n   */\n  destroy() {\n    if (this.client && this._messageHandler) {\n      this.client.removeEventListener('message:received', this._messageHandler);\n    }\n  }\n}\n\nexport default MonitoringDisplay;\n","/**\n * AdminController - Admin Module Lifecycle Manager\n * ES6 Module - Browser Only\n *\n * Responsibilities:\n * - Creates all admin modules once\n * - Guards against re-initialization\n * - Coordinates pause/resume on connection state changes\n * - Clean module destruction\n *\n * Does NOT handle:\n * - Connection state (ConnectionManager)\n * - WebSocket messages (OrchestratorClient)\n * - Token management (ConnectionManager)\n */\n\nimport { SessionManager } from '../admin/SessionManager.js';\nimport { VideoController } from '../admin/VideoController.js';\nimport { DisplayController } from '../admin/DisplayController.js';\nimport { SystemMonitor } from '../admin/SystemMonitor.js';\nimport { AdminOperations } from '../admin/AdminOperations.js';\nimport { MonitoringDisplay } from '../admin/MonitoringDisplay.js';\n\nexport class AdminController extends EventTarget {\n  constructor(client, dataManager, teamRegistry = null) {\n    super();\n    this.client = client; // OrchestratorClient reference for admin modules to use\n    this.dataManager = dataManager; // DataManager reference for MonitoringDisplay\n    this.teamRegistry = teamRegistry; // TeamRegistry for team dropdown sync\n    this.modules = null;\n    this.initialized = false;\n  }\n\n  /**\n   * Initialize all admin modules\n   * Guards against re-initialization\n   * @emits initialized - Admin modules ready\n   */\n  initialize() {\n    // Guard against re-initialization\n    if (this.initialized) {\n      console.warn('AdminController: Already initialized');\n      return;\n    }\n\n    // Create all admin modules with dependency injection\n    this.modules = {\n      sessionManager: new SessionManager(this.client),\n      videoController: new VideoController(this.client),\n      displayController: new DisplayController(this.client),\n      systemMonitor: new SystemMonitor(this.client),\n      adminOperations: new AdminOperations(this.client),\n      monitoringDisplay: new MonitoringDisplay(this.client, this.dataManager, this.teamRegistry)\n    };\n\n    this.initialized = true;\n    this.dispatchEvent(new CustomEvent('initialized'));\n  }\n\n  /**\n   * Get specific admin module\n   * @param {string} name - Module name (sessionManager, videoController, systemMonitor, etc.)\n   * @returns {Object} Module instance\n   * @throws {Error} If not initialized\n   */\n  getModule(name) {\n    if (!this.initialized) {\n      throw new Error('Admin modules not initialized');\n    }\n\n    if (!this.modules[name]) {\n      throw new Error(`Unknown module: ${name}`);\n    }\n\n    return this.modules[name];\n  }\n\n  /**\n   * Pause admin operations (called on disconnect)\n   */\n  pause() {\n    if (!this.modules) return;\n\n    // Pause modules that support pausing\n    if (this.modules.sessionManager?.pause) {\n      this.modules.sessionManager.pause();\n    }\n    if (this.modules.videoController?.pause) {\n      this.modules.videoController.pause();\n    }\n  }\n\n  /**\n   * Resume admin operations (called on reconnect)\n   */\n  resume() {\n    if (!this.modules) return;\n\n    // Resume modules that support resuming\n    if (this.modules.sessionManager?.resume) {\n      this.modules.sessionManager.resume();\n    }\n    if (this.modules.videoController?.resume) {\n      this.modules.videoController.resume();\n    }\n    if (this.modules.monitoringDisplay?.resume) {\n      this.modules.monitoringDisplay.resume();\n    }\n  }\n\n  /**\n   * Destroy all admin modules\n   */\n  destroy() {\n    // Graceful cleanup - no error if not initialized\n    if (!this.modules) return;\n\n    // Destroy all modules\n    Object.values(this.modules).forEach(module => {\n      if (module?.destroy) {\n        module.destroy();\n      }\n    });\n\n    this.modules = null;\n    this.initialized = false;\n  }\n}\n\n// Named and default exports\nexport default AdminController;\n","/**\n * NetworkedSession - Service Factory and Lifecycle Orchestrator\n * ES6 Module - Browser Only\n *\n * Responsibilities:\n * - Creates all networked services in correct order\n * - Wires event-driven coordination between services\n * - Manages complete session lifecycle (initialize, destroy)\n * - Single source of truth for service references\n *\n * Does NOT handle:\n * - WebSocket details (OrchestratorClient)\n * - Token validation (ConnectionManager)\n * - Retry logic (ConnectionManager)\n * - Admin UI operations (AdminController)\n */\n\nimport OrchestratorClient from './orchestratorClient.js';\nimport ConnectionManager from './connectionManager.js';\nimport NetworkedQueueManager from './networkedQueueManager.js';\nimport AdminController from '../app/adminController.js';\n\nexport class NetworkedSession extends EventTarget {\n  constructor(config, dataManager, teamRegistry = null) {\n    super();\n    this.config = config; // { url, deviceId, stationName, token }\n    this.dataManager = dataManager; // DataManager reference for AdminController\n    this.teamRegistry = teamRegistry; // TeamRegistry for team dropdown sync\n    this.services = null;\n    this.state = 'disconnected'; // disconnected, connecting, connected, error\n  }\n\n  /**\n   * Initialize session - creates services, wires events, initiates connection\n   * @returns {Promise<void>}\n   * @throws {Error} If initialization fails\n   * @emits session:ready - All services initialized and connected\n   * @emits session:error - Initialization failed\n   */\n  async initialize() {\n    if (this.services) {\n      throw new Error('Session already initialized');\n    }\n\n    try {\n      this._createServices();\n      this._wireEventHandlers();\n      await this._initiateConnection();\n\n      this.state = 'connected';\n      this.dispatchEvent(new CustomEvent('session:ready', {\n        detail: { services: this.services },\n      }));\n    } catch (error) {\n      this.state = 'error';\n\n      // CRITICAL: Cleanup on initialization failure\n      // Prevents event listener leaks and zombie services\n      await this.destroy();\n\n      this.dispatchEvent(new CustomEvent('session:error', {\n        detail: { error },\n      }));\n      throw error;\n    }\n  }\n\n  /**\n   * Get a service by name\n   * @param {string} name - Service name (connectionManager, client, queueManager, adminController)\n   * @returns {Object} Service instance\n   * @throws {Error} If session not initialized\n   */\n  getService(name) {\n    if (!this.services) {\n      throw new Error('Session not initialized');\n    }\n\n    if (!this.services[name]) {\n      throw new Error(`Unknown service: ${name}`);\n    }\n\n    return this.services[name];\n  }\n\n  /**\n   * Destroy session - cleanup all services in reverse order\n   * @returns {Promise<void>}\n   */\n  async destroy() {\n    // Graceful cleanup - no error if not initialized\n    if (!this.services) return;\n\n    // Destroy in reverse order (LIFO)\n    if (this.services.adminController) {\n      this.services.adminController.destroy();\n    }\n\n    if (this.services.queueManager) {\n      this.services.queueManager.destroy();\n    }\n\n    if (this.services.connectionManager) {\n      // Remove event listeners first\n      if (this._connectedHandler) {\n        this.services.connectionManager.removeEventListener('connected', this._connectedHandler);\n      }\n      if (this._disconnectedHandler) {\n        this.services.connectionManager.removeEventListener('disconnected', this._disconnectedHandler);\n      }\n      if (this._authRequiredHandler) {\n        this.services.connectionManager.removeEventListener('auth:required', this._authRequiredHandler);\n      }\n\n      await this.services.connectionManager.disconnect();\n    }\n\n    if (this.services.client) {\n      // Remove message handler first\n      if (this._messageHandler) {\n        this.services.client.removeEventListener('message:received', this._messageHandler);\n      }\n      this.services.client.destroy();\n    }\n\n    this.services = null;\n    this.state = 'disconnected';\n  }\n\n  /**\n   * Create all services in correct order\n   * @private\n   */\n  _createServices() {\n    // Create services in dependency order\n    this.services = {};\n\n    // 1. OrchestratorClient (no dependencies)\n    this.services.client = new OrchestratorClient({\n      url: this.config.url,\n      deviceId: this.config.deviceId,\n    });\n\n    // 2. ConnectionManager (depends on client)\n    this.services.connectionManager = new ConnectionManager({\n      url: this.config.url,\n      deviceId: this.config.deviceId,\n      token: this.config.token,\n      client: this.services.client,\n    });\n\n    // 3. NetworkedQueueManager (depends on client)\n    this.services.queueManager = new NetworkedQueueManager({\n      client: this.services.client,\n      deviceId: this.config.deviceId,\n      debug: console\n    });\n\n    // 4. AdminController (depends on client, dataManager, and teamRegistry)\n    this.services.adminController = new AdminController(this.services.client, this.dataManager, this.teamRegistry);\n  }\n\n  /**\n   * Wire event handlers between services\n   * @private\n   */\n  _wireEventHandlers() {\n    // Store handler references for cleanup\n    this._connectedHandler = () => {\n      // On connection: initialize admin and sync queue\n      if (this.services.adminController) {\n        this.services.adminController.initialize();\n      }\n      if (this.services.queueManager) {\n        this.services.queueManager.syncQueue();\n      }\n    };\n\n    this._disconnectedHandler = () => {\n      // On disconnection: pause admin operations\n      if (this.services.adminController) {\n        this.services.adminController.pause();\n      }\n    };\n\n    this._authRequiredHandler = () => {\n      // Forward auth:required event to session listeners\n      this.dispatchEvent(new CustomEvent('auth:required'));\n    };\n\n    // Global WebSocket ‚Üí DataManager event handler\n    // Updates state for ALL WebSocket events, regardless of active screen/view\n    this._messageHandler = (event) => {\n      const { type, payload } = event.detail;\n\n      switch (type) {\n        case 'score:updated':\n          this.dataManager.updateTeamScoreFromBackend(payload);\n          break;\n\n        case 'sync:full':\n          // Session boundary detection (DRY: same logic as session:update)\n          this._handleSessionBoundary(payload.session?.id);\n\n          // Restore scanned tokens from server state (handles reconnection)\n          if (payload.deviceScannedTokens) {\n            this.dataManager.setScannedTokensFromServer(payload.deviceScannedTokens);\n          }\n\n          // Sync scores and transactions\n          if (payload.scores) {\n            payload.scores.forEach(s => this.dataManager.updateTeamScoreFromBackend(s));\n          }\n          if (payload.recentTransactions) {\n            payload.recentTransactions.forEach(tx => this.dataManager.addTransaction(tx));\n          }\n\n          // Sync player scans from server (Game Activity feature)\n          if (payload.playerScans) {\n            this.dataManager.setPlayerScansFromServer(payload.playerScans);\n          }\n          break;\n\n        case 'session:update':\n          // Session lifecycle: detect boundary changes\n          if (payload.status === 'ended') {\n            this.dataManager.resetForNewSession(null);\n          } else {\n            this._handleSessionBoundary(payload.id);\n          }\n          break;\n\n        case 'transaction:new':\n          if (payload.transaction) {\n            // Use addTransactionFromBroadcast to store without re-submitting to backend\n            this.dataManager.addTransactionFromBroadcast(payload.transaction);\n          }\n          break;\n\n        case 'transaction:deleted':\n          if (payload.transactionId) {\n            this.dataManager.removeTransaction(payload.transactionId);\n          }\n          break;\n\n        case 'scores:reset':\n          this.dataManager.clearBackendScores();\n          break;\n\n        case 'player:scan':\n          // Player scanner activity - forward to DataManager for Game Activity tracking\n          this.dataManager.handlePlayerScan(payload);\n          break;\n      }\n    };\n\n    // Wire events\n    this.services.connectionManager.addEventListener('connected', this._connectedHandler);\n    this.services.connectionManager.addEventListener('disconnected', this._disconnectedHandler);\n    this.services.connectionManager.addEventListener('auth:required', this._authRequiredHandler);\n    this.services.client.addEventListener('message:received', this._messageHandler);\n  }\n\n  /**\n   * Handle session boundary detection (DRY helper)\n   * Resets DataManager only when session ID actually changes\n   * @param {string|null} newSessionId - New session ID from server\n   * @private\n   */\n  _handleSessionBoundary(newSessionId) {\n    const currentSessionId = this.dataManager.currentSessionId;\n\n    // Only reset when session ID actually changes (new session started)\n    if (newSessionId && newSessionId !== currentSessionId) {\n      this.dataManager.resetForNewSession(newSessionId);\n    }\n  }\n\n  /**\n   * Initiate connection via ConnectionManager\n   * @private\n   */\n  async _initiateConnection() {\n    await this.services.connectionManager.connect();\n  }\n}\n\nexport default NetworkedSession;\n","/**\n * App - Main Application Controller\n * ES6 Module\n *\n * Main application coordinator that handles:\n * - NFC processing pipeline\n * - Mode-specific initialization (networked vs standalone)\n * - Admin panel integration\n * - Event wiring between all modules\n * - Team management and transaction processing\n */\n\nimport Debug from '../utils/debug.js';\nimport UIManager from '../ui/uiManager.js';\nimport Settings from '../ui/settings.js';\nimport TokenManager from '../core/tokenManager.js';\n// DataManager import removed - use UnifiedDataManager via dependency injection\nimport NFCHandler from '../utils/nfcHandler.js';\nimport CONFIG from '../utils/config.js';\nimport InitializationSteps from './initializationSteps.js';\nimport { SessionModeManager } from './sessionModeManager.js'; // Import class, not singleton\nimport NetworkedSession from '../network/networkedSession.js';\n\n/**\n * Main Application Class\n * Coordinates all modules and handles user interaction\n *\n * Architecture: Dependency Injection + Event-Driven\n * - Dependencies injected via constructor for testability\n * - Session services received via session:ready event.detail\n * - No window.XXX global reaching (per Architecture Refactoring 2025-11)\n */\nclass App {\n  constructor(dependencies = {}) {\n    // Core dependencies (injected for testing, defaults for production)\n    this.debug = dependencies.debug || Debug;\n    this.uiManager = dependencies.uiManager || UIManager;\n    this.settings = dependencies.settings || Settings;\n    this.tokenManager = dependencies.tokenManager || TokenManager;\n    this.dataManager = dependencies.dataManager; // Required: inject via main.js\n    this.teamRegistry = dependencies.teamRegistry || null;\n    this.nfcHandler = dependencies.nfcHandler || NFCHandler;\n    this.config = dependencies.config || CONFIG;\n    this.initializationSteps = dependencies.initializationSteps || InitializationSteps;\n\n    // Session dependencies (injected after mode selection)\n    this.sessionModeManager = dependencies.sessionModeManager || null;\n    this.networkedSession = dependencies.networkedSession || null;\n\n    // Global reference for HTML onclick handlers (temporary until Phase 6)\n    this.showConnectionWizard = dependencies.showConnectionWizard || (typeof window !== 'undefined' ? window.showConnectionWizard : null);\n\n    // Instance state\n    this.currentTeamId = '';\n    this.nfcSupported = false;\n    this.currentInterventionTeamId = null; // For GM intervention features\n    this.viewController = this._createViewController();\n  }\n\n  /**\n   * Initialize application\n   * Runs 11-phase initialization sequence\n   */\n  async init() {\n    this.debug.log('App initializing...');\n\n    // Initialize UI (Phase 1D) - MUST be before showLoadingScreen\n    this.initializationSteps.initializeUIManager(this.uiManager);\n\n    // Show loading screen after UIManager initialized (Phase 0)\n    await this.initializationSteps.showLoadingScreen(this.uiManager);\n\n    // CRITICAL: Initialize SessionModeManager BEFORE viewController (Phase 1E)\n    // Store reference as instance property (no window global assignment)\n    this.sessionModeManager = this.initializationSteps.createSessionModeManager(SessionModeManager);\n\n    // Inject sessionModeManager and app into UIManager\n    // This allows UIManager to access session mode for rendering decisions\n    this.uiManager.sessionModeManager = this.sessionModeManager;\n    this.uiManager.app = this;\n\n    // Initialize view controller (Phase 1F)\n    this.initializationSteps.initializeViewController(this.viewController);\n\n    // Load settings (Phase 1G)\n    this.initializationSteps.loadSettings(this.settings);\n\n    // Load transaction history (Phase 1H)\n    this.initializationSteps.loadDataManager(this.dataManager, this.uiManager);\n\n    // Check NFC support (Phase 1I)\n    this.nfcSupported = await this.initializationSteps.detectNFCSupport(this.nfcHandler);\n\n    // Load token database (Phase 1A)\n    await this.initializationSteps.loadTokenDatabase(this.tokenManager, this.uiManager);\n\n    // Apply URL parameter mode override (Phase 1B)\n    this.initializationSteps.applyURLModeOverride(window.location.search, this.settings);\n\n    // Register service worker for PWA functionality (Phase 1J)\n    await this.initializationSteps.registerServiceWorker(navigator, this.uiManager);\n\n    // Connection restoration logic with full state validation (Phase 1C + Phase 4.1)\n    // Use validateAndDetermineInitialScreen for networked mode validation:\n    // - Validates JWT token expiration\n    // - Validates orchestrator reachability\n    // - Validates session exists\n    // If any validation fails, clears stale state and shows mode selection\n    const screenDecision = await this.initializationSteps.validateAndDetermineInitialScreen(this.sessionModeManager);\n\n    // Log validation result if present\n    if (screenDecision.validationResult) {\n      if (screenDecision.validationResult.valid) {\n        this.debug.log('[App] State validation passed - proceeding with auto-connect');\n      } else {\n        this.debug.log(`[App] State validation failed: ${screenDecision.validationResult.reason}`);\n      }\n    }\n\n    await this.initializationSteps.applyInitialScreenDecision(\n      screenDecision,\n      this.sessionModeManager,\n      this.uiManager,\n      this.showConnectionWizard,\n      this._initializeNetworkedMode.bind(this)\n    );\n  }\n\n  /**\n   * Wire event listeners for NetworkedSession lifecycle\n   * Event-driven architecture: Services provided via event.detail\n   * @private\n   */\n  _wireNetworkedSessionEvents() {\n    if (!this.networkedSession) {\n      this.debug.log('Cannot wire networked session events: session is null');\n      return;\n    }\n\n    // Listen for session:ready from NetworkedSession\n    // Services are provided via event.detail.services (per Architecture Refactoring 2025-11)\n    this.networkedSession.addEventListener('session:ready', (event) => {\n      this.debug.log('NetworkedSession ready - initializing admin modules');\n\n      // Event-driven: Receive services from event detail, not window lookup\n      if (event.detail && event.detail.services) {\n        this.debug.log('Received services via session:ready event.detail');\n      }\n\n      // Initialize admin modules when session is ready\n      if (this.viewController) {\n        this.viewController.initAdminModules();\n      }\n    });\n\n    // Listen for auth:required from NetworkedSession\n    this.networkedSession.addEventListener('auth:required', () => {\n      this.debug.log('Authentication required - showing connection wizard');\n      if (this.showConnectionWizard) {\n        this.showConnectionWizard();\n      }\n    });\n  }\n\n  /**\n   * Create view controller\n   * Manages scanner/admin/debug view switching in networked mode\n   * @private\n   */\n  _createViewController() {\n    const app = this;\n\n    return {\n      currentView: 'scanner',\n      views: ['scanner', 'admin', 'debug'],\n      adminInstances: null,\n\n      init() {\n        // Show view selector tabs in BOTH networked and standalone modes\n        // Phase 3: Admin panel is now available in standalone mode\n        const viewSelector = document.getElementById('viewSelector');\n        if (viewSelector) {\n          viewSelector.style.display = 'flex';\n        }\n\n        // Admin modules (WebSocket-based) only initialized in networked mode\n        // Standalone admin operations use dataManager directly\n      },\n\n      switchView(viewName) {\n        if (!this.views.includes(viewName)) {\n          console.error('Invalid view:', viewName);\n          app.uiManager.showError(`Invalid view: ${viewName}`);\n          return;\n        }\n\n        // Hide all view contents\n        document.querySelectorAll('.view-content').forEach(view => {\n          view.style.display = 'none';\n        });\n\n        // Show selected view\n        const selectedView = document.getElementById(`${viewName}-view`);\n        if (selectedView) {\n          selectedView.style.display = 'block';\n        }\n\n        // Update tab highlighting\n        document.querySelectorAll('.view-tab').forEach(tab => {\n          tab.classList.remove('active');\n        });\n        const activeTab = document.querySelector(`[data-view=\"${viewName}\"]`);\n        if (activeTab) {\n          activeTab.classList.add('active');\n        }\n\n        this.currentView = viewName;\n\n        // Trigger view-specific initialization\n        if (viewName === 'admin') {\n          // Initialize admin modules if not already done\n          if (!this.adminInstances) {\n            this.initAdminModules();\n          }\n\n          // Refresh admin panel\n          if (this.adminInstances) {\n            // Fetch current session state\n            this.fetchCurrentSession();\n          }\n          // Update admin panel displays\n          app.updateAdminPanel();\n        }\n      },\n\n      async fetchCurrentSession() {\n        // BUG FIX (Phase 2.3): Session state and display now handled by broadcasts\n        // SessionManager.currentSession updated from session:update broadcasts (event-driven)\n        // MonitoringDisplay updates DOM from session:update broadcasts\n        // No need to manually refresh display - broadcasts handle everything\n        // This follows event-driven architecture with clear separation of concerns\n\n        if (!this.adminInstances?.sessionManager) return;\n\n        app.debug.log(this.adminInstances.sessionManager.currentSession\n          ? 'Session active: ' + JSON.stringify(this.adminInstances.sessionManager.currentSession)\n          : 'No active session');\n      },\n\n      initAdminModules() {\n        // Only initialize in networked mode with valid connection\n        if (!app.sessionModeManager?.isNetworked()) {\n          console.log('Admin modules only available in networked mode');\n          return;\n        }\n\n        if (!app.networkedSession) {\n          console.error('NetworkedSession not initialized');\n          app.uiManager.showError('Network session not available. Check connection.');\n          return;\n        }\n\n        // Get admin modules from NetworkedSession's AdminController\n        const adminController = app.networkedSession.getService('adminController');\n\n        // Initialize admin modules if not already initialized\n        // This is safe to call multiple times (AdminController has guard)\n        if (!adminController.initialized) {\n          console.log('Initializing admin modules...');\n          adminController.initialize();\n        }\n\n        // Reference admin modules (created by AdminController)\n        this.adminInstances = {\n          sessionManager: adminController.getModule('sessionManager'),\n          videoController: adminController.getModule('videoController'),\n          displayController: adminController.getModule('displayController'),\n          systemMonitor: adminController.getModule('systemMonitor'),\n          adminOps: adminController.getModule('adminOperations'),\n          monitoring: adminController.getModule('monitoringDisplay')\n        };\n\n        // Note: MonitoringDisplay automatically registers event listeners\n        // for all monitoring display updates (session, video, system, scores, transactions)\n        // No need to manually register event listeners here\n\n        console.log('Admin modules referenced from AdminController');\n      }\n    };\n  }\n\n  // ========== Settings Management ==========\n\n  showSettings() {\n    this.uiManager.showScreen('settings');\n  }\n\n  saveSettings() {\n    this.settings.save();\n    this.uiManager.showScreen('teamEntry');\n  }\n\n  toggleMode() {\n    this.settings.mode = this.settings.mode === 'detective' ? 'blackmarket' : 'detective';\n\n    // Mode is stored in Settings and localStorage only\n    // No need to sync to services (they read from Settings)\n\n    this.uiManager.updateModeDisplay(this.settings.mode);\n\n    const scanScreen = document.getElementById('scanScreen');\n    if (scanScreen && scanScreen.classList.contains('active')) {\n      this.uiManager.updateSessionStats();\n    }\n\n    // Visual feedback\n    const indicator = document.getElementById('modeIndicator');\n    if (indicator) {\n      indicator.style.transform = `scale(${this.config.MODE_TOGGLE_SCALE})`;\n      setTimeout(() => {\n        indicator.style.transform = 'scale(1)';\n      }, this.config.ANIMATION_DURATION);\n    }\n  }\n\n  updateModeFromToggle() {\n    const modeToggle = document.getElementById('modeToggle');\n    if (modeToggle) {\n      this.settings.mode = modeToggle.checked ? 'blackmarket' : 'detective';\n      this.uiManager.updateModeDisplay(this.settings.mode);\n    }\n  }\n\n  // ========== Team Entry ==========\n\n  /**\n   * Initialize team entry UI\n   * UNIFIED: No mode branching - TeamRegistry handles mode differences\n   */\n  initTeamEntryUI() {\n    const teamInput = document.getElementById('teamNameInput');\n    const teamList = document.getElementById('teamList');\n    const listLabel = document.getElementById('teamListLabel');\n\n    // Label adapts to mode (TeamRegistry encapsulates this)\n    if (listLabel && this.teamRegistry) {\n      listLabel.textContent = this.teamRegistry.getTeamListLabel();\n    }\n\n    // Render team list with click handler\n    if (this.teamRegistry && teamList) {\n      this._renderTeamList(teamList);\n    }\n\n    // Focus input\n    if (teamInput) {\n      teamInput.value = '';\n      teamInput.focus();\n    }\n\n    // Wire teams:updated listener (once)\n    if (this.teamRegistry && !this._teamsListenerAdded) {\n      this._teamsListenerAdded = true;\n      this.teamRegistry.addEventListener('teams:updated', () => {\n        const list = document.getElementById('teamList');\n        if (list) this._renderTeamList(list);\n      });\n    }\n  }\n\n  /**\n   * Render clickable team list from TeamRegistry\n   * @param {HTMLElement} container - Team list container element\n   * @private\n   */\n  _renderTeamList(container) {\n    container.innerHTML = '';\n    const teams = this.teamRegistry.getTeamsForDisplay();\n\n    teams.forEach(teamName => {\n      const item = document.createElement('div');\n      item.className = 'team-list-item';\n      item.textContent = teamName;\n      item.setAttribute('role', 'option');\n      item.addEventListener('click', () => {\n        document.getElementById('teamNameInput').value = teamName;\n        this.confirmTeamId(); // Auto-proceed when clicking existing team\n      });\n      container.appendChild(item);\n    });\n  }\n\n  /**\n   * Confirm team selection and proceed to scan screen\n   * UNIFIED: Reads from single input, TeamRegistry handles mode-specific logic\n   */\n  async confirmTeamId() {\n    const teamInput = document.getElementById('teamNameInput');\n    const teamName = teamInput?.value?.trim();\n\n    if (!teamName) {\n      this.uiManager.showError('Please enter a team name');\n      return;\n    }\n\n    // TeamRegistry handles mode-specific behavior (localStorage vs backend)\n    const result = await this.teamRegistry.selectTeam(teamName);\n    if (!result.success) {\n      this.uiManager.showError(result.error || 'Failed to select team');\n      return;\n    }\n\n    this.currentTeamId = teamName;\n\n    const currentTeamEl = document.getElementById('currentTeam');\n    if (currentTeamEl) currentTeamEl.textContent = teamName;\n\n    this.uiManager.updateSessionStats();\n    this.uiManager.showScreen('scan');\n\n    // Auto-start NFC scanning after team confirmation\n    await this._startNFCScanning();\n  }\n\n  // ========== Game Mode Selection ==========\n\n  /**\n   * Select game mode (networked or standalone)\n   * Per Architecture Refactoring 2025-11: App creates NetworkedSession\n   *\n   * @param {string} mode - 'networked' or 'standalone'\n   */\n  async selectGameMode(mode) {\n    if (!this.sessionModeManager) {\n      console.error('SessionModeManager not initialized');\n      this.uiManager.showError('System error: SessionModeManager not initialized. Please reload the page.');\n      return;\n    }\n\n    try {\n      // For networked mode: Check auth token first before locking mode\n      if (mode === 'networked') {\n        const token = localStorage.getItem('aln_auth_token');\n\n        if (!token || !this._isTokenValid(token)) {\n          // No valid token - show connection wizard WITHOUT locking mode yet\n          // The wizard's handleConnectionSubmit will lock mode after successful auth\n          this.debug.log('Networked mode selected - showing connection wizard (mode not locked yet)');\n          if (this.showConnectionWizard) {\n            this.showConnectionWizard();\n          } else {\n            this.uiManager.showError('Connection wizard not available');\n          }\n          return;\n        }\n\n        // Valid token exists - lock mode and initialize\n        this.sessionModeManager.setMode(mode);\n        this.debug.log(`Game mode locked: ${mode}`);\n        await this._initializeNetworkedMode();\n      } else if (mode === 'standalone') {\n        // Standalone mode: lock immediately and proceed\n        this.sessionModeManager.setMode(mode);\n        this.debug.log(`Game mode locked: ${mode}`);\n\n        // Phase 3: Add body class for CSS-based feature hiding\n        document.body.classList.add('standalone-mode');\n        document.body.classList.remove('networked-mode');\n\n        // Clear phantom data from previous sessions\n        localStorage.removeItem('standaloneSession');\n\n        // Initialize UnifiedDataManager for standalone mode\n        // This creates LocalStorage strategy and loads from localStorage if available\n        this.dataManager.sessionModeManager = this.sessionModeManager;\n        await this.dataManager.initializeStandaloneMode();\n\n        this.debug.log('UnifiedDataManager initialized for standalone mode');\n\n        // Phase 3: Initialize view controller (shows admin tabs in standalone mode too)\n        this.viewController.init();\n\n        // Phase 3: Initialize admin session display in standalone mode\n        const sessionContainer = document.getElementById('session-status-container');\n        if (sessionContainer) {\n          this.uiManager.renderSessionStatus(sessionContainer);\n        }\n\n        // Wire TeamRegistry for unified API (standalone)\n        if (this.teamRegistry) {\n          this.teamRegistry.sessionModeManager = this.sessionModeManager;\n        }\n\n        // Initialize team entry UI\n        this.initTeamEntryUI();\n\n        this.uiManager.showScreen('teamEntry');\n      }\n    } catch (error) {\n      console.error('Failed to set game mode:', error);\n      this.uiManager.showError(`Failed to set game mode: ${error.message}`);\n\n      // Re-throw so caller (ConnectionWizard) can display error in modal\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize networked mode by creating NetworkedSession\n   * Per Architecture Refactoring 2025-11 line 166: \"App creates NetworkedSession with config\"\n   * @private\n   */\n  async _initializeNetworkedMode() {\n    // Phase 3: Add body class for CSS-based feature display\n    document.body.classList.add('networked-mode');\n    document.body.classList.remove('standalone-mode');\n\n    // Get configuration from localStorage (set by connection wizard)\n    const orchestratorUrl = localStorage.getItem('aln_orchestrator_url') || 'https://localhost:3000';\n    const deviceId = this.settings?.deviceId || 'GM_STATION_UNKNOWN';\n    const token = localStorage.getItem('aln_auth_token');\n\n    // Check if we have a valid token\n    if (token && this._isTokenValid(token)) {\n      this.debug.log('Valid token found - creating NetworkedSession...');\n\n      // Show reconnecting toast\n      this.uiManager.showToast('Reconnecting to orchestrator...', 'info', 3000);\n\n      // Create NetworkedSession (Service Orchestrator)\n      this.networkedSession = new NetworkedSession({\n        url: orchestratorUrl,\n        deviceId: deviceId,\n        stationName: this.settings?.stationName || 'GM Station',\n        token: token\n      }, this.dataManager, this.teamRegistry);\n\n      // Attempt connection\n      try {\n        // Wire event listeners BEFORE initializing (so we catch session:ready)\n        this._wireNetworkedSessionEvents();\n\n        // CRITICAL: Initialize UnifiedDataManager BEFORE WebSocket connects\n        // NetworkedSession._messageHandler calls dataManager methods on sync:full\n        // If _networkedStrategy doesn't exist, score updates are silently dropped\n        this.dataManager.sessionModeManager = this.sessionModeManager;\n        await this.dataManager.initializeNetworkedMode(null); // Socket added after connect\n        this.debug.log('UnifiedDataManager initialized for networked mode (socket pending)');\n\n        await this.networkedSession.initialize();\n        this.debug.log('NetworkedSession initialized - session:ready will fire');\n\n        // Update NetworkedStorage with the actual socket reference\n        const client = this.networkedSession.getService('client');\n        if (client?.socket && this.dataManager._networkedStrategy) {\n          this.dataManager._networkedStrategy.socket = client.socket;\n          this.debug.log('NetworkedStorage socket reference updated');\n        }\n\n        // Wire TeamRegistry for unified API (networked)\n        if (this.teamRegistry) {\n          this.teamRegistry.sessionModeManager = this.sessionModeManager;\n          if (client) {\n            this.teamRegistry.orchestratorClient = client;\n          }\n        }\n\n        // Close connection wizard modal (if open) and show team entry screen\n        // Per Architecture Refactoring 2025-11: App manages UI transitions after NetworkedSession ready\n        const connectionModal = document.getElementById('connectionModal');\n        if (connectionModal && connectionModal.style.display !== 'none') {\n          connectionModal.style.display = 'none';\n          this.debug.log('Connection wizard closed after successful initialization');\n        }\n\n        // Show viewSelector (admin panel tabs) in networked mode\n        const viewSelector = document.getElementById('viewSelector');\n        if (viewSelector) {\n          viewSelector.style.display = 'flex';\n        }\n\n        // Transition to team entry screen\n        this.uiManager.showScreen('teamEntry');\n        this.debug.log('UI transitioned to team entry screen');\n\n      } catch (error) {\n        console.error('NetworkedSession initialization failed:', error);\n        // Clean up failed session\n        if (this.networkedSession) {\n          await this.networkedSession.destroy();\n          this.networkedSession = null;\n        }\n        throw error;\n      }\n    } else {\n      // No valid token - show connection wizard\n      this.debug.log('No valid token - showing connection wizard');\n      if (this.showConnectionWizard) {\n        this.showConnectionWizard();\n      } else {\n        this.uiManager.showError('Connection wizard not available');\n      }\n    }\n  }\n\n  /**\n   * Check if JWT token is valid (not expired, with 1-minute buffer)\n   * @private\n   */\n  _isTokenValid(token) {\n    if (!token) return false;\n\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) return false;\n\n      const payload = JSON.parse(atob(parts[1]));\n      const exp = payload.exp;\n\n      if (!exp) return false;\n\n      const now = Math.floor(Date.now() / 1000);\n      const bufferMinutes = 1;\n      return exp > (now + (bufferMinutes * 60));\n    } catch (error) {\n      console.error('Token validation error:', error);\n      return false;\n    }\n  }\n\n  // ========== Helper Methods ==========\n\n  /**\n   * Helper to switch to a specific view\n   */\n  switchView(viewName) {\n    this.viewController.switchView(viewName);\n  }\n\n  // ========== Scanning ==========\n\n  /**\n   * @deprecated Use _startNFCScanning() instead. Kept for console debugging.\n   */\n  async startScan() {\n    console.warn('startScan() is deprecated - NFC now auto-starts on team confirmation');\n    await this._startNFCScanning();\n  }\n\n  /**\n   * Start NFC scanning without button state management\n   * Called automatically on team confirmation\n   * @private\n   */\n  async _startNFCScanning() {\n    if (!this.nfcSupported) {\n      this.debug.log('NFC not supported - scan simulation available via Manual Entry');\n      return;\n    }\n\n    const status = document.getElementById('scanStatus');\n\n    try {\n      if (status) {\n        status.textContent = 'Scanning... Tap a token';\n      }\n\n      await this.nfcHandler.startScan(\n        (result) => this.processNFCRead(result),\n        (err) => {\n          this.debug.log(`NFC read error: ${err?.message || err}`, true);\n          if (status) {\n            status.textContent = 'Read error. Tap token again.';\n          }\n        }\n      );\n\n      this.debug.log('NFC scanning started automatically');\n    } catch (error) {\n      this.debug.log(`NFC start error: ${error.message}`, true);\n      if (status) {\n        status.textContent = 'NFC unavailable. Use Manual Entry.';\n      }\n    }\n  }\n\n  simulateScan() {\n    const status = document.getElementById('scanStatus');\n    if (status) {\n      status.textContent = 'Demo Mode: Simulating scan...';\n    }\n\n    setTimeout(() => {\n      const result = this.nfcHandler.simulateScan();\n      this.processNFCRead(result);\n    }, this.config.SCAN_SIMULATION_DELAY);\n  }\n\n  async processNFCRead(result) {\n    // Handle NFC read errors (no serial fallback - errors returned from NFCHandler)\n    if (result.source === 'error') {\n      this.debug.log(`NFC read failed: ${result.error}`, true);\n      this.uiManager.showError('Could not read token - please re-tap');\n      return;\n    }\n\n    this.debug.log(`Processing token: \"${result.id}\" (from ${result.source})`);\n    this.debug.log(`Token ID length: ${result.id.length} characters`);\n\n    // VALIDATION: Ensure team is selected before processing\n    if (!this.currentTeamId || this.currentTeamId.trim() === '') {\n      this.debug.log('ERROR: No team selected - cannot process token', true);\n      this.uiManager.showError('Please select a team before scanning tokens');\n      return;\n    }\n\n    // Trim any whitespace\n    const cleanId = result.id.trim();\n    this.debug.log(`Cleaned ID: \"${cleanId}\" (length: ${cleanId.length})`);\n\n    // Look up token first to get normalized ID (findToken handles case variations)\n    const tokenData = this.tokenManager.findToken(cleanId);\n\n    // Use matched ID for duplicate check (handles case variations)\n    const tokenId = tokenData ? tokenData.matchedId : cleanId;\n\n    // Check for duplicate using normalized ID\n    // UnifiedDataManager handles this for both modes\n    if (this.dataManager.isTokenScanned(tokenId)) {\n      this.debug.log(`Duplicate token detected: ${tokenId}`, true);\n      this.showDuplicateError(tokenId);\n      return;\n    }\n\n    if (!tokenData) {\n      await this.recordTransaction(null, cleanId, true);\n    } else {\n      await this.recordTransaction(tokenData.token, tokenData.matchedId, false);\n    }\n  }\n\n  showDuplicateError(tokenId) {\n    const statusEl = document.getElementById('resultStatus');\n    if (statusEl) {\n      statusEl.className = 'status-message error';\n      statusEl.innerHTML = `\n        <h2>Token Already Scanned</h2>\n        <p style=\"font-size: 14px;\">This token has been used</p>\n        <p style=\"font-size: 12px; color: #666;\">ID: ${tokenId}</p>\n      `;\n    }\n\n    const rfidEl = document.getElementById('resultRfid');\n    if (rfidEl) {\n      rfidEl.textContent = tokenId;\n    }\n\n    const typeEl = document.getElementById('resultType');\n    if (typeEl) {\n      typeEl.textContent = 'DUPLICATE';\n      typeEl.style.color = '#FF5722';\n    }\n\n    const groupEl = document.getElementById('resultGroup');\n    if (groupEl) {\n      groupEl.textContent = 'Previously scanned';\n    }\n\n    const valueEl = document.getElementById('resultValue');\n    if (valueEl) {\n      valueEl.textContent = 'No points awarded';\n    }\n\n    this.uiManager.showScreen('result');\n  }\n\n  async recordTransaction(token, tokenId, isUnknown) {\n    const transaction = {\n      timestamp: new Date().toISOString(),\n      deviceId: this.settings.deviceId,\n      mode: this.settings.mode,\n      teamId: this.currentTeamId,\n      rfid: tokenId,\n      tokenId: tokenId,  // Add tokenId for consistency with backend\n      memoryType: isUnknown ? 'UNKNOWN' : (token?.SF_MemoryType || 'UNKNOWN'),\n      group: isUnknown ? `Unknown: ${tokenId}` : (token?.SF_Group || ''),\n      tokenGroup: isUnknown ? '' : (token?.SF_Group || ''),  // For group completion detection\n      valueRating: isUnknown ? 0 : (token?.SF_ValueRating || 0),\n      isUnknown: isUnknown\n    };\n\n    // Calculate points for blackmarket mode\n    if (this.settings.mode === 'blackmarket' && !isUnknown) {\n      transaction.points = this.dataManager.calculateTokenValue(transaction);\n      // DIAGNOSTIC: Log calculated points\n      console.log('[app.js] Transaction points calculated:', {\n        tokenId: transaction.tokenId,\n        valueRating: transaction.valueRating,\n        memoryType: transaction.memoryType,\n        calculatedPoints: transaction.points,\n        tokenGroup: transaction.tokenGroup\n      });\n    } else {\n      transaction.points = 0;\n      console.log('[app.js] Transaction points set to 0 (detective mode or unknown token)');\n    }\n\n    // Submit transaction based on session mode\n    if (this.sessionModeManager && this.sessionModeManager.isNetworked()) {\n      // Networked mode - DON'T add to DataManager yet (will be added when backend confirms)\n      this.dataManager.markTokenAsScanned(tokenId);  // Still mark as scanned to prevent duplicates\n\n      // Get queue manager from NetworkedSession\n      if (!this.networkedSession) {\n        throw new Error('Cannot scan: NetworkedSession not initialized. Please reconnect.');\n      }\n\n      const queueManager = this.networkedSession.getService('queueManager');\n\n      // Use queue manager for reliable delivery\n      const txId = queueManager.queueTransaction({\n        tokenId: tokenId,\n        teamId: this.currentTeamId,\n        deviceId: this.settings.deviceId,\n        deviceType: 'gm',  // BUG #1 FIX: Required by backend validators\n        mode: this.settings.mode,  // AsyncAPI contract field (was 'mode')\n        summary: token?.summary || null,  // Include summary for persistence (backend AsyncAPI contract)\n        timestamp: transaction.timestamp  // Use same timestamp\n      });\n      this.debug.log(`Transaction queued for orchestrator: ${txId}`);\n    } else {\n      // Standalone mode - use UnifiedDataManager (LocalStorage strategy)\n      if (this.sessionModeManager && this.sessionModeManager.isStandalone()) {\n        // Add transaction via UnifiedDataManager (delegates to LocalStorage strategy)\n        // LocalStorage handles scoring, group bonuses, and persists to localStorage\n        await this.dataManager.addTransaction(transaction);\n        this.dataManager.markTokenAsScanned(tokenId);\n        this.debug.log('Transaction stored via UnifiedDataManager (standalone mode)');\n      } else {\n        // No session mode selected yet - should not happen, but handle gracefully\n        this.debug.log('Warning: No session mode selected - cannot process transaction', true);\n        this.uiManager.showError('Please select a game mode first');\n        return;\n      }\n    }\n\n    if (this.settings.mode === 'blackmarket' && !isUnknown) {\n      // Use UnifiedDataManager for all modes\n      const tokenScore = this.dataManager.calculateTokenValue(transaction);\n      this.debug.log(`Token scored: $${tokenScore.toLocaleString()}`);\n    }\n\n    this.uiManager.updateSessionStats();\n    this.uiManager.showTokenResult(token, tokenId, isUnknown);\n  }\n\n  manualEntry() {\n    const rfid = prompt('Enter RFID manually:');\n    if (rfid && rfid.trim()) {\n      this.processNFCRead({\n        id: rfid.trim(),\n        source: 'manual',\n        raw: rfid.trim()\n      });\n    }\n  }\n\n  cancelScan() {\n    this.nfcHandler.stopScan();\n    this.currentTeamId = '';\n    this.uiManager.updateTeamDisplay('');\n    this.uiManager.showScreen('teamEntry');\n  }\n\n  continueScan() {\n    this.uiManager.updateSessionStats();\n    this.uiManager.showScreen('scan');\n  }\n\n  finishTeam() {\n    this.currentTeamId = '';\n    // Note: Do NOT clear DataManager session here - scannedTokens must persist\n    // across team switches for cross-team duplicate detection\n    this.uiManager.updateTeamDisplay('');\n    this.uiManager.showScreen('teamEntry');\n  }\n\n  // ========== History ==========\n\n  showHistory() {\n    this.uiManager.updateHistoryStats();\n    // Use unified Game Activity renderer (same as admin panel)\n    const historyContainer = document.getElementById('historyContainer');\n    if (historyContainer) {\n      this.uiManager.renderGameActivity(historyContainer, { showSummary: true, showFilters: true });\n    }\n    this.uiManager.showScreen('history');\n  }\n\n  closeHistory() {\n    // Default to teamEntry if no valid previous screen\n    const targetScreen = this.uiManager.previousScreen || 'teamEntry';\n    this.uiManager.showScreen(targetScreen);\n  }\n\n  // ========== Scoreboard ==========\n\n  showScoreboard() {\n    if (this.settings.mode !== 'blackmarket') {\n      this.debug.log('Scoreboard only available in Black Market mode');\n      return;\n    }\n    this.uiManager.renderScoreboard();\n    this.uiManager.showScreen('scoreboard');\n  }\n\n  closeScoreboard() {\n    // Default to teamEntry if no valid previous screen\n    const targetScreen = this.uiManager.previousScreen || 'teamEntry';\n    this.uiManager.showScreen(targetScreen);\n  }\n\n  // ========== Team Details ==========\n\n  showTeamDetails(teamId) {\n    // CRITICAL: teamDetailsScreen is inside scanner-view, so switch to scanner view first\n    // if currently in admin view (common when clicking team from admin panel score board)\n    if (this.viewController && this.viewController.currentView === 'admin') {\n      this.viewController.switchView('scanner');\n    }\n\n    // CRITICAL: Track current team for intervention actions (deletion, score adjustment)\n    this.currentInterventionTeamId = teamId;\n\n    const transactions = this.dataManager.getTeamTransactions(teamId);\n    this.uiManager.renderTeamDetails(teamId, transactions);\n    this.uiManager.showScreen('teamDetails');\n  }\n\n  closeTeamDetails() {\n    this.uiManager.showScreen('scoreboard');\n  }\n\n  // ========== Admin Actions ==========\n  // These methods wrap calls to AdminModule functionality\n\n  async adminCreateSession() {\n    const name = prompt('Enter session name:');\n    if (!name) return;\n\n    const isStandalone = this.sessionModeManager?.isStandalone();\n\n    // Standalone mode: Use UnifiedDataManager (LocalStorage strategy)\n    if (isStandalone) {\n      try {\n        await this.dataManager.createSession(name.trim(), []);\n        this.debug.log(`Session created (standalone): ${name}`);\n        this.uiManager.showToast('Session created', 'success');\n\n        // Refresh session display\n        this._refreshAdminSessionDisplay();\n      } catch (error) {\n        console.error('Failed to create session (standalone):', error);\n        this.uiManager.showError(`Failed to create session: ${error.message}`);\n      }\n      return;\n    }\n\n    // Networked mode: Use SessionManager (existing code)\n    if (!this.viewController.adminInstances?.sessionManager) {\n      alert('Admin functions not available. Please ensure you are connected.');\n      return;\n    }\n\n    try {\n      await this.viewController.adminInstances.sessionManager.createSession(name);\n      this.debug.log(`Session created: ${name}`);\n    } catch (error) {\n      console.error('Failed to create session:', error);\n      this.uiManager.showError('Failed to create session. Check connection.');\n    }\n  }\n\n  async adminPauseSession() {\n    const isStandalone = this.sessionModeManager?.isStandalone();\n\n    // Standalone mode: Use UnifiedDataManager\n    if (isStandalone) {\n      try {\n        const result = await this.dataManager.pauseSession();\n        if (result.success) {\n          this.debug.log('Session paused (standalone)');\n          this.uiManager.showToast('Session paused', 'info');\n          this._refreshAdminSessionDisplay();\n        } else {\n          this.uiManager.showError(result.error || 'Failed to pause session');\n        }\n      } catch (error) {\n        console.error('Failed to pause session (standalone):', error);\n        this.uiManager.showError(`Failed to pause session: ${error.message}`);\n      }\n      return;\n    }\n\n    // Networked mode (existing code)\n    if (!this.viewController.adminInstances?.sessionManager) {\n      alert('Admin functions not available.');\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.sessionManager.pauseSession();\n      this.debug.log('Session paused');\n    } catch (error) {\n      console.error('Failed to pause session:', error);\n      this.uiManager.showError('Failed to pause session.');\n    }\n  }\n\n  async adminResumeSession() {\n    const isStandalone = this.sessionModeManager?.isStandalone();\n\n    // Standalone mode: Use UnifiedDataManager\n    if (isStandalone) {\n      try {\n        const result = await this.dataManager.resumeSession();\n        if (result.success) {\n          this.debug.log('Session resumed (standalone)');\n          this.uiManager.showToast('Session resumed', 'success');\n          this._refreshAdminSessionDisplay();\n        } else {\n          this.uiManager.showError(result.error || 'Failed to resume session');\n        }\n      } catch (error) {\n        console.error('Failed to resume session (standalone):', error);\n        this.uiManager.showError(`Failed to resume session: ${error.message}`);\n      }\n      return;\n    }\n\n    // Networked mode (existing code)\n    if (!this.viewController.adminInstances?.sessionManager) {\n      alert('Admin functions not available.');\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.sessionManager.resumeSession();\n      this.debug.log('Session resumed');\n    } catch (error) {\n      console.error('Failed to resume session:', error);\n      this.uiManager.showError('Failed to resume session.');\n    }\n  }\n\n  async adminEndSession() {\n    if (!confirm('Are you sure you want to end the session?')) return;\n\n    const isStandalone = this.sessionModeManager?.isStandalone();\n\n    // Standalone mode: Use UnifiedDataManager\n    if (isStandalone) {\n      try {\n        await this.dataManager.endSession();\n        this.debug.log('Session ended (standalone)');\n        this.uiManager.showToast('Session ended', 'info');\n        this._refreshAdminSessionDisplay();\n      } catch (error) {\n        console.error('Failed to end session (standalone):', error);\n        this.uiManager.showError(`Failed to end session: ${error.message}`);\n      }\n      return;\n    }\n\n    // Networked mode (existing code)\n    if (!this.viewController.adminInstances?.sessionManager) {\n      alert('Admin functions not available.');\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.sessionManager.endSession();\n      this.debug.log('Session ended');\n    } catch (error) {\n      console.error('Failed to end session:', error);\n      this.uiManager.showError('Failed to end session.');\n    }\n  }\n\n  async adminResetAndCreateNew() {\n    // Step 0: Confirm with user\n    const confirmReset = confirm(\n      'Reset system and start new session?\\n\\n' +\n      'This will:\\n' +\n      '‚Ä¢ Archive the current completed session\\n' +\n      '‚Ä¢ Clear all current data\\n' +\n      '‚Ä¢ Prepare system for a new game\\n\\n' +\n      'Continue?'\n    );\n\n    if (!confirmReset) return;\n\n    // Step 1: Get new session name\n    const name = prompt('Enter new session name:');\n    if (!name || name.trim() === '') {\n      alert('Session name is required');\n      return;\n    }\n\n    // Step 2: Verify admin instances available\n    if (!this.viewController.adminInstances?.sessionManager) {\n      alert('Admin functions not available. Please ensure you are connected to the orchestrator.');\n      return;\n    }\n\n    try {\n      // Step 3: Send system:reset command\n      this.debug.log('Sending system:reset command...');\n\n      await new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('System reset timeout (5s)'));\n        }, 5000);\n\n        const socket = this.viewController.adminInstances.sessionManager.connection.socket;\n\n        socket.once('gm:command:ack', (response) => {\n          clearTimeout(timeout);\n\n          if (response.data && response.data.success) {\n            this.debug.log('System reset successful');\n            resolve();\n          } else {\n            const errorMsg = response.data?.message || 'Reset failed';\n            reject(new Error(errorMsg));\n          }\n        });\n\n        socket.emit('gm:command', {\n          event: 'gm:command',\n          data: {\n            action: 'system:reset',\n            payload: {}\n          },\n          timestamp: new Date().toISOString()\n        });\n      });\n\n      this.debug.log('System reset complete, creating new session...');\n\n      // Step 4: Create new session\n      await this.viewController.adminInstances.sessionManager.createSession(name.trim());\n\n      this.debug.log(`New session created: ${name}`);\n\n      // Step 5: Show success feedback\n      if (this.uiManager.showToast) {\n        this.uiManager.showToast(`Session \"${name}\" started successfully`, 'success', 5000);\n      } else {\n        alert(`Session \"${name}\" created successfully!`);\n      }\n\n    } catch (error) {\n      console.error('Failed to reset and create session:', error);\n\n      const errorMsg = `Failed to reset and create session: ${error.message}`;\n\n      if (this.uiManager.showError) {\n        this.uiManager.showError(errorMsg);\n      } else {\n        alert(errorMsg);\n      }\n    }\n  }\n\n  async adminViewSessionDetails() {\n    const session = this.viewController.adminInstances?.sessionManager?.currentSession;\n\n    if (!session) {\n      alert('No session data available');\n      return;\n    }\n\n    // Format session details\n    const startTime = session.startTime ? new Date(session.startTime).toLocaleString() : 'Unknown';\n    const endTime = session.endTime ? new Date(session.endTime).toLocaleString() : 'Ongoing';\n    const duration = session.getDuration ? this.formatSessionDuration(session.getDuration()) : 'Unknown';\n\n    const details = `\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nSESSION DETAILS\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nName: ${session.name || 'Unnamed Session'}\nID: ${session.id}\nStatus: ${session.status.toUpperCase()}\n\nTIMING\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nStarted: ${startTime}\n${session.endTime ? 'Ended: ' + endTime : 'Status: In Progress'}\nDuration: ${duration}\n\nSTATISTICS\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nTotal Scans: ${session.metadata?.totalScans || 0}\nUnique Tokens: ${session.metadata?.uniqueTokensScanned?.length || 0}\nTeams: ${session.scores?.length || 0}\nGM Stations: ${session.connectedDevices?.filter(d => d.type === 'gm').length || 0}\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n    `.trim();\n\n    alert(details);\n  }\n\n  /**\n   * Helper: Format duration for session details\n   */\n  formatSessionDuration(ms) {\n    if (ms == null || ms < 0) return 'Unknown';\n\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n\n    const parts = [];\n    if (days > 0) parts.push(`${days}d`);\n    if (hours % 24 > 0) parts.push(`${hours % 24}h`);\n    if (minutes % 60 > 0 && parts.length < 2) parts.push(`${minutes % 60}m`);\n    if (seconds % 60 > 0 && parts.length < 2) parts.push(`${seconds % 60}s`);\n\n    return parts.length > 0 ? parts.join(' ') : '0s';\n  }\n\n  async adminPlayVideo() {\n    if (!this.viewController.adminInstances?.videoController) {\n      alert('Video controls not available.');\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.videoController.playVideo();\n    } catch (error) {\n      console.error('Failed to play video:', error);\n      this.uiManager.showError('Failed to play video.');\n    }\n  }\n\n  async adminPauseVideo() {\n    if (!this.viewController.adminInstances?.videoController) {\n      alert('Video controls not available.');\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.videoController.pauseVideo();\n    } catch (error) {\n      console.error('Failed to pause video:', error);\n      this.uiManager.showError('Failed to pause video.');\n    }\n  }\n\n  async adminStopVideo() {\n    if (!this.viewController.adminInstances?.videoController) {\n      alert('Video controls not available.');\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.videoController.stopVideo();\n    } catch (error) {\n      console.error('Failed to stop video:', error);\n      this.uiManager.showError('Failed to stop video.');\n    }\n  }\n\n  async adminSkipVideo() {\n    if (!this.viewController.adminInstances?.videoController) {\n      alert('Video controls not available.');\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.videoController.skipVideo();\n    } catch (error) {\n      console.error('Failed to skip video:', error);\n      this.uiManager.showError('Failed to skip video.');\n    }\n  }\n\n  // ============================================\n  async adminAddVideoToQueue() {\n    if (!this.viewController.adminInstances?.videoController) {\n      alert('Video controls not available.');\n      return;\n    }\n    const input = document.getElementById('manual-video-input');\n    const filename = input?.value;\n    if (!filename) {\n      alert('Enter a video filename (e.g., jaw001.mp4)');\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.videoController.addToQueue(filename);\n      this.uiManager.showToast(`Added ${filename} to queue`, 'success');\n      if (input) {\n        input.value = '';\n      }\n    } catch (error) {\n      console.error('Failed to add video to queue:', error);\n      this.uiManager.showError(`Failed to add video: ${error.message}`);\n    }\n  }\n\n  async adminClearQueue() {\n    if (!this.viewController.adminInstances?.videoController) {\n      alert('Video controls not available.');\n      return;\n    }\n    if (!confirm('Clear entire video queue?')) {\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.videoController.clearQueue();\n      this.uiManager.showToast('Queue cleared', 'success');\n    } catch (error) {\n      console.error('Failed to clear queue:', error);\n      this.uiManager.showError(`Failed to clear queue: ${error.message}`);\n    }\n  }\n\n  // ========== Admin Panel Display Updates ==========\n\n  updateAdminPanel() {\n    // In networked mode, delegate to MonitoringDisplay for session/device/video status\n    if (this.viewController?.adminInstances?.monitoring) {\n      this.viewController.adminInstances.monitoring.refreshAllDisplays();\n    }\n\n    // Render Game Activity (unified display for both modes)\n    // This replaces the old transaction log with the new token lifecycle view\n    const gameActivityContainer = document.getElementById('admin-game-activity');\n    if (gameActivityContainer) {\n      this.uiManager.renderGameActivity(gameActivityContainer, { showSummary: true, showFilters: true });\n    }\n\n    // Fallback scoreboard for standalone mode (no WebSocket connection)\n    // In networked mode, scores are rendered by ScreenUpdateManager container handlers\n    if (!this.viewController?.adminInstances?.monitoring) {\n      const scoreBoard = document.getElementById('admin-score-board');\n      if (scoreBoard) {\n        const teams = {};\n        this.dataManager.getTransactions().forEach(tx => {\n          if (!teams[tx.teamId]) {\n            teams[tx.teamId] = {\n              score: 0,\n              count: 0\n            };\n          }\n          teams[tx.teamId].count++;\n          // Use each transaction's mode, not the current setting\n          if (tx.mode === 'blackmarket') {\n            const score = this.dataManager.calculateTokenValue(tx);\n            teams[tx.teamId].score += score;\n          }\n        });\n\n        // Display scores\n        let html = '<table class=\"score-table\"><tr><th>Team</th><th>Tokens</th><th>Score</th></tr>';\n        Object.keys(teams).forEach(teamId => {\n          html += `<tr>\n            <td style=\"cursor: pointer; color: #007bff; text-decoration: underline;\"\n                data-action=\"app.showTeamDetails\" data-arg=\"${teamId}\">\n              ${teamId}\n            </td>\n            <td>${teams[teamId].count}</td>\n            <td>${teams[teamId].score.toLocaleString()}</td>\n          </tr>`;\n        });\n        html += '</table>';\n        scoreBoard.innerHTML = html;\n      }\n    }\n  }\n\n  async adminResetScores() {\n    if (!confirm('Reset all team scores to zero? Transactions will be preserved.')) return;\n\n    const isStandalone = this.sessionModeManager?.isStandalone();\n\n    // Standalone mode: Use UnifiedDataManager\n    if (isStandalone) {\n      try {\n        const result = await this.dataManager.resetScores();\n        if (result.success) {\n          this.debug.log('Scores reset (standalone)');\n          this.uiManager.showToast('All scores reset to zero', 'success');\n        } else {\n          this.uiManager.showError(result.error || 'Failed to reset scores');\n        }\n      } catch (error) {\n        console.error('Failed to reset scores (standalone):', error);\n        this.uiManager.showError(`Failed to reset scores: ${error.message}`);\n      }\n      return;\n    }\n\n    // Networked mode: Use AdminOps\n    if (!this.viewController.adminInstances?.adminOps) {\n      alert('Admin functions not available.');\n      return;\n    }\n\n    try {\n      await this.viewController.adminInstances.adminOps.resetScores();\n      this.debug.log('Scores reset');\n      this.uiManager.showToast('All scores reset', 'success');\n    } catch (error) {\n      console.error('Failed to reset scores:', error);\n      this.uiManager.showError('Failed to reset scores.');\n    }\n  }\n\n  /**\n   * Navigate to full scoreboard view from admin panel\n   */\n  viewFullScoreboard() {\n    this.switchView('scanner');\n    this.showScoreboard();\n  }\n\n  /**\n   * Navigate to full transaction history from admin panel\n   */\n  viewFullHistory() {\n    this.switchView('scanner');\n    this.showHistory();\n  }\n\n  /**\n   * Refresh admin session display (standalone mode)\n   * @private\n   */\n  _refreshAdminSessionDisplay() {\n    const container = document.getElementById('session-status-container');\n    if (container && this.uiManager) {\n      this.uiManager.renderSessionStatus(container);\n    }\n  }\n\n  // ========== GM Intervention (Both Modes) ==========\n\n  async adjustTeamScore() {\n    const teamId = this.currentInterventionTeamId;\n    if (!teamId) {\n      alert('No team selected. Please open team details first.');\n      return;\n    }\n\n    const deltaInput = document.getElementById('scoreAdjustmentInput');\n    const reasonInput = document.getElementById('scoreAdjustmentReason');\n\n    const delta = parseInt(deltaInput?.value || '0');\n    if (isNaN(delta) || delta === 0) {\n      alert('Please enter a valid positive or negative number.');\n      return;\n    }\n\n    const reason = reasonInput?.value.trim() || 'Manual GM adjustment';\n\n    const isStandalone = this.sessionModeManager?.isStandalone();\n\n    // Standalone mode: Use UnifiedDataManager (LocalStorage strategy)\n    if (isStandalone) {\n      try {\n        await this.dataManager.adjustTeamScore(teamId, delta, reason);\n        this.debug.log(`Score adjusted (standalone): Team ${teamId} ${delta > 0 ? '+' : ''}${delta} (${reason})`);\n\n        // Clear inputs\n        if (deltaInput) deltaInput.value = '';\n        if (reasonInput) reasonInput.value = '';\n\n        // Refresh team details immediately with updated local data\n        const transactions = this.dataManager.getTeamTransactions(teamId);\n        this.uiManager.renderTeamDetails(teamId, transactions);\n\n        this.uiManager.showToast(`Score adjusted: ${delta > 0 ? '+' : ''}${delta} points`, 'success');\n      } catch (error) {\n        console.error('Failed to adjust score (standalone):', error);\n        this.uiManager.showError(`Failed to adjust score: ${error.message}`);\n      }\n      return;\n    }\n\n    // Networked mode: Use AdminOps (backend authoritative)\n    if (!this.viewController?.adminInstances?.adminOps) {\n      alert('Admin functions not available. Ensure you are in networked mode.');\n      return;\n    }\n\n    try {\n      await this.viewController.adminInstances.adminOps.adjustScore(teamId, delta, reason);\n      this.debug.log(`Score adjusted (networked): Team ${teamId} ${delta > 0 ? '+' : ''}${delta} (${reason})`);\n\n      // Clear inputs\n      if (deltaInput) deltaInput.value = '';\n      if (reasonInput) reasonInput.value = '';\n\n      // Team details screen will auto-refresh via updateTeamScoreFromBackend()\n      // when score:updated event is received (centralized in dataManager.js)\n\n      this.uiManager.showToast(`Score adjusted: ${delta > 0 ? '+' : ''}${delta} points`, 'success');\n    } catch (error) {\n      console.error('Failed to adjust score (networked):', error);\n      this.uiManager.showError(`Failed to adjust score: ${error.message}`);\n    }\n  }\n\n  async deleteTeamTransaction(transactionId) {\n    if (!confirm('Delete this transaction? This cannot be undone.')) return;\n\n    const isStandalone = this.sessionModeManager?.isStandalone();\n\n    // Standalone mode: Use UnifiedDataManager (LocalStorage strategy)\n    if (isStandalone) {\n      try {\n        const result = await this.dataManager.removeTransaction(transactionId);\n        if (result.success) {\n          this.debug.log(`Transaction deleted (standalone): ${transactionId}`);\n\n          // Refresh team details immediately with updated local data\n          const teamId = this.currentInterventionTeamId;\n          if (teamId) {\n            const transactions = this.dataManager.getTeamTransactions(teamId);\n            this.uiManager.renderTeamDetails(teamId, transactions);\n          }\n\n          this.uiManager.showToast('Transaction deleted', 'success');\n        } else {\n          this.uiManager.showError('Transaction not found');\n        }\n      } catch (error) {\n        console.error('Failed to delete transaction (standalone):', error);\n        this.uiManager.showError(`Failed to delete transaction: ${error.message}`);\n      }\n      return;\n    }\n\n    // Networked mode: Use AdminOps (backend authoritative)\n    if (!this.viewController?.adminInstances?.adminOps) {\n      alert('Admin functions not available. Ensure you are in networked mode.');\n      return;\n    }\n\n    try {\n      await this.viewController.adminInstances.adminOps.deleteTransaction(transactionId);\n      this.debug.log(`Transaction deleted (networked): ${transactionId}`);\n\n      // ‚úÖ Remove local mutations - let broadcast flow handle it\n      // Backend sends transaction:deleted broadcast\n      // MonitoringDisplay calls DataManager.removeTransaction()\n      // DataManager emits event\n      // main.js listener re-renders team details if active\n\n      this.uiManager.showToast('Transaction deleted', 'success');\n    } catch (error) {\n      console.error('Failed to delete transaction (networked):', error);\n      this.uiManager.showError(`Failed to delete transaction: ${error.message}`);\n    }\n  }\n\n  // ========== Admin Display Control (Phase 4.2) ==========\n\n  /**\n   * Set display to Idle Loop mode\n   * Called by data-action=\"app.adminSetIdleLoop\" from admin panel button\n   */\n  async adminSetIdleLoop() {\n    if (!this.sessionModeManager?.isNetworked()) {\n      this.debug.log('Display control only available in networked mode');\n      return;\n    }\n\n    const displayController = this.viewController?.adminInstances?.displayController;\n    if (!displayController) {\n      this.debug.log('DisplayController not available - admin modules not initialized');\n      this.uiManager.showError('Admin functions not available. Please ensure connection is established.');\n      return;\n    }\n\n    try {\n      const result = await displayController.setIdleLoop();\n      this.debug.log(`Display mode set to Idle Loop: ${JSON.stringify(result)}`);\n    } catch (error) {\n      console.error('Failed to set display mode:', error);\n      this.uiManager.showError(`Failed to set display mode: ${error.message}`);\n    }\n  }\n\n  /**\n   * Set display to Scoreboard mode\n   * Called by data-action=\"app.adminSetScoreboard\" from admin panel button\n   */\n  async adminSetScoreboard() {\n    if (!this.sessionModeManager?.isNetworked()) {\n      this.debug.log('Display control only available in networked mode');\n      return;\n    }\n\n    const displayController = this.viewController?.adminInstances?.displayController;\n    if (!displayController) {\n      this.debug.log('DisplayController not available - admin modules not initialized');\n      this.uiManager.showError('Admin functions not available. Please ensure connection is established.');\n      return;\n    }\n\n    try {\n      const result = await displayController.setScoreboard();\n      this.debug.log(`Display mode set to Scoreboard: ${JSON.stringify(result)}`);\n    } catch (error) {\n      console.error('Failed to set display mode:', error);\n      this.uiManager.showError(`Failed to set display mode: ${error.message}`);\n    }\n  }\n\n  // ========== Testing Functions ==========\n\n  testTokenMatch() {\n    const testId = prompt('Enter a token ID to test:');\n    if (testId) {\n      const result = this.tokenManager.findToken(testId);\n      if (result) {\n        alert(`Match found!\\nID: ${result.matchedId}\\nType: ${result.token.SF_MemoryType}\\nGroup: ${result.token.SF_Group}`);\n      } else {\n        alert(`No match found for: ${testId}`);\n      }\n    }\n  }\n\n  testGroupParsing() {\n    const testCases = [\n      'Server Logs (x5)',\n      'Marcus\\' Memories (x1)',\n      'Government Files (x3)',\n      'No Multiplier Group',\n      'Bad Format (x)',\n      'Zero Multiplier (x0)',\n      'Large Multiplier (x999)'\n    ];\n\n    console.log('=== Testing Group Parsing ===');\n    testCases.forEach(testCase => {\n      const parsed = this.dataManager.parseGroupInfo(testCase);\n      const normalized = this.dataManager.normalizeGroupName(parsed.name);\n      console.log(`Input: \"${testCase}\"`);\n      console.log(`  Parsed: name=\"${parsed.name}\", multiplier=${parsed.multiplier}`);\n      console.log(`  Normalized: \"${normalized}\"`);\n    });\n\n    alert('Check console for test results');\n  }\n\n  testGroupInventory() {\n    const inventory = this.tokenManager.getGroupInventory();\n\n    console.log('=== Group Inventory Test ===');\n    console.log('Total groups:', Object.keys(inventory).length);\n\n    Object.entries(inventory).forEach(([normalizedName, groupData]) => {\n      console.log(`\\nGroup: \"${groupData.displayName}\"`);\n      console.log(`  Normalized: \"${normalizedName}\"`);\n      console.log(`  Multiplier: ${groupData.multiplier}x`);\n      console.log(`  Tokens: ${groupData.tokens.size}`);\n    });\n\n    alert('Check console for group inventory details');\n  }\n\n  testCompletionDetection() {\n    console.log('=== Testing Group Completion Detection ===\\n');\n\n    const realTeams = [...new Set(this.dataManager.getTransactions()\n      .filter(t => t.mode === 'blackmarket')\n      .map(t => t.teamId))];\n\n    if (realTeams.length > 0) {\n      console.log('=== Testing with REAL data ===');\n      realTeams.forEach(teamId => {\n        const completed = this.dataManager.getTeamCompletedGroups(teamId);\n        console.log(`Team ${teamId}: ${completed.length} completed groups`);\n        completed.forEach(group => {\n          console.log(`  ‚úÖ \"${group.name}\" - ${group.tokenCount} tokens, ${group.multiplier}x`);\n        });\n      });\n    } else {\n      console.log('No real data found. Add some transactions first.');\n    }\n\n    alert('Check console for completion detection results');\n  }\n\n  testBonusCalculations() {\n    console.log('=== Testing Bonus Score Calculations ===\\n');\n\n    const teamScores = this.dataManager.getTeamScores();\n\n    if (teamScores.length > 0) {\n      teamScores.forEach((team, index) => {\n        console.log(`${index + 1}. Team ${team.teamId}`);\n        console.log(`   Base: $${team.baseScore.toLocaleString()}`);\n        console.log(`   Bonus: $${team.bonusScore.toLocaleString()}`);\n        console.log(`   Total: $${team.score.toLocaleString()}`);\n        console.log(`   Completed Groups: ${team.completedGroups}`);\n      });\n    } else {\n      console.log('No teams found. Add some transactions first.');\n    }\n\n    alert('Check console for bonus calculation results');\n  }\n\n  testEnhancedUI() {\n    console.log('=== Testing Enhanced UI Data Structure ===\\n');\n\n    const teamId = prompt('Enter a team ID to test (or leave blank for first team):');\n    const transactions = this.dataManager.getTransactions();\n    const testTeamId = teamId || transactions[0]?.teamId;\n\n    if (!testTeamId) {\n      alert('No teams found. Add some transactions first.');\n      return;\n    }\n\n    const enhancedData = this.dataManager.getEnhancedTeamTransactions(testTeamId);\n\n    console.log(`Team ${testTeamId} Enhanced Data:`);\n    console.log(`  Completed Groups: ${enhancedData.completedGroups.length}`);\n    console.log(`  In-Progress Groups: ${enhancedData.incompleteGroups.length}`);\n    console.log(`  Ungrouped Tokens: ${enhancedData.ungroupedTokens.length}`);\n    console.log(`  Unknown Tokens: ${enhancedData.unknownTokens.length}`);\n\n    if (enhancedData.hasCompletedGroups) {\n      console.log('\\nCompleted Groups:');\n      enhancedData.completedGroups.forEach(group => {\n        console.log(`  \"${group.displayName}\": ${group.tokens.length} tokens, +$${group.bonusValue.toLocaleString()} bonus`);\n      });\n    }\n\n    if (enhancedData.hasIncompleteGroups) {\n      console.log('\\nIn-Progress Groups:');\n      enhancedData.incompleteGroups.forEach(group => {\n        console.log(`  \"${group.displayName}\": ${group.progress} (${group.percentage}%)`);\n      });\n    }\n\n    alert('Check console for enhanced UI data structure');\n  }\n}\n\n// Create singleton instance\nconst appInstance = new App();\n\n// Export both class and instance\nexport default appInstance;\nexport { App, appInstance };\n","/**\n * Connection Wizard Module\n * Handles networked mode connection setup and server discovery\n *\n * This module replaces the inline script functions from index.html\n * with proper ES6 module architecture and dependency injection.\n */\n\n/**\n * ConnectionWizard class - Manages connection wizard UI and workflow\n * Receives app instance via dependency injection (no window globals)\n */\nexport class ConnectionWizard {\n  constructor(app) {\n    this.app = app;\n\n    // Bind methods for event listeners\n    this.scanForServers = this.scanForServers.bind(this);\n    this.handleConnectionSubmit = this.handleConnectionSubmit.bind(this);\n    this.cancelNetworkedMode = this.cancelNetworkedMode.bind(this);\n    this.showConnectionWizard = this.showConnectionWizard.bind(this);\n    this.showAuthModal = this.showAuthModal.bind(this);\n  }\n\n  /**\n   * Initialize connection wizard by binding form submit event\n   * Call this after DOM is ready\n   */\n  init() {\n    const connectionForm = document.getElementById('connectionForm');\n    if (connectionForm) {\n      connectionForm.addEventListener('submit', this.handleConnectionSubmit);\n    }\n\n    // Setup debounced server URL handler for manual entry\n    this._setupServerUrlHandler();\n  }\n\n  /**\n   * Scan for game servers via HTTP brute-force\n   * Web browsers cannot do UDP, so we scan common IPs/ports using /health endpoint\n   * Based on player scanner discovery pattern from aln-memory-scanner/config.html\n   */\n  async scanForServers() {\n    const statusDiv = document.getElementById('discoveryStatus');\n    const serversDiv = document.getElementById('discoveredServers');\n    const btn = document.getElementById('scanServersBtn');\n\n    btn.disabled = true;\n    btn.textContent = 'üîç Scanning...';\n    statusDiv.textContent = 'Looking for orchestrators on the network...';\n    statusDiv.style.color = '#2196F3';\n    serversDiv.innerHTML = '';\n\n    try {\n      // Detect current subnet dynamically\n      const currentHost = window.location.hostname;\n      let subnet = '192.168.1'; // Default fallback\n\n      // Try to detect subnet from current host\n      if (currentHost && currentHost !== 'localhost' && currentHost !== '127.0.0.1') {\n        const parts = currentHost.split('.');\n        if (parts.length >= 3) {\n          subnet = parts.slice(0, 3).join('.');\n        }\n      }\n\n      const commonPorts = [3000, 8080];\n      // Use same protocol as current page to avoid mixed content blocking\n      const protocol = window.location.protocol.replace(':', ''); // 'https' or 'http'\n      const promises = [];\n\n      // Scan detected subnet (254 IPs √ó 2 ports = 508 requests max)\n      // Limited to 20 concurrent to avoid overwhelming network\n      for (let i = 1; i <= 254; i++) {\n        for (const port of commonPorts) {\n          const url = `${protocol}://${subnet}.${i}:${port}`;\n          promises.push(\n            fetch(`${url}/health`, {\n              method: 'GET',\n              mode: 'cors',\n              signal: AbortSignal.timeout(500)\n            })\n            .then(response => response.ok ? url : null)\n            .catch(() => null)\n          );\n        }\n\n        // Limit concurrent requests to avoid overwhelming the network\n        if (promises.length >= 20) {\n          await Promise.race(promises);\n        }\n      }\n\n      // Also try localhost\n      promises.push(\n        fetch(`${protocol}://localhost:3000/health`, {\n          signal: AbortSignal.timeout(1000)\n        })\n        .then(response => response.ok ? `${protocol}://localhost:3000` : null)\n        .catch(() => null)\n      );\n\n      // Try current origin if served from orchestrator\n      if (window.location.pathname.startsWith('/gm-scanner/')) {\n        promises.push(Promise.resolve(window.location.origin));\n      }\n\n      const results = await Promise.all(promises);\n      const foundServers = [...new Set(results.filter(url => url !== null))];\n\n      if (foundServers.length > 0) {\n        statusDiv.textContent = `‚úÖ Found ${foundServers.length} orchestrator(s)`;\n        statusDiv.style.color = '#4CAF50';\n\n        // Use existing displayDiscoveredServers pattern\n        this.displayDiscoveredServers(foundServers.map(url => ({ url })));\n      } else {\n        statusDiv.textContent = '‚ö†Ô∏è No orchestrators found. Please enter URL manually below.';\n        statusDiv.style.color = '#ff9800';\n      }\n    } catch (error) {\n      statusDiv.textContent = '‚ùå Discovery failed. Please enter URL manually below.';\n      statusDiv.style.color = '#f44336';\n      console.error('Server discovery error:', error);\n    } finally {\n      btn.disabled = false;\n      btn.textContent = 'üîç Scan for Game Servers';\n    }\n  }\n\n  /**\n   * Display discovered servers in the UI\n   * @private\n   */\n  displayDiscoveredServers(servers) {\n    const statusDiv = document.getElementById('discoveryStatus');\n    const serversDiv = document.getElementById('discoveredServers');\n\n    statusDiv.textContent = `‚úÖ Found ${servers.length} game server(s)`;\n    serversDiv.innerHTML = '';\n\n    servers.forEach(server => {\n      const serverEl = document.createElement('div');\n      serverEl.className = 'server-item';\n      serverEl.innerHTML = `\n        <span>üéÆ Game Server at ${server.ip || server.url}</span>\n        <button data-action=\"connectionWizard.selectServer\" data-arg=\"${server.url}\">Select</button>\n      `;\n      serversDiv.appendChild(serverEl);\n    });\n  }\n\n  /**\n   * Setup debounced handler for server URL manual entry\n   * Queries /api/state to auto-assign station name when URL is entered\n   * @private\n   */\n  _setupServerUrlHandler() {\n    const serverUrlInput = document.getElementById('serverUrl');\n    if (!serverUrlInput) return;\n\n    let debounceTimer;\n    const DEBOUNCE_MS = 500;\n\n    serverUrlInput.addEventListener('input', () => {\n      clearTimeout(debounceTimer);\n      debounceTimer = setTimeout(() => {\n        const url = serverUrlInput.value.trim();\n        if (url) {\n          // Normalize URL (add protocol if missing)\n          let normalizedUrl = url;\n          if (!normalizedUrl.match(/^https?:\\/\\//i)) {\n            normalizedUrl = `http://${normalizedUrl}`;\n          }\n          this.assignStationName(normalizedUrl);\n        }\n      }, DEBOUNCE_MS);\n    });\n  }\n\n  /**\n   * Query orchestrator for existing devices and assign next available station name\n   * @param {string} serverUrl - The orchestrator URL\n   * @private\n   */\n  async assignStationName(serverUrl) {\n    const stationNameDisplay = document.getElementById('stationNameDisplay');\n    if (!stationNameDisplay) return; // Graceful fallback if HTML not updated yet\n\n    try {\n      // Query /api/state (no auth required)\n      const response = await fetch(`${serverUrl}/api/state`, {\n        method: 'GET',\n        mode: 'cors',\n        signal: AbortSignal.timeout(3000)\n      });\n\n      if (!response.ok) {\n        throw new Error('Server unreachable');\n      }\n\n      const state = await response.json();\n      const devices = state.devices || [];\n\n      // Extract existing GM device IDs\n      const existingIds = devices\n        .filter(d => d.type === 'gm')\n        .map(d => d.deviceId);\n\n      // Find next available station ID\n      const nextStationId = this._findNextStationId(existingIds);\n\n      // Update display\n      stationNameDisplay.textContent = nextStationId;\n      stationNameDisplay.dataset.deviceId = nextStationId;\n\n      console.log(`[ConnectionWizard] Auto-assigned station name: ${nextStationId}`);\n    } catch (error) {\n      // Fallback to localStorage counter on error\n      console.warn(`[ConnectionWizard] Failed to query /api/state, using localStorage fallback:`, error.message);\n\n      const stationNum = localStorage.getItem('lastStationNum') || '1';\n      const fallbackId = `GM_Station_${stationNum}`;\n\n      if (stationNameDisplay) {\n        stationNameDisplay.textContent = fallbackId;\n        stationNameDisplay.dataset.deviceId = fallbackId;\n      }\n    }\n  }\n\n  /**\n   * Find next available station ID using gap-filling algorithm\n   * @param {string[]} existingIds - Array of existing device IDs (e.g., [\"GM_Station_1\", \"GM_Station_3\"])\n   * @returns {string} Next available station ID (e.g., \"GM_Station_2\")\n   * @private\n   */\n  _findNextStationId(existingIds) {\n    // Extract numbers from GM_Station_N pattern\n    const stationNumbers = existingIds\n      .filter(id => id && id.startsWith('GM_Station_'))\n      .map(id => {\n        const match = id.match(/GM_Station_(\\d+)$/);\n        return match ? parseInt(match[1], 10) : null;\n      })\n      .filter(num => num !== null)\n      .sort((a, b) => a - b);\n\n    // Find first missing number starting from 1\n    let nextNum = 1;\n    for (const num of stationNumbers) {\n      if (num === nextNum) {\n        nextNum++;\n      } else if (num > nextNum) {\n        break; // Found a gap\n      }\n    }\n\n    return `GM_Station_${nextNum}`;\n  }\n\n  /**\n   * Select discovered server and pre-fill connection form\n   */\n  selectServer(url) {\n    document.getElementById('serverUrl').value = url;\n    document.getElementById('discoveryStatus').textContent = '‚úÖ Server selected';\n\n    // Auto-assign station name by querying /api/state\n    this.assignStationName(url);\n  }\n\n  /**\n   * Unified connection form handler\n   */\n  async handleConnectionSubmit(event) {\n    event.preventDefault();\n\n    const serverUrl = document.getElementById('serverUrl').value;\n    const password = document.getElementById('gmPassword').value;\n    const statusDiv = document.getElementById('connectionStatusMsg');\n\n    // Read device ID from display element's dataset (not input field)\n    const stationNameDisplay = document.getElementById('stationNameDisplay');\n    const deviceId = stationNameDisplay ? stationNameDisplay.dataset.deviceId : null;\n\n    // Validate inputs\n    if (!serverUrl || !deviceId || !password) {\n      statusDiv.textContent = '‚ö†Ô∏è Please fill in all fields';\n      statusDiv.style.color = '#ff9800';\n      return;\n    }\n\n    statusDiv.textContent = '‚è≥ Connecting...';\n    statusDiv.style.color = '#2196F3';\n\n    try {\n      // Normalize URL - add http:// if no protocol specified\n      let normalizedUrl = serverUrl.trim();\n      if (!normalizedUrl.match(/^https?:\\/\\//i)) {\n        normalizedUrl = `http://${normalizedUrl}`;\n        statusDiv.textContent = `üîß Using ${normalizedUrl}`;\n      }\n\n      // 1. Test server reachability (use orchestrator health endpoint)\n      const healthCheck = await fetch(`${normalizedUrl}/health`, {\n        method: 'GET',\n        mode: 'cors',\n        signal: AbortSignal.timeout(3000)\n      });\n\n      if (!healthCheck.ok) {\n        throw new Error('Server not responding');\n      }\n\n      // 2. Authenticate\n      const authResponse = await fetch(`${normalizedUrl}/api/admin/auth`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ password })\n      });\n\n      if (!authResponse.ok) {\n        statusDiv.textContent = '‚ùå Invalid password';\n        statusDiv.style.color = '#f44336';\n        return;\n      }\n\n      const { token } = await authResponse.json();\n\n      // 3. Save configuration to localStorage\n      localStorage.setItem('aln_orchestrator_url', normalizedUrl);\n      localStorage.setItem('aln_auth_token', token);\n      localStorage.setItem('aln_station_name', deviceId);\n\n      // Set device ID in Settings (deviceId is already in correct format: GM_Station_N)\n      const settings = this.app.settings;\n      settings.deviceId = deviceId;\n      settings.stationName = deviceId;\n      settings.save();\n\n      // Update localStorage counter for next session\n      const match = deviceId.match(/GM_Station_(\\d+)$/);\n      if (match) {\n        const nextNum = parseInt(match[1], 10) + 1;\n        localStorage.setItem('lastStationNum', nextNum.toString());\n      }\n\n      // 4. Trigger networked mode initialization via App (event-driven pattern)\n      // Per Architecture Refactoring 2025-11: App creates NetworkedSession, not wizard\n      statusDiv.textContent = '‚úÖ Authenticated! Connecting...';\n      statusDiv.style.color = '#4CAF50';\n\n      // Delegate to App.selectGameMode() for proper event-driven initialization:\n      // - App will lock mode via SessionModeManager\n      // - App will create NetworkedSession with services\n      // - NetworkedSession will emit session:ready event\n      // - App's session:ready listener will initialize admin modules\n      // - App will close modal and show team entry screen\n      await this.app.selectGameMode('networked');\n\n      // Success handled by App's session:ready event listener\n      // (Modal close and UI transition happen in App._initializeNetworkedMode)\n\n    } catch (error) {\n      statusDiv.textContent = `‚ùå Connection failed: ${error.message}`;\n      statusDiv.style.color = '#f44336';\n    }\n  }\n\n  /**\n   * Cancel networked mode and return to game mode selection\n   */\n  cancelNetworkedMode() {\n    // Close the connection modal\n    document.getElementById('connectionModal').style.display = 'none';\n\n    // Clear the session mode manager's lock so user can choose again\n    const sessionModeManager = this.app.sessionModeManager;\n    if (sessionModeManager) {\n      sessionModeManager.clearMode();\n    }\n\n    // Return to game mode selection screen\n    this.app.uiManager.showScreen('gameModeScreen');\n  }\n\n  /**\n   * Show connection wizard modal\n   */\n  showConnectionWizard() {\n    const modal = document.getElementById('connectionModal');\n    modal.style.display = 'flex';\n\n    // Auto-scan on open for better UX (but don't block)\n    setTimeout(() => this.scanForServers(), 100);\n  }\n\n  /**\n   * Show non-blocking authentication modal\n   */\n  async showAuthModal() {\n    // Show the connection wizard modal instead of using prompt\n    this.showConnectionWizard();\n\n    // Pre-fill the server URL if we already have one\n    const connectionManager = this.app.networkedSession?.services?.connectionManager;\n    if (connectionManager && connectionManager.url) {\n      document.getElementById('serverUrl').value = connectionManager.url;\n\n      // Trigger station name assignment\n      this.assignStationName(connectionManager.url);\n    }\n\n    // Pre-fill station name display if we have one\n    if (connectionManager && connectionManager.stationName) {\n      const stationNameDisplay = document.getElementById('stationNameDisplay');\n      if (stationNameDisplay) {\n        stationNameDisplay.textContent = connectionManager.stationName;\n        stationNameDisplay.dataset.deviceId = connectionManager.stationName;\n      }\n    }\n  }\n}\n\n/**\n * Queue Status Indicator Manager\n * Manages the offline queue UI indicator with event-driven updates\n */\nexport class QueueStatusManager {\n  constructor(app) {\n    this.app = app;\n    this.updateQueueIndicator = this.updateQueueIndicator.bind(this);\n  }\n\n  /**\n   * Initialize queue status indicator with event listeners\n   */\n  init() {\n    this.updateQueueIndicator(); // Initial update\n\n    // Register event listener for queue changes (no polling)\n    const queueManager = this.app.networkedSession?.services?.queueManager;\n    if (queueManager) {\n      queueManager.addEventListener('queue:changed', (event) => {\n        console.log('Queue changed:', event.detail);\n        this.updateQueueIndicator();\n      });\n    }\n  }\n\n  /**\n   * Update the queue status indicator with current queue count\n   * P2.2.3: Event-driven updates (no polling)\n   */\n  updateQueueIndicator() {\n    const indicator = document.getElementById('queueStatusIndicator');\n    const countSpan = document.getElementById('queueCount');\n\n    if (!indicator || !countSpan) return;\n\n    // Get queue count from NetworkedQueueManager\n    const queueManager = this.app.networkedSession?.services?.queueManager;\n    const queueStatus = queueManager?.getStatus();\n    const queueCount = queueStatus ? queueStatus.queuedCount : 0;\n\n    // Update count display\n    countSpan.textContent = queueCount;\n\n    // Show/hide indicator based on queue count\n    if (queueCount > 0) {\n      indicator.classList.add('visible');\n    } else {\n      indicator.classList.remove('visible');\n    }\n  }\n}\n\n/**\n * Cleanup handler for page unload\n * Ensures graceful disconnect when page is closing\n */\nexport function setupCleanupHandlers(app) {\n  window.addEventListener('beforeunload', () => {\n    if (app.networkedSession?.services?.client) {\n      console.log('Page unloading - disconnecting socket');\n      app.networkedSession.services.client.disconnect();\n    }\n  });\n}\n","/**\n * DOM Event Bindings\n * Replaces HTML onclick handlers with proper event listeners\n *\n * This module implements event delegation to handle button clicks without\n * exposing global window.App, window.DataManager, etc.\n */\n\nexport function bindDOMEvents(app, dataManager, settings, debug, uiManager, connectionWizard, queueStatusManager) {\n  // Event delegation for data-action attributes\n  document.addEventListener('click', (event) => {\n    const actionElement = event.target.closest('[data-action]');\n    if (!actionElement) return;\n\n    // Prevent default action for links (e.g., <a href=\"#\" data-action=\"...\">)\n    if (actionElement.tagName === 'A') {\n      event.preventDefault();\n    }\n\n    const action = actionElement.dataset.action;\n    const arg = actionElement.dataset.arg;\n\n    // Split action into target and method\n    const [target, method] = action.split('.');\n\n    try {\n      switch(target) {\n        case 'app':\n          if (typeof app[method] === 'function') {\n            app[method](arg);\n          } else {\n            debug.log(`Action method not found: app.${method}`, true);\n          }\n          break;\n\n        case 'dataManager':\n          if (typeof dataManager[method] === 'function') {\n            dataManager[method](arg);\n          } else {\n            debug.log(`Action method not found: dataManager.${method}`, true);\n          }\n          break;\n\n        case 'settings':\n          if (typeof settings[method] === 'function') {\n            settings[method](arg);\n          } else {\n            debug.log(`Action method not found: settings.${method}`, true);\n          }\n          break;\n\n        case 'debug':\n          if (typeof debug[method] === 'function') {\n            debug[method](arg);\n          } else {\n            debug.log(`Action method not found: debug.${method}`, true);\n          }\n          break;\n\n        case 'uiManager':\n          if (typeof uiManager[method] === 'function') {\n            uiManager[method](arg);\n          } else {\n            debug.log(`Action method not found: uiManager.${method}`, true);\n          }\n          break;\n\n        case 'connectionWizard':\n          if (typeof connectionWizard[method] === 'function') {\n            connectionWizard[method](arg);\n          } else {\n            debug.log(`Action method not found: connectionWizard.${method}`, true);\n          }\n          break;\n\n        case 'queueStatusManager':\n          if (typeof queueStatusManager[method] === 'function') {\n            queueStatusManager[method](arg);\n          } else {\n            debug.log(`Action method not found: queueStatusManager.${method}`, true);\n          }\n          break;\n\n        default:\n          debug.log(`Unknown action target: ${target}`, true);\n      }\n    } catch (error) {\n      debug.log(`Action handler error: ${action} - ${error.message}`, true);\n      console.error(`Action handler error: ${action}`, error);\n    }\n  });\n}\n","/**\n * ScreenUpdateManager - Centralized Event-to-Screen Update Routing\n *\n * Phase 3: Event Architecture Standardization\n *\n * Problem Solved:\n * - Eliminates repetitive screen visibility checks scattered in main.js\n * - Removes window.__app hack by providing proper app context injection\n * - Creates consistent, declarative pattern for screen updates\n * - Makes it easy to add new screens or events\n *\n * Architecture:\n * - Global handlers: Run on EVERY event regardless of active screen\n * - Screen handlers: Run ONLY when that screen is active\n * - App context: Injected reference to App instance (replaces window.__app)\n *\n * Usage:\n *   const manager = new ScreenUpdateManager({ uiManager, dataManager, debug });\n *   manager.setAppContext(app);\n *\n *   manager.registerGlobalHandler('transaction:added', () => {\n *     uiManager.updateHistoryBadge();\n *   });\n *\n *   manager.registerScreen('history', {\n *     'transaction:added': () => uiManager.renderGameActivity(container)\n *   });\n *\n *   // Wire to DataManager\n *   DataManager.addEventListener('transaction:added', (e) =>\n *     manager.onDataUpdate('transaction:added', e.detail)\n *   );\n */\n\nexport class ScreenUpdateManager {\n  /**\n   * Create ScreenUpdateManager instance\n   * @param {Object} options - Dependency injection\n   * @param {Object} options.uiManager - UIManager instance for rendering\n   * @param {Object} options.dataManager - DataManager instance for data queries\n   * @param {Object} options.debug - Debug instance for logging\n   */\n  constructor({ uiManager, dataManager, debug } = {}) {\n    this.uiManager = uiManager;\n    this.dataManager = dataManager;\n    this.debug = debug;\n\n    // App context - set via setAppContext() after App is created\n    this.appContext = null;\n\n    // Global handlers: eventType -> [handler, handler, ...]\n    this.globalHandlers = {};\n\n    // Screen handlers: screenId -> { eventType: handler, ... }\n    this.screenHandlers = new Map();\n\n    // Container handlers: containerId -> { eventType: handler, ... }\n    // Always run if container element exists in DOM (regardless of active screen)\n    this.containerHandlers = {};\n\n    // Track connected data sources for cleanup (hot-reload, unmount)\n    // Map<dataSource, Map<eventType, boundHandler>>\n    this.connectedSources = new Map();\n  }\n\n  /**\n   * Set the App context for handlers that need app state\n   * Replaces the window.__app hack\n   * @param {Object} app - App instance\n   */\n  setAppContext(app) {\n    this.appContext = app;\n    this.debug?.log('[ScreenUpdateManager] App context set');\n  }\n\n  /**\n   * Register a global handler that runs on every event\n   * regardless of which screen is active\n   *\n   * NOTE: Global handlers run in registration order. If handlers have\n   * dependencies on each other, register them in the correct sequence.\n   *\n   * @param {string} eventType - Event name (e.g., 'transaction:added')\n   * @param {Function} handler - Handler function(eventData)\n   *   - eventData may be undefined; use defensive destructuring if needed\n   */\n  registerGlobalHandler(eventType, handler) {\n    if (!this.globalHandlers[eventType]) {\n      this.globalHandlers[eventType] = [];\n    }\n    this.globalHandlers[eventType].push(handler);\n    this.debug?.log(`[ScreenUpdateManager] Registered global handler for ${eventType}`);\n  }\n\n  /**\n   * Register screen-specific handlers\n   * @param {string} screenId - Screen identifier (without 'Screen' suffix, e.g., 'history')\n   * @param {Object} handlers - Map of eventType -> handler function\n   *   Handler signature: (eventData, appContext) => void\n   *   - eventData may be undefined; use defensive destructuring: `const { prop } = eventData || {}`\n   *   - appContext is the App instance (set via setAppContext)\n   * @throws {TypeError} If handlers is not a plain object\n   */\n  registerScreen(screenId, handlers) {\n    // Type safety: validate handlers is an object\n    if (!handlers || typeof handlers !== 'object' || Array.isArray(handlers)) {\n      throw new TypeError(\n        `[ScreenUpdateManager] registerScreen('${screenId}'): handlers must be an object, got ${typeof handlers}`\n      );\n    }\n    this.screenHandlers.set(screenId, handlers);\n    const eventTypes = Object.keys(handlers).join(', ');\n    this.debug?.log(`[ScreenUpdateManager] Registered screen '${screenId}' for events: ${eventTypes}`);\n  }\n\n  /**\n   * Register container-specific handlers\n   * Container handlers run for ANY container that exists in DOM, regardless of active screen.\n   * Use for UI elements that should update globally (scoreboards, transaction logs, etc.)\n   *\n   * @param {string} containerId - DOM element ID (e.g., 'scoreboardContainer', 'admin-score-board')\n   * @param {Object} handlers - Map of eventType -> handler function\n   *   Handler signature: (eventData, containerElement) => void\n   */\n  registerContainer(containerId, handlers) {\n    this.containerHandlers[containerId] = handlers;\n    const eventTypes = Object.keys(handlers).join(', ');\n    this.debug?.log(`[ScreenUpdateManager] Registered container '${containerId}' for events: ${eventTypes}`);\n  }\n\n  /**\n   * Get the currently active screen ID\n   * @returns {string|null} Screen ID without 'Screen' suffix, or null\n   */\n  getActiveScreenId() {\n    const activeScreen = document.querySelector('.screen.active');\n    if (!activeScreen) return null;\n\n    const screenId = activeScreen.id;\n\n    // Validate expected pattern: screen IDs should end with 'Screen' suffix\n    if (!screenId.endsWith('Screen')) {\n      console.warn(\n        `[ScreenUpdateManager] Unexpected screen ID pattern: '${screenId}' ` +\n        `(expected 'xxxScreen' format). Screen handlers may not work correctly.`\n      );\n      return screenId; // Return as-is for best-effort handling\n    }\n\n    // Convert 'historyScreen' -> 'history'\n    return screenId.replace('Screen', '');\n  }\n\n  /**\n   * Handle a data update event\n   * 1. Run all global handlers for this event type\n   * 2. Run container handlers for any container that exists in DOM\n   * 3. If active screen has a handler for this event, run it\n   *\n   * @param {string} eventType - Event name (e.g., 'transaction:added')\n   * @param {*} eventData - Event payload (from CustomEvent.detail)\n   */\n  onDataUpdate(eventType, eventData) {\n    this.debug?.log(`[ScreenUpdateManager] ${eventType} event received`);\n\n    // Step 1: Run global handlers (always, in registration order)\n    const globals = this.globalHandlers[eventType] || [];\n    for (const handler of globals) {\n      try {\n        handler(eventData);\n      } catch (error) {\n        console.error(`[ScreenUpdateManager] Global handler error for ${eventType}:`, error);\n      }\n    }\n\n    // Step 2: Run container handlers (for any container that exists in DOM)\n    for (const [containerId, handlers] of Object.entries(this.containerHandlers)) {\n      const container = document.getElementById(containerId);\n      if (container && handlers[eventType]) {\n        try {\n          handlers[eventType](eventData, container);\n        } catch (error) {\n          console.error(`[ScreenUpdateManager] Container handler error for ${containerId}/${eventType}:`, error);\n        }\n      }\n    }\n\n    // Step 3: Run screen-specific handler (if active)\n    const activeScreenId = this.getActiveScreenId();\n    if (!activeScreenId) {\n      this.debug?.log('[ScreenUpdateManager] No active screen, skipping screen handler');\n      return;\n    }\n\n    const screenHandlers = this.screenHandlers.get(activeScreenId);\n    const screenHandler = screenHandlers?.[eventType];\n\n    if (screenHandler) {\n      this.debug?.log(`[ScreenUpdateManager] Running ${eventType} handler for screen '${activeScreenId}'`);\n      try {\n        // Pass both eventData and appContext to handler\n        screenHandler(eventData, this.appContext);\n      } catch (error) {\n        console.error(`[ScreenUpdateManager] Screen handler error for ${activeScreenId}/${eventType}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Connect this manager to a DataManager (or StandaloneDataManager)\n   * Convenience method to wire all events at once\n   * @param {EventTarget} dataSource - DataManager or StandaloneDataManager\n   * @param {string[]} eventTypes - Array of event types to listen for\n   */\n  connectToDataSource(dataSource, eventTypes) {\n    // Initialize listener map for this source if not present\n    if (!this.connectedSources.has(dataSource)) {\n      this.connectedSources.set(dataSource, new Map());\n    }\n    const sourceListeners = this.connectedSources.get(dataSource);\n\n    for (const eventType of eventTypes) {\n      // Create and store bound handler for cleanup\n      const boundHandler = (event) => {\n        this.onDataUpdate(eventType, event.detail);\n      };\n      sourceListeners.set(eventType, boundHandler);\n      dataSource.addEventListener(eventType, boundHandler);\n    }\n    this.debug?.log(`[ScreenUpdateManager] Connected to data source for events: ${eventTypes.join(', ')}`);\n  }\n\n  /**\n   * Disconnect from a data source - removes all event listeners\n   * Use for cleanup in hot-reloading scenarios or component unmount\n   * @param {EventTarget} dataSource - DataManager or StandaloneDataManager to disconnect\n   */\n  disconnectFromDataSource(dataSource) {\n    const sourceListeners = this.connectedSources.get(dataSource);\n    if (!sourceListeners) {\n      this.debug?.log('[ScreenUpdateManager] No listeners found for data source, skipping disconnect');\n      return;\n    }\n\n    for (const [eventType, handler] of sourceListeners) {\n      dataSource.removeEventListener(eventType, handler);\n    }\n\n    this.connectedSources.delete(dataSource);\n    this.debug?.log(`[ScreenUpdateManager] Disconnected from data source (${sourceListeners.size} listeners removed)`);\n  }\n\n  /**\n   * Disconnect from all data sources - full cleanup\n   * Use when tearing down the entire ScreenUpdateManager\n   */\n  disconnectAll() {\n    for (const dataSource of this.connectedSources.keys()) {\n      this.disconnectFromDataSource(dataSource);\n    }\n    this.debug?.log('[ScreenUpdateManager] Disconnected from all data sources');\n  }\n}\n\nexport default ScreenUpdateManager;\n","/**\n * ALNScanner - Main Entry Point\n * ES6 Module Architecture\n *\n * This file orchestrates the application initialization in the new\n * ES6 module architecture with Vite build system.\n *\n * Architecture:\n * - Import all modules (singleton instances)\n * - Create App with dependency injection\n * - Initialize application\n * - Expose minimal window globals for HTML onclick handlers (temporary until Phase 9)\n *\n * Phase 3 Changes:\n * - Introduced ScreenUpdateManager for centralized event-to-screen routing\n * - Removed window.__app hack (app context passed via ScreenUpdateManager)\n * - Declarative screen update registration\n */\n\n// Import core dependencies\n// Note: Debug, Settings, TokenManager, NFCHandler, CONFIG are singletons (pre-created instances)\n// Note: UnifiedDataManager, UIManager are classes (instances created below with DI)\nimport Debug from './utils/debug.js';\nimport { UIManager as UIManagerClass } from './ui/uiManager.js';\nimport Settings from './ui/settings.js';\nimport TokenManager from './core/tokenManager.js';\nimport { UnifiedDataManager as UnifiedDataManagerClass } from './core/unifiedDataManager.js';\nimport { TeamRegistry as TeamRegistryClass } from './core/teamRegistry.js';\nimport NFCHandler from './utils/nfcHandler.js';\nimport CONFIG from './utils/config.js';\nimport InitializationSteps from './app/initializationSteps.js';\n\n// Import App class\nimport { App } from './app/app.js';\n\n// Import connection wizard and DOM event bindings\nimport { ConnectionWizard, QueueStatusManager, setupCleanupHandlers } from './ui/connectionWizard.js';\nimport { bindDOMEvents } from './utils/domEventBindings.js';\n\n// Import ScreenUpdateManager for centralized event routing (Phase 3)\nimport { ScreenUpdateManager } from './ui/ScreenUpdateManager.js';\n\n/**\n * Create service instances with proper dependency injection\n *\n * Architecture: Event-Driven Coordination (no direct cross-dependencies)\n * - UnifiedDataManager emits events (transaction:added, data:cleared, etc.)\n * - ScreenUpdateManager routes events to appropriate UI updates\n * - Event wiring happens in main.js (centralized)\n *\n * Phase 2: UnifiedDataManager replaces both DataManager and StandaloneDataManager\n * - Single manager with strategy pattern (LocalStorage/NetworkedStorage)\n * - Mode-specific initialization done by App during selectGameMode()\n */\n\n// Create UnifiedDataManager (strategy selected during App initialization)\nconst DataManager = new UnifiedDataManagerClass({\n  tokenManager: TokenManager,\n  sessionModeManager: null, // Set by App during mode selection\n  debug: Debug\n});\n\n// Create TeamRegistry for unified team management (networked + standalone)\nconst TeamRegistry = new TeamRegistryClass();\n\n// Create UIManager with unified DataManager\nconst UIManager = new UIManagerClass({\n  settings: Settings,\n  dataManager: DataManager\n  // sessionModeManager, app set later by App\n});\n\n/**\n * Create ScreenUpdateManager for centralized event-to-screen routing\n * Replaces scattered event handlers with declarative registration\n */\nconst screenUpdateManager = new ScreenUpdateManager({\n  uiManager: UIManager,\n  dataManager: DataManager,\n  debug: Debug\n});\n\n// ============================================================================\n// GLOBAL HANDLERS - Always run regardless of active screen\n// ============================================================================\n\n// Transaction added: Update badge and stats globally\nscreenUpdateManager.registerGlobalHandler('transaction:added', () => {\n  UIManager.updateHistoryBadge();\n  UIManager.updateSessionStats();\n});\n\n// Transaction deleted: Update badge and stats globally\nscreenUpdateManager.registerGlobalHandler('transaction:deleted', () => {\n  UIManager.updateHistoryBadge();\n  UIManager.updateSessionStats();\n});\n\n// Data cleared: Update badge\nscreenUpdateManager.registerGlobalHandler('data:cleared', () => {\n  UIManager.updateHistoryBadge();\n});\n\n// Game state updated: Update badge and stats\nscreenUpdateManager.registerGlobalHandler('game-state:updated', () => {\n  UIManager.updateHistoryBadge();\n  UIManager.updateSessionStats();\n});\n\n\n// ============================================================================\n// SCREEN-SPECIFIC HANDLERS - Only run when that screen is active\n// ============================================================================\n// NOTE: Screen handlers receive (eventData, app). Use defensive destructuring\n// when accessing eventData properties: `const { prop } = eventData || {}`\n\n// History screen: Re-render game activity when data changes\nscreenUpdateManager.registerScreen('history', {\n  'transaction:added': () => {\n    Debug.log('[main.js] History screen active - rendering game activity');\n    UIManager.updateHistoryStats();\n    const historyContainer = document.getElementById('historyContainer');\n    if (historyContainer) {\n      UIManager.renderGameActivity(historyContainer, { showSummary: true, showFilters: true });\n    }\n  },\n  'transaction:deleted': () => {\n    Debug.log('[main.js] History screen active - re-rendering after deletion');\n    UIManager.updateHistoryStats();\n    const historyContainer = document.getElementById('historyContainer');\n    if (historyContainer) {\n      UIManager.renderGameActivity(historyContainer, { showSummary: true, showFilters: true });\n    }\n  },\n  'player-scan:added': () => {\n    Debug.log('[main.js] History screen active - rendering game activity (player scan)');\n    const historyContainer = document.getElementById('historyContainer');\n    if (historyContainer) {\n      UIManager.renderGameActivity(historyContainer, { showSummary: true, showFilters: true });\n    }\n  }\n});\n\n// Team details screen: Re-render team data when transactions change\nscreenUpdateManager.registerScreen('teamDetails', {\n  'transaction:added': (_eventData, app) => {\n    // _eventData unused - we fetch fresh data for current team\n    const currentTeamId = app?.currentInterventionTeamId;\n    if (currentTeamId) {\n      Debug.log(`[main.js] Team details active - re-rendering for team ${currentTeamId}`);\n      const transactions = DataManager.getTeamTransactions(currentTeamId);\n      UIManager.renderTeamDetails(currentTeamId, transactions);\n    }\n  },\n  'transaction:deleted': (_eventData, app) => {\n    // _eventData unused - we fetch fresh data for current team\n    const currentTeamId = app?.currentInterventionTeamId;\n    if (currentTeamId) {\n      Debug.log(`[main.js] Team details active - re-rendering after deletion for team ${currentTeamId}`);\n      const transactions = DataManager.getTeamTransactions(currentTeamId);\n      UIManager.renderTeamDetails(currentTeamId, transactions);\n    }\n  },\n  'team-score:updated': (eventData, app) => {\n    // Defensive destructuring for eventData\n    const { teamId, transactions } = eventData || {};\n    const currentTeamId = app?.currentInterventionTeamId;\n    if (currentTeamId && currentTeamId === teamId) {\n      Debug.log(`[main.js] Team details active - score update for team ${teamId}`);\n      UIManager.renderTeamDetails(teamId, transactions);\n    }\n  }\n});\n\n// ============================================================================\n// CONTAINER HANDLERS (run for ANY container present in DOM, regardless of screen)\n// ============================================================================\n\n// Scoreboard containers - both use UIManager.renderScoreboard() for consistent rendering\n// scoreboardContainer: Full scoreboard screen (scanner-view)\n// admin-score-board: Admin panel inline scoreboard (admin-view)\nscreenUpdateManager.registerContainer('scoreboardContainer', {\n  'team-score:updated': (eventData, container) => {\n    Debug.log('[main.js] Updating scoreboardContainer');\n    UIManager.renderScoreboard(container);\n  },\n  'scores:cleared': (eventData, container) => {\n    Debug.log('[main.js] Clearing scoreboardContainer');\n    container.innerHTML = '';\n  },\n  'data:cleared': (eventData, container) => {\n    Debug.log('[main.js] Session reset - clearing scoreboardContainer');\n    container.innerHTML = '';\n  }\n});\n\nscreenUpdateManager.registerContainer('admin-score-board', {\n  'team-score:updated': (eventData, container) => {\n    Debug.log('[main.js] Updating admin-score-board');\n    UIManager.renderScoreboard(container);\n  },\n  'scores:cleared': (eventData, container) => {\n    Debug.log('[main.js] Clearing admin-score-board');\n    container.innerHTML = '';\n  },\n  'data:cleared': (eventData, container) => {\n    Debug.log('[main.js] Session reset - clearing admin-score-board');\n    container.innerHTML = '';\n  }\n});\n\n// Game Activity container (admin panel) - unified token lifecycle display\nscreenUpdateManager.registerContainer('admin-game-activity', {\n  'transaction:added': (eventData, container) => {\n    Debug.log('[main.js] Updating admin-game-activity (transaction added)');\n    UIManager.renderGameActivity(container, { showSummary: true, showFilters: true });\n  },\n  'transaction:deleted': (eventData, container) => {\n    Debug.log('[main.js] Updating admin-game-activity (transaction deleted)');\n    UIManager.renderGameActivity(container, { showSummary: true, showFilters: true });\n  },\n  'player-scan:added': (eventData, container) => {\n    Debug.log('[main.js] Updating admin-game-activity (player scan)');\n    UIManager.renderGameActivity(container, { showSummary: true, showFilters: true });\n  },\n  'data:cleared': (eventData, container) => {\n    Debug.log('[main.js] Session reset - clearing admin-game-activity');\n    container.innerHTML = '';\n  }\n});\n\n// Session Status container (admin panel) - Phase 3: Session lifecycle display\nscreenUpdateManager.registerContainer('session-status-container', {\n  'session:updated': (eventData, container) => {\n    Debug.log('[main.js] Updating session-status-container (session updated)');\n    UIManager.renderSessionStatus(container);\n  },\n  'data:cleared': (eventData, container) => {\n    Debug.log('[main.js] Session reset - re-rendering session-status-container');\n    UIManager.renderSessionStatus(container);\n  }\n});\n\n// ============================================================================\n// CONNECT TO DATA SOURCES\n// ============================================================================\n\n// Connect ScreenUpdateManager to UnifiedDataManager events\n// Phase 2: Single connection - UnifiedDataManager emits all events\nscreenUpdateManager.connectToDataSource(DataManager, [\n  'transaction:added',\n  'transaction:deleted',\n  'scores:cleared',\n  'data:cleared',\n  'game-state:updated',\n  'team-score:updated',\n  'player-scan:added',  // Game Activity: token lifecycle tracking\n  'session:updated'     // Phase 3: Session lifecycle events for admin panel\n]);\n\n/**\n * Create App instance with dependency injection\n * Now using created instances (not pre-created singletons)\n */\nconst app = new App({\n  debug: Debug,\n  uiManager: UIManager,\n  settings: Settings,\n  tokenManager: TokenManager,\n  dataManager: DataManager,\n  teamRegistry: TeamRegistry,\n  nfcHandler: NFCHandler,\n  config: CONFIG,\n  initializationSteps: InitializationSteps\n  // Note: sessionModeManager and networkedSession are set internally by App\n  // during mode selection (see App.selectGameMode)\n});\n\n// Set app context for screen handlers that need it (replaces window.__app hack)\nscreenUpdateManager.setAppContext(app);\n\n// TeamRegistry dependencies (sessionModeManager, orchestratorClient) are wired\n// by App.selectGameMode() after mode selection - not here in main.js\n// This follows the same pattern as UnifiedDataManager strategy initialization\n\n/**\n * Create connection wizard and queue status manager\n * These handle networked mode connection UI and offline queue indicator\n */\nconst connectionWizard = new ConnectionWizard(app);\nconst queueStatusManager = new QueueStatusManager(app);\n\n/**\n * Inject showConnectionWizard method into app\n * Required by App._initializeNetworkedMode() when no valid auth token exists\n */\napp.showConnectionWizard = connectionWizard.showConnectionWizard.bind(connectionWizard);\n\n/**\n * Bind DOM event handlers using event delegation\n * Replaces window globals and onclick handlers with data-action attributes\n */\nbindDOMEvents(app, DataManager, Settings, Debug, UIManager, connectionWizard, queueStatusManager);\n\n/**\n * Setup cleanup handlers for page unload\n * Ensures graceful disconnect when closing page\n */\nsetupCleanupHandlers(app);\n\n/**\n * Initialize application\n * Runs 11-phase initialization sequence from InitializationSteps\n */\nasync function initializeApp() {\n  Debug.log('=== ALNScanner ES6 Module Architecture ===');\n  Debug.log('Main entry point loaded');\n  Debug.log('Initializing application...');\n\n  try {\n    await app.init();\n    Debug.log('Application initialization complete');\n\n    // Initialize connection wizard (bind form events)\n    connectionWizard.init();\n    Debug.log('Connection wizard initialized');\n\n    // Initialize queue status manager (event-driven updates)\n    queueStatusManager.init();\n    Debug.log('Queue status manager initialized');\n  } catch (error) {\n    Debug.log(`Initialization error: ${error.message}`, true);\n    console.error('App initialization failed:', error);\n\n    // Show error to user\n    if (UIManager) {\n      UIManager.showError(`Failed to initialize: ${error.message}`);\n    }\n  }\n}\n\n/**\n * Start application when DOM is ready\n * Handles both cases: DOM already loaded, or still loading\n */\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', initializeApp);\n} else {\n  // DOM already loaded (module scripts are deferred by default)\n  initializeApp();\n}\n\n/**\n * Export app for console debugging\n * Developers can access via: import('./src/main.js').then(m => m.default)\n */\nexport default app;\n"],"names":["CONFIG","DebugLogger","message","isError","formatted","app","content","Debug","UIManager$1","settings","dataManager","sessionModeManager","container","duration","errorDiv","type","toast","screenName","current","screen","resultScreen","dismissHandler","event","mode","indicator","modeText","toggle","scoreboardButton","teamId","display","dataSource","stats","tokenCount","valueElement","labelElement","badge","count","totalScans","uniqueTeams","totalValue","avgValue","targetContainer","teamScores","scoreSource","team","index","rank","rankClass","medal","session","startTime","ms","seconds","minutes","hours","transactions","enhancedData","scoreData","isNetworked","titleEl","summaryEl","html","group","hasActiveSession","token","backendScore","displayBaseScore","displayBonusScore","displayTotalScore","baseScoreEl","bonusScoreEl","totalScoreEl","adjustmentsSection","adjustments","totalAdjustment","sum","adj","adjHtml","date","interventionControls","hasBonus","isUnknown","showDelete","tokenValue","isDuplicate","cardClass","calculationText","baseValue","multiplier","groupInfo","finalValue","deleteButton","displayValue","data","notification","tokenId","statusEl","rfidEl","typeEl","groupEl","valueEl","summaryContainer","tokenScore","text","div","timestamp","options","showSummary","showFilters","tokens","getLatestTimestamp","a","b","tokenData","events","status","discoveredByPlayers","potentialValue","memoryType","rating","scanEvents","e","hasMultipleScans","claimEvent","statusContent","idx","totalEvents","time","searchInput","filterSelect","cards","searchTerm","filterValue","card","matchesSearch","matchesFilter","Settings","deviceIdInput","deviceIdDisplay","modeToggle","settingsScreen","oldDeviceId","oldMode","TokenManagerClass","helpers","response","error","groups","issues","rfid","normalizedName","issue","groupString","match","name","completableGroups","g","singleTokenGroups","id","normalizedInput","dbKey","normalizedDbKey","TokenManager","IStorageStrategy","transaction","transactionId","delta","reason","teams","SCORING_CONFIG","sharedConfig","k","v","parseGroupInfo","groupName","trimmed","normalizeGroupName","calculateTokenValue","LocalStorage","tokenManager","debug","saved","parsed","sessionDate","today","tx","groupTxs","groupTokens","scannedIds","t","groupBaseScore","bonus","removedTx","adjustment","tokenMap","scan","activity","lookedUpToken","NetworkedStorage","socket","score","scans","sessionId","DataManagerUtils","scannedTokens","total","known","blackMarketScore","UnifiedDataManager","actualSocket","strategy","listeners","eventName","handler","calcTokenValue","parseGroup","sharedNormalizeGroupName","groupInventory","completedGroups","completedGroupNames","groupBonusData","completedGroupTokens","incompleteGroupTokens","ungroupedTokens","unknownTokens","normalizedGroupName","groupData","completedGroupsArray","incompleteGroupsArray","baseScore","bonusScore","groupBreakdown","tokenBaseValue","bonusAmount","currentTeamId","teamTransactions","totalScore","s","ts","payload","playerScan","playerScans","teamInfo","normalizedId","existingTeam","removed","sessionData","standaloneSessionData","teamData","selectElement","placeholder","selectedTeamId","placeholderOption","option","teamName","normalized","result","recent","limited","NFCHandlerClass","onRead","onError","serialNumber","now","debounceKey","record","url","testIds","randomId","NFCHandler","StateValidationService","orchestratorUrl","parts","expiry","str","controller","timeoutId","stateValidationService","initializeUIManager","uiManager","createSessionModeManager","SessionModeManagerClass","instance","initializeViewController","viewController","loadSettings","loadDataManager","detectNFCSupport","nfcHandler","supported","registerServiceWorker","navigatorObj","swPath","registration","loadTokenDatabase","errorMsg","applyURLModeOverride","locationSearch","modeParam","determineInitialScreen","savedMode","isTokenValid","validateAndDetermineInitialScreen","validationResult","decode","applyInitialScreenDecision","decision","showWizardFn","initNetworkedModeFn","showLoadingScreen","resolve","InitializationSteps","SessionModeManager","OrchestratorClient","config","auth","reject","onConnect","eventType","action","timeout","cleanup","envelope","ConnectionManager","delay","statusElement","textElement","statusText","NetworkedQueueManager","fallbackQueue","orphaned","batch","results","i","errorType","successCount","r","failCount","errorTypes","acc","handlerKey","key","sendCommand","connection","ackHandler","SessionManager","VideoController","videoFile","fromIndex","toIndex","DisplayController","SystemMonitor","baseUrl","AdminOperations","MonitoringDisplay","client","teamRegistry","gameActivity","scoreBoard","d","transactionLog","txElement","nowShowingValue","nowShowingIcon","returnsToContainer","btnIdleLoop","btnScoreboard","txTime","duplicateClass","duplicateBadge","txHtml","items","devices","countElement","listElement","device","endTime","overtimeHtml","expectedMin","actualMin","overtimeMin","videoStatus","currentVideoElem","queueLengthElem","returnsToMode","pendingQueueCount","progress","progressData","progressContainer","progressFill","progressTime","position","queueData","list","item","datalist","videoOptions","orchestratorElem","syncData","vlcElement","vlcStatus","AdminController","module","NetworkedSession","newSessionId","currentSessionId","App","dependencies","UIManager","screenDecision","viewSelector","viewName","view","selectedView","tab","activeTab","adminController","scanScreen","teamInput","teamList","listLabel","currentTeamEl","sessionContainer","deviceId","connectionModal","exp","err","cleanId","txId","historyContainer","targetScreen","details","days","input","filename","gameActivityContainer","deltaInput","reasonInput","displayController","testId","testCases","testCase","inventory","realTeams","completed","testTeamId","ConnectionWizard","connectionForm","statusDiv","serversDiv","btn","currentHost","subnet","commonPorts","protocol","promises","port","foundServers","servers","server","serverEl","serverUrlInput","debounceTimer","DEBOUNCE_MS","normalizedUrl","serverUrl","stationNameDisplay","existingIds","nextStationId","fallbackId","stationNumbers","num","nextNum","password","authResponse","modal","connectionManager","QueueStatusManager","queueManager","countSpan","queueStatus","queueCount","setupCleanupHandlers","bindDOMEvents","connectionWizard","queueStatusManager","actionElement","arg","target","method","ScreenUpdateManager","screenId","handlers","eventTypes","containerId","activeScreen","eventData","globals","activeScreenId","screenHandler","sourceListeners","boundHandler","DataManager","UnifiedDataManagerClass","TeamRegistry","TeamRegistryClass","UIManagerClass","screenUpdateManager","_eventData","initializeApp"],"mappings":"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"}