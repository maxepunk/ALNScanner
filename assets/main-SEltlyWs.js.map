{"version":3,"file":"main-SEltlyWs.js","sources":["../../src/utils/config.js","../../src/utils/debug.js","../../src/ui/uiManager.js","../../src/ui/settings.js","../../src/core/tokenManager.js","../../src/core/storage/IStorageStrategy.js","../../src/core/scoring.js","../../src/core/gameActivityBuilder.js","../../src/core/storage/LocalStorage.js","../../src/core/storage/NetworkedStorage.js","../../src/core/unifiedDataManager.js","../../src/core/teamRegistry.js","../../src/utils/nfcHandler.js","../../src/utils/jwtUtils.js","../../src/services/StateValidationService.js","../../src/app/initializationSteps.js","../../src/app/sessionModeManager.js","../../src/network/orchestratorClient.js","../../src/network/connectionManager.js","../../src/network/networkedQueueManager.js","../../src/admin/utils/CommandSender.js","../../src/admin/SessionManager.js","../../src/admin/VideoController.js","../../src/admin/DisplayController.js","../../src/admin/SystemMonitor.js","../../src/admin/AdminOperations.js","../../src/ui/renderers/CueRenderer.js","../../src/ui/renderers/EnvironmentRenderer.js","../../src/ui/renderers/SessionRenderer.js","../../src/ui/renderers/VideoRenderer.js","../../src/admin/MonitoringDisplay.js","../../src/admin/BluetoothController.js","../../src/admin/AudioController.js","../../src/admin/LightingController.js","../../src/admin/CueController.js","../../src/admin/SoundController.js","../../src/admin/SpotifyController.js","../../src/app/adminController.js","../../src/network/networkedSession.js","../../src/app/app.js","../../src/ui/connectionWizard.js","../../src/utils/domEventBindings.js","../../src/ui/ScreenUpdateManager.js","../../src/main.js"],"sourcesContent":["/**\n * Application Configuration Constants\n * ES6 Module Export\n */\n\nexport const CONFIG = {\n    MAX_TEAM_ID_LENGTH: 6,\n    MAX_DEBUG_MESSAGES: 50,\n    ANIMATION_DURATION: 200,\n    MODE_TOGGLE_SCALE: 1.1,\n    SCAN_SIMULATION_DELAY: 1000,\n    NFC_PULSE_INTERVAL: 2000\n};\n\n// Export as default as well for convenience\nexport default CONFIG;\n","/**\n * Debug Logging System\n * ES6 Module Export\n */\n\nimport CONFIG from './config.js';\n\nclass DebugLogger {\n  constructor() {\n    this.messages = [];\n  }\n\n  /**\n   * Log a debug message\n   * @param {string} message - Message to log\n   * @param {boolean} isError - Whether this is an error message\n   */\n  log(message, isError = false) {\n    const timestamp = new Date().toLocaleTimeString();\n    const prefix = isError ? '‚ùå' : '‚úì';\n    const formatted = `[${timestamp}] ${prefix} ${message}`;\n\n    this.messages.push(formatted);\n    if (this.messages.length > CONFIG.MAX_DEBUG_MESSAGES) {\n      this.messages.shift();\n    }\n\n    this.updatePanel();\n\n    if (isError) {\n      console.error(message);\n    } else {\n      console.log(message);\n    }\n  }\n\n  /**\n   * Update the debug panel display\n   * @param {Object} app - App instance (for viewController access)\n   */\n  updatePanel(app = null) {\n    const content = document.getElementById('debugContent');\n    if (content) {\n      content.textContent = this.messages.join('\\n');\n      // Auto-scroll to bottom if debug view is active\n      // TODO: Remove app parameter once App is converted to ES6\n      if (app?.viewController?.currentView === 'debug') {\n        content.scrollTop = content.scrollHeight;\n      }\n    }\n  }\n\n  /**\n   * Toggle debug panel visibility\n   * @param {Object} app - App instance (for viewController access)\n   */\n  toggle(app = null) {\n    // TODO: Remove app parameter once App is converted to ES6\n    if (app?.viewController) {\n      if (app.viewController.currentView === 'debug') {\n        app.viewController.switchView('scanner');\n      } else {\n        app.viewController.switchView('debug');\n      }\n    } else {\n      console.warn('Debug view not available in this mode');\n    }\n  }\n\n  /**\n   * Clear all debug messages\n   */\n  clear() {\n    this.messages = [];\n    this.updatePanel();\n  }\n}\n\n// Create singleton instance\nconst Debug = new DebugLogger();\n\nexport default Debug;\nexport { DebugLogger };\n","/**\n * UI Manager Module\n * Manages all UI rendering and screen navigation\n * ES6 Module - Pure Rendering Layer (does NOT extend EventTarget)\n *\n * Responsibilities:\n * - Screen navigation\n * - DOM updates and rendering\n * - Error/toast notifications\n * - Mode display management\n * - Scoreboard and team details rendering\n */\n\nclass UIManager {\n  /**\n   * Create UIManager instance\n   * @param {Object} options - Dependency injection options\n   * @param {Object} options.settings - Settings instance (for mode checking)\n   * @param {Object} options.dataManager - UnifiedDataManager instance\n   * @param {Object} options.sessionModeManager - SessionModeManager instance (for mode check)\n   * @param {Object} options.app - App instance (for callbacks like showTeamDetails, deleteTeamTransaction)\n   */\n  constructor({ settings, dataManager, sessionModeManager, app } = {}) {\n    this.settings = settings;\n    this.dataManager = dataManager;\n    this.sessionModeManager = sessionModeManager;\n    this.app = app;\n\n    this.screens = {};\n    this.previousScreen = null;\n    this.errorContainer = null;\n  }\n\n  /**\n   * Initialize UI elements\n   * Caches screen references and sets up error container\n   */\n  init() {\n    this.screens = {\n      loading: document.getElementById('loadingScreen'),\n      gameModeScreen: document.getElementById('gameModeScreen'),\n      teamEntry: document.getElementById('teamEntryScreen'),\n      scan: document.getElementById('scanScreen'),\n      result: document.getElementById('resultScreen'),\n      history: document.getElementById('historyScreen'),\n      scoreboard: document.getElementById('scoreboardScreen'),\n      teamDetails: document.getElementById('teamDetailsScreen')\n    };\n\n    // Initialize error display container\n    this.initErrorDisplay();\n  }\n\n  /**\n   * Initialize error display container\n   */\n  initErrorDisplay() {\n    // Create error container if doesn't exist\n    if (!document.getElementById('error-container')) {\n      const container = document.createElement('div');\n      container.id = 'error-container';\n      container.className = 'error-container';\n      document.body.appendChild(container);\n    }\n    this.errorContainer = document.getElementById('error-container');\n  }\n\n  /**\n   * Show error message to user\n   * @param {string} message - Error message to display\n   * @param {number} duration - Duration in milliseconds (default 5000)\n   */\n  showError(message, duration = 5000) {\n    if (!this.errorContainer) {\n      this.initErrorDisplay();\n    }\n\n    const errorDiv = document.createElement('div');\n    errorDiv.className = 'error-message';\n    errorDiv.textContent = message;\n\n    this.errorContainer.appendChild(errorDiv);\n\n    // Auto-dismiss after duration\n    setTimeout(() => {\n      errorDiv.style.animation = 'slideOut 0.3s ease-out forwards';\n      setTimeout(() => errorDiv.remove(), 300);\n    }, duration);\n  }\n\n  /**\n   * Show toast notification to user\n   * @param {string} message - Notification message\n   * @param {string} type - Toast type: 'info', 'success', 'warning', 'error'\n   * @param {number} duration - Duration in milliseconds (default 3000)\n   */\n  showToast(message, type = 'info', duration = 3000) {\n    if (!this.errorContainer) {\n      this.initErrorDisplay();\n    }\n\n    const toast = document.createElement('div');\n    toast.className = `toast toast-${type}`;\n    toast.textContent = message;\n\n    this.errorContainer.appendChild(toast);\n\n    // Auto-dismiss after duration\n    setTimeout(() => {\n      toast.style.animation = 'slideOut 0.3s ease-out forwards';\n      setTimeout(() => toast.remove(), 300);\n    }, duration);\n  }\n\n  /**\n   * Show specified screen\n   * @param {string} screenName - Name of screen to show\n   */\n  showScreen(screenName) {\n    // Track previous screen for back navigation\n    const current = document.querySelector('.screen.active');\n    if (current && current.id !== 'historyScreen' &&\n      current.id !== 'scoreboardScreen' &&\n      current.id !== 'teamDetailsScreen' &&\n      current.id !== 'gameModeScreen' &&\n      current.id !== 'loadingScreen' &&\n      screenName !== 'history' &&\n      screenName !== 'scoreboard' &&\n      screenName !== 'teamDetails') {\n      this.previousScreen = current.id.replace('Screen', '');\n    }\n\n    // Hide all screens\n    Object.values(this.screens).forEach(screen => {\n      if (screen) {\n        screen.classList.remove('active');\n      }\n    });\n\n    // Show requested screen\n    if (this.screens[screenName]) {\n      this.screens[screenName].classList.add('active');\n    }\n\n    // Screen-specific initialization callbacks\n    if (screenName === 'teamEntry' && this.app?.initTeamEntryUI) {\n      this.app.initTeamEntryUI();\n    }\n    if (screenName === 'scoreboard') {\n      this.renderScoreboard();\n    }\n    if (screenName === 'result') {\n      this._enableResultScreenQuickDismiss();\n    }\n  }\n\n  /**\n   * Enable quick-dismiss behavior on result screen\n   * Tap anywhere (except buttons) returns to scan screen\n   * @private\n   */\n  _enableResultScreenQuickDismiss() {\n    const resultScreen = this.screens.result;\n    if (!resultScreen) return;\n\n    const dismissHandler = (event) => {\n      // Don't dismiss if clicking any button (let data-action handlers handle navigation)\n      if (event.target.closest('button')) {\n        return;\n      }\n      resultScreen.removeEventListener('click', dismissHandler);\n      this.showScreen('scan');\n    };\n\n    // Remove any existing handler first (prevents stacking)\n    if (resultScreen._quickDismissHandler) {\n      resultScreen.removeEventListener('click', resultScreen._quickDismissHandler);\n    }\n    resultScreen._quickDismissHandler = dismissHandler;\n    resultScreen.addEventListener('click', dismissHandler);\n  }\n\n  /**\n   * Update mode display elements\n   * @param {string} mode - 'detective' or 'blackmarket'\n   */\n  updateModeDisplay(mode) {\n    const indicator = document.getElementById('modeIndicator');\n    const modeText = document.getElementById('modeText');\n    const toggle = document.getElementById('modeToggle');\n\n    if (!indicator) return;\n\n    if (mode === 'blackmarket') {\n      indicator.className = 'mode-indicator mode-blackmarket';\n      indicator.textContent = 'Black Market Mode';\n      if (modeText) modeText.textContent = 'Black Market Mode';\n      if (toggle) toggle.checked = true;\n    } else {\n      indicator.className = 'mode-indicator mode-detective';\n      indicator.textContent = 'Detective Mode';\n      if (modeText) modeText.textContent = 'Detective Mode';\n      if (toggle) toggle.checked = false;\n    }\n\n    this.updateNavigationButtons();\n  }\n\n  /**\n   * Update navigation button visibility\n   */\n  updateNavigationButtons() {\n    const scoreboardButton = document.getElementById('scoreboardButton');\n    if (scoreboardButton && this.settings) {\n      scoreboardButton.style.display =\n        this.settings.mode === 'blackmarket' ? 'block' : 'none';\n    }\n  }\n\n  /**\n   * Update team display\n   * @param {string} teamId - Team ID to display\n   */\n  updateTeamDisplay(teamId) {\n    const display = document.getElementById('teamDisplay');\n    if (display) {\n      display.textContent = teamId || '_';\n    }\n  }\n\n  /**\n   * Update session statistics display\n   */\n  updateSessionStats() {\n    const dataSource = this.dataManager;\n    if (!dataSource || !this.settings) return;\n\n    const stats = dataSource.getSessionStats();\n    const tokenCount = document.getElementById('teamTokenCount');\n    const valueElement = document.getElementById('teamTotalValue');\n    const labelElement = document.getElementById('teamValueLabel');\n\n    if (tokenCount) {\n      tokenCount.textContent = stats.count;\n    }\n\n    if (valueElement) {\n      if (this.settings.mode === 'blackmarket') {\n        valueElement.textContent = `$${stats.totalScore.toLocaleString()}`;\n        if (labelElement) labelElement.textContent = 'Score';\n      } else {\n        valueElement.textContent = stats.totalValue;\n        if (labelElement) labelElement.textContent = 'Total Value';\n      }\n    }\n  }\n\n  /**\n   * Update history badge count\n   */\n  updateHistoryBadge() {\n    const dataSource = this.dataManager;\n    if (!dataSource) return;\n\n    const badge = document.getElementById('historyBadge');\n    if (!badge) return;\n\n    // Check if strategy is initialized before accessing transactions\n    if (!dataSource.getActiveStrategyType()) {\n      badge.style.display = 'none';\n      return;\n    }\n\n    const count = dataSource.getTransactions().length;\n    if (count > 0) {\n      badge.textContent = count;\n      badge.style.display = 'inline';\n    } else {\n      badge.style.display = 'none';\n    }\n  }\n\n  /**\n   * Update history statistics\n   */\n  updateHistoryStats() {\n    const dataSource = this.dataManager;\n    if (!dataSource) return;\n\n    const stats = dataSource.getGlobalStats();\n    const totalScans = document.getElementById('totalScans');\n    const uniqueTeams = document.getElementById('uniqueTeams');\n    const totalValue = document.getElementById('totalValue');\n    const avgValue = document.getElementById('avgValue');\n\n    if (totalScans) totalScans.textContent = stats.total;\n    if (uniqueTeams) uniqueTeams.textContent = stats.teams;\n    if (totalValue) totalValue.textContent = stats.totalValue;\n    if (avgValue) avgValue.textContent = stats.avgValue;\n  }\n\n  /**\n   * Render scoreboard\n   * @param {HTMLElement|null} container - Optional container element. Defaults to #scoreboardContainer\n   */\n  renderScoreboard(container = null) {\n    const dataSource = this.dataManager;\n    if (!dataSource || !this.app) return;\n\n    // Use provided container or default to scoreboardContainer\n    const targetContainer = container || document.getElementById('scoreboardContainer');\n    if (!targetContainer) return;\n\n    const teamScores = dataSource.getTeamScores();\n\n    if (teamScores.length === 0) {\n      targetContainer.innerHTML = `\n        <div class=\"empty-state\">\n          <h3>No Teams Yet</h3>\n          <p>Teams will appear here after scanning tokens</p>\n        </div>\n      `;\n      return;\n    }\n\n    // Add score source indicator\n    const scoreSource = teamScores[0]?.isFromBackend ?\n      '<div class=\"score-source\" style=\"text-align: center; margin: 10px 0; padding: 10px; background: rgba(103,126,234,0.1); border-radius: 8px; font-size: 14px;\">üîó Live from Orchestrator</div>' :\n      '<div class=\"score-source\" style=\"text-align: center; margin: 10px 0; padding: 10px; background: rgba(255,152,0,0.1); border-radius: 8px; font-size: 14px;\">üì± Local Calculation</div>';\n\n    targetContainer.innerHTML = scoreSource + teamScores.map((team, index) => {\n      const rank = index + 1;\n      const rankClass = rank <= 3 ? `rank-${rank}` : '';\n      const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `#${rank}`;\n\n      return `\n        <div class=\"scoreboard-entry ${rankClass}\" data-action=\"app.showTeamDetails\" data-arg=\"${team.teamId}\" style=\"cursor: pointer;\">\n          <div class=\"scoreboard-rank\">${medal}</div>\n          <div class=\"scoreboard-team\">\n            Team ${team.teamId}\n            <span class=\"scoreboard-tokens\">(${team.tokenCount} tokens)</span>\n          </div>\n          <div class=\"scoreboard-score\">$${team.score.toLocaleString()}</div>\n        </div>\n      `;\n    }).join('');\n  }\n\n  /**\n   * Render session status display (mode-agnostic)\n   * Used by standalone mode admin panel\n   * @param {HTMLElement} container - Container element\n   */\n  renderSessionStatus(container) {\n    if (!container) return;\n\n    const session = this.dataManager?.getCurrentSession?.();\n\n    // No session\n    if (!session) {\n      container.innerHTML = `\n        <div class=\"session-status session-status--empty\">\n          <p class=\"session-status__message\">No Active Session</p>\n          <p class=\"session-status__hint\">Create a new session to begin tracking gameplay</p>\n          <button class=\"btn btn-primary\" data-action=\"app.adminCreateSession\">\n            Create New Session\n          </button>\n        </div>\n      `;\n      return;\n    }\n\n    // Calculate duration\n    const startTime = session.startTime ? new Date(session.startTime) : null;\n    const duration = startTime ? this._formatDuration(Date.now() - startTime.getTime()) : '‚Äî';\n\n    // Paused session\n    if (session.status === 'paused') {\n      container.innerHTML = `\n        <div class=\"session-status session-status--paused\">\n          <h4 class=\"session-status__header\">\n            <span class=\"session-status__icon\">‚è∏Ô∏è</span>\n            <span>${this.escapeHtml(session.name || 'Session')}</span>\n            <span class=\"session-status__badge session-status__badge--paused\">Paused</span>\n          </h4>\n          <div class=\"session-status__details\">\n            <span>Started: ${startTime ? startTime.toLocaleTimeString() : '‚Äî'}</span>\n            <span>Duration: ${duration}</span>\n          </div>\n          <div class=\"session-status__actions\">\n            <button class=\"btn btn-primary\" data-action=\"app.adminResumeSession\">\n              Resume Session\n            </button>\n            <button class=\"btn btn-danger\" data-action=\"app.adminEndSession\">\n              End Session\n            </button>\n          </div>\n        </div>\n      `;\n      return;\n    }\n\n    // Active session (default)\n    container.innerHTML = `\n      <div class=\"session-status session-status--active\">\n        <h4 class=\"session-status__header\">\n          <span class=\"session-status__icon\">üéÆ</span>\n          <span>${this.escapeHtml(session.name || 'Session')}</span>\n          <span class=\"session-status__badge session-status__badge--active\">Active</span>\n        </h4>\n        <div class=\"session-status__details\">\n          <span>Started: ${startTime.toLocaleTimeString()}</span>\n          <span>Duration: ${duration}</span>\n        </div>\n        <div class=\"session-status__actions\">\n          <button class=\"btn btn-secondary\" data-action=\"app.adminPauseSession\">\n            Pause Session\n          </button>\n          <button class=\"btn btn-danger\" data-action=\"app.adminEndSession\">\n            End Session\n          </button>\n        </div>\n      </div>\n    `;\n  }\n\n  /**\n   * Format duration in milliseconds to human readable\n   * @private\n   */\n  _formatDuration(ms) {\n    if (!ms || ms < 0) return '0m';\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n\n    if (hours > 0) {\n      return `${hours}h ${minutes % 60}m`;\n    } else if (minutes > 0) {\n      return `${minutes}m`;\n    } else {\n      return `${seconds}s`;\n    }\n  }\n\n  /**\n   * Render team details with enhanced grouping\n   * @param {string} teamId - Team ID\n   * @param {Array} transactions - Team transactions\n   */\n  renderTeamDetails(teamId, transactions) {\n    const dataSource = this.dataManager;\n    if (!dataSource) return;\n\n    // Get enhanced data structure\n    const enhancedData = dataSource.getEnhancedTeamTransactions(teamId);\n    const scoreData = dataSource.calculateTeamScoreWithBonuses(teamId);\n\n    // Check if networked mode for intervention controls\n    const isNetworked = this.sessionModeManager?.isNetworked();\n\n    // Update header\n    const titleEl = document.getElementById('teamDetailsTitle');\n    const summaryEl = document.getElementById('teamDetailsSummary');\n\n    if (titleEl) {\n      titleEl.textContent = `Team ${teamId}`;\n    }\n    if (summaryEl) {\n      summaryEl.textContent = `${transactions.length} token${transactions.length !== 1 ? 's' : ''} collected`;\n    }\n\n    // Build HTML with grouped sections\n    let html = '';\n\n    // Completed Groups Section\n    if (enhancedData.hasCompletedGroups) {\n      html += '<div class=\"section-divider\">‚úÖ Completed Groups</div>';\n\n      enhancedData.completedGroups.forEach(group => {\n        html += `\n          <div class=\"group-section\">\n            <div class=\"group-header completed\">\n              <div class=\"group-title\">\n                <span class=\"completion-badge\">üèÜ</span>\n                <span class=\"group-name\">${group.displayName}</span>\n                <span class=\"completion-text\">COMPLETE</span>\n              </div>\n              <div class=\"bonus-amount\">\n                +$${group.bonusValue.toLocaleString()} bonus (${group.multiplier}x)\n              </div>\n            </div>`;\n\n        // Add tokens in this group\n        const hasActiveSession = this.sessionModeManager?.isNetworked() || this.sessionModeManager?.isStandalone();\n        group.tokens.forEach(token => {\n          html += this.renderTokenCard(token, true, false, hasActiveSession);\n        });\n\n        html += '</div>';\n      });\n    }\n\n    // In-progress Groups Section\n    if (enhancedData.hasIncompleteGroups) {\n      html += '<div class=\"section-divider\">üî∂ In Progress Groups</div>';\n\n      enhancedData.incompleteGroups.forEach(group => {\n        html += `\n          <div class=\"group-section\">\n            <div class=\"group-header in-progress\">\n              <div class=\"group-title\">\n                <span class=\"progress-badge\">‚è≥</span>\n                <span class=\"group-name\">${group.displayName}</span>\n                <span class=\"progress-text\">${group.progress}</span>\n              </div>\n              <div class=\"progress-bar\">\n                <div class=\"progress-fill\" style=\"width: ${group.percentage}%\"></div>\n              </div>\n            </div>`;\n\n        // Add tokens in this group\n        const hasActiveSession = this.sessionModeManager?.isNetworked() || this.sessionModeManager?.isStandalone();\n        group.tokens.forEach(token => {\n          html += this.renderTokenCard(token, false, false, hasActiveSession);\n        });\n\n        html += '</div>';\n      });\n    }\n\n    // Ungrouped Tokens Section\n    if (enhancedData.hasUngroupedTokens) {\n      html += '<div class=\"section-divider\">üì¶ Individual Tokens</div>';\n\n      const hasActiveSession = this.sessionModeManager?.isNetworked() || this.sessionModeManager?.isStandalone();\n      enhancedData.ungroupedTokens.forEach(token => {\n        html += this.renderTokenCard(token, false, false, hasActiveSession);\n      });\n    }\n\n    // Unknown Tokens Section\n    if (enhancedData.hasUnknownTokens) {\n      html += '<div class=\"section-divider\">‚ùì Unknown Tokens</div>';\n\n      enhancedData.unknownTokens.forEach(token => {\n        html += this.renderTokenCard(token, false, true, isNetworked);\n      });\n    }\n\n    // Handle empty state\n    if (html === '') {\n      html = `\n        <div class=\"empty-state\">\n          <h3>No Tokens</h3>\n          <p>This team hasn't scanned any tokens yet</p>\n        </div>\n      `;\n    }\n\n    // Update container\n    const container = document.getElementById('teamDetailsContainer');\n    if (container) {\n      container.innerHTML = html;\n    }\n\n    // Check if backend has authoritative score (networked mode only)\n    // backendScores only exists in networked mode\n    const backendScore = isNetworked && this.dataManager?.backendScores?.get(teamId);\n\n    // Use backend scores if available (authoritative in networked mode)\n    let displayBaseScore = scoreData.baseScore;\n    let displayBonusScore = scoreData.bonusScore;\n    let displayTotalScore = scoreData.totalScore;\n\n    if (isNetworked && backendScore) {\n      displayBaseScore = backendScore.baseScore;\n      displayBonusScore = backendScore.bonusPoints;\n      displayTotalScore = backendScore.currentScore;\n    }\n\n    // Update score breakdown with authoritative values\n    const baseScoreEl = document.getElementById('teamBaseScore');\n    const bonusScoreEl = document.getElementById('teamBonusScore');\n    const totalScoreEl = document.getElementById('teamTotalScore');\n\n    if (baseScoreEl) baseScoreEl.textContent = `$${displayBaseScore.toLocaleString()}`;\n    if (bonusScoreEl) bonusScoreEl.textContent = `$${displayBonusScore.toLocaleString()}`;\n    if (totalScoreEl) totalScoreEl.textContent = `$${displayTotalScore.toLocaleString()}`;\n\n    // Display admin adjustments if present\n    const adjustmentsSection = document.getElementById('teamAdminAdjustmentsSection');\n    if (adjustmentsSection && isNetworked && backendScore?.adminAdjustments?.length > 0) {\n      const adjustments = backendScore.adminAdjustments;\n      const totalAdjustment = adjustments.reduce((sum, adj) => sum + adj.delta, 0);\n\n      let adjHtml = `\n        <div class=\"transaction-detail\" style=\"margin: 8px 0; padding: 12px; background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; border-radius: 4px;\">\n          <label style=\"color: #856404; font-weight: bold;\">‚ö†Ô∏è Admin Adjustments:</label>\n          <span class=\"value\" style=\"color: ${totalAdjustment >= 0 ? '#28a745' : '#dc3545'}; font-weight: bold;\">\n            ${totalAdjustment >= 0 ? '+' : ''}$${Math.abs(totalAdjustment).toLocaleString()}\n          </span>\n        </div>\n        <div style=\"margin-left: 20px; font-size: 12px; color: #666;\">\n      `;\n\n      adjustments.forEach(adj => {\n        const date = new Date(adj.timestamp).toLocaleString();\n        adjHtml += `\n          <div style=\"margin: 4px 0; padding: 6px; background: #f8f9fa; border-radius: 3px;\">\n            <span style=\"color: ${adj.delta >= 0 ? '#28a745' : '#dc3545'}; font-weight: bold;\">\n              ${adj.delta >= 0 ? '+' : ''}$${Math.abs(adj.delta).toLocaleString()}\n            </span>\n            - ${adj.reason || 'No reason provided'}\n            <br><span style=\"font-size: 10px; color: #999;\">${date} by ${adj.gmStation}</span>\n          </div>\n        `;\n      });\n\n      adjHtml += '</div>';\n      adjustmentsSection.innerHTML = adjHtml;\n      adjustmentsSection.style.display = 'block';\n    } else if (adjustmentsSection) {\n      adjustmentsSection.style.display = 'none';\n    }\n\n    // Show intervention controls in both networked and standalone modes\n    const interventionControls = document.getElementById('teamInterventionControls');\n    if (interventionControls) {\n      // Show controls if we have an active game session (networked or standalone)\n      const hasActiveSession = this.sessionModeManager?.isNetworked() || this.sessionModeManager?.isStandalone();\n      interventionControls.style.display = hasActiveSession ? 'block' : 'none';\n    }\n\n    // Store team ID for intervention handlers\n    if (this.app) {\n      this.app.currentInterventionTeamId = teamId;\n    }\n  }\n\n  /**\n   * Render individual token card\n   * @param {Object} token - Token data (transaction object)\n   * @param {boolean} hasBonus - Whether token has group bonus\n   * @param {boolean} isUnknown - Whether token is unknown\n   * @param {boolean} showDelete - Show delete button (both networked and standalone modes)\n   * @returns {string} HTML string\n   */\n  renderTokenCard(token, hasBonus = false, isUnknown = false, showDelete = false) {\n    const dataSource = this.dataManager;\n    if (!dataSource) return '';\n\n    const tokenValue = dataSource.calculateTokenValue(token);\n\n    // Add duplicate marker\n    const isDuplicate = token.status === 'duplicate';\n    let cardClass = isUnknown ? 'unknown' : (hasBonus ? 'bonus-applied' : '');\n    if (isDuplicate) cardClass += ' duplicate';\n\n    let calculationText = '';\n    if (!isUnknown && !token.isUnknown) {\n      const baseValue = dataSource.SCORING_CONFIG.BASE_VALUES[token.valueRating] || 0;\n      const multiplier = dataSource.SCORING_CONFIG.TYPE_MULTIPLIERS[token.memoryType] || 1;\n\n      if (hasBonus) {\n        const groupInfo = dataSource.parseGroupInfo(token.group);\n        const finalValue = tokenValue * groupInfo.multiplier;\n        calculationText = `\n          <strong>${baseValue.toLocaleString()}</strong> √ó\n          <strong>${multiplier}x</strong> ${token.memoryType} √ó\n          <strong>${groupInfo.multiplier}x</strong> group =\n          <strong>$${finalValue.toLocaleString()}</strong>`;\n      } else {\n        calculationText = `\n          <strong>${baseValue.toLocaleString()}</strong> √ó\n          <strong>${multiplier}x</strong> ${token.memoryType} =\n          <strong>$${tokenValue.toLocaleString()}</strong>`;\n      }\n    } else {\n      calculationText = 'Unknown token - No value';\n    }\n\n    // Delete button (both modes)\n    const deleteButton = showDelete && token.id ? `\n      <button class=\"btn\" data-action=\"app.deleteTeamTransaction\" data-arg=\"${token.id}\"\n              style=\"background: #dc3545; color: white; padding: 4px 8px; font-size: 12px; margin-left: 8px; cursor: pointer;\">\n        üóëÔ∏è Delete\n      </button>\n    ` : '';\n\n    const groupInfo = dataSource.parseGroupInfo(token.group);\n    const displayValue = hasBonus ? tokenValue * groupInfo.multiplier : tokenValue;\n\n    return `\n      <div class=\"token-detail-card ${cardClass}\">\n        <div class=\"token-detail-header\">\n          <span>${token.group}</span>\n          <span class=\"token-detail-value\" style=\"display: flex; align-items: center;\">\n            <span style=\"margin-right: 8px;\">$${displayValue.toLocaleString()}</span>\n            ${deleteButton}\n          </span>\n        </div>\n        <div class=\"token-detail-grid\">\n          <div class=\"token-detail-item\">\n            <span class=\"token-detail-label\">RFID</span>\n            <span class=\"token-detail-info\">${token.rfid}</span>\n          </div>\n          <div class=\"token-detail-item\">\n            <span class=\"token-detail-label\">Memory Type</span>\n            <span class=\"token-detail-info\">${token.memoryType}</span>\n          </div>\n          <div class=\"token-detail-item\">\n            <span class=\"token-detail-label\">Base Rating</span>\n            <span class=\"token-detail-info\">\n              ${isUnknown ? 'N/A' : `‚≠ê${'‚≠ê'.repeat(Math.max(0, token.valueRating - 1))}`}\n            </span>\n          </div>\n          <div class=\"token-detail-item\">\n            <span class=\"token-detail-label\">Status</span>\n            <span class=\"token-detail-info\">\n              ${isDuplicate ? '‚ö†Ô∏è Duplicate' : hasBonus ? '‚úÖ Bonus Applied' : isUnknown ? '‚ùì Unknown' : '‚è≥ No Bonus'}\n            </span>\n          </div>\n          <div class=\"token-calculation\">\n            ${calculationText}\n          </div>\n        </div>\n      </div>\n    `;\n  }\n\n  /**\n   * Show notification for group completion (from backend event)\n   * @param {Object} data - Group completion data\n   */\n  showGroupCompletionNotification(data) {\n    // Create a temporary notification element\n    const notification = document.createElement('div');\n    notification.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      background: linear-gradient(135deg, #667eea, #764ba2);\n      color: white;\n      padding: 15px 20px;\n      border-radius: 12px;\n      box-shadow: 0 10px 30px rgba(0,0,0,0.3);\n      z-index: 10000;\n      animation: slideIn 0.3s ease-out;\n      max-width: 350px;\n    `;\n\n    notification.innerHTML = `\n      <div style=\"display: flex; align-items: center; gap: 10px;\">\n        <span style=\"font-size: 24px;\">üèÜ</span>\n        <div>\n          <div style=\"font-weight: bold; margin-bottom: 5px;\">Group Completed!</div>\n          <div style=\"font-size: 14px;\">Team ${data.teamId} - ${data.groupId}</div>\n          <div style=\"font-size: 14px;\">Bonus: +$${data.bonus.toLocaleString()} (${data.multiplier}x)</div>\n        </div>\n      </div>\n    `;\n\n    document.body.appendChild(notification);\n\n    // Remove after 5 seconds\n    setTimeout(() => {\n      notification.style.animation = 'fadeOut 0.3s ease-out forwards';\n      setTimeout(() => notification.remove(), 300);\n    }, 5000);\n  }\n\n  /**\n   * Show token scan result\n   * @param {Object} token - Token data\n   * @param {string} tokenId - Token ID\n   * @param {boolean} isUnknown - Whether token is unknown\n   */\n  showTokenResult(token, tokenId, isUnknown) {\n    const dataSource = this.dataManager;\n    if (!dataSource || !this.settings) return;\n\n    const statusEl = document.getElementById('resultStatus');\n    const rfidEl = document.getElementById('resultRfid');\n    const typeEl = document.getElementById('resultType');\n    const groupEl = document.getElementById('resultGroup');\n    const valueEl = document.getElementById('resultValue');\n    const summaryContainer = document.getElementById('resultSummaryContainer');\n    const summaryEl = document.getElementById('resultSummary');\n\n    if (!statusEl || !rfidEl || !typeEl || !groupEl || !valueEl) return;\n\n    if (isUnknown) {\n      statusEl.className = 'status-message error';\n      statusEl.innerHTML = `\n        <h2>Unknown Token</h2>\n        <p style=\"font-size: 14px;\">Not in database</p>\n      `;\n      rfidEl.textContent = tokenId;\n      typeEl.textContent = 'UNKNOWN';\n      typeEl.style.color = '#FF5722';\n      groupEl.textContent = `Raw ID: ${tokenId}`;\n\n      if (this.settings.mode === 'blackmarket') {\n        valueEl.textContent = '$0';\n      } else {\n        valueEl.textContent = 'No Value';\n      }\n\n      // Hide summary for unknown tokens\n      if (summaryContainer) {\n        summaryContainer.style.display = 'none';\n      }\n    } else {\n      statusEl.className = 'status-message success';\n      statusEl.innerHTML = '<h2>Transaction Complete!</h2>';\n      rfidEl.textContent = tokenId;\n      typeEl.textContent = token.SF_MemoryType;\n      typeEl.style.color = '#333';\n      groupEl.textContent = token.SF_Group;\n\n      if (this.settings.mode === 'blackmarket') {\n        const tokenScore = dataSource.calculateTokenValue({\n          valueRating: token.SF_ValueRating,\n          memoryType: token.SF_MemoryType,\n          isUnknown: false\n        });\n        valueEl.textContent = `$${tokenScore.toLocaleString()}`;\n      } else {\n        valueEl.textContent = '‚≠ê'.repeat(token.SF_ValueRating || 0);\n      }\n\n      // Show summary if available (all modes - gives GM visibility on token content)\n      if (token.summary && summaryContainer && summaryEl) {\n        summaryContainer.style.display = 'flex';\n        summaryEl.textContent = token.summary;\n      } else if (summaryContainer) {\n        summaryContainer.style.display = 'none';\n      }\n    }\n\n    this.showScreen('result');\n    // Quick-dismiss is now handled by showScreen('result') -> _enableResultScreenQuickDismiss()\n  }\n\n  /**\n   * Escape HTML to prevent XSS\n   * @param {string} text - Text to escape\n   * @returns {string} Escaped text\n   */\n  escapeHtml(text) {\n    if (!text) return '';\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n\n  /**\n   * Format timestamp to time string (HH:MM)\n   * @param {string} timestamp - ISO timestamp\n   * @returns {string} Formatted time\n   */\n  _formatTime(timestamp) {\n    if (!timestamp) return '';\n    const date = new Date(timestamp);\n    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\n  }\n\n  /**\n   * Unified game activity renderer - used by BOTH admin panel AND historyScreen\n   * @param {HTMLElement} container - Target container\n   * @param {Object} options - Rendering options\n   * @param {boolean} options.showSummary - Show stats bar (default: true)\n   * @param {boolean} options.showFilters - Show search/filter controls (default: true)\n   * @param {string} options.defaultFilter - 'all' | 'available' | 'claimed'\n   */\n  renderGameActivity(container, options = {}) {\n    if (!container) return;\n\n    const { showSummary = true, showFilters = true } = options;\n    const dataSource = this.dataManager;\n    if (!dataSource) return;\n\n    // UnifiedDataManager delegates to strategy - both modes support this now\n    // Defensive check in case dataManager doesn't have the method\n    if (typeof dataSource.getGameActivity !== 'function') {\n      container.innerHTML = `\n        <div class=\"empty-state\">\n          <h3>Game Activity</h3>\n          <p>No activity data available</p>\n        </div>\n      `;\n      return;\n    }\n\n    const { tokens, stats } = dataSource.getGameActivity();\n\n    let html = '';\n\n    // Summary bar - includes GM-only claims for observability\n    if (showSummary) {\n      html += `\n        <div class=\"activity-summary\">\n          <span class=\"stat\">${stats.totalTokens} tokens</span>\n          <span class=\"stat available\">${stats.available} available</span>\n          <span class=\"stat claimed\">${stats.claimed} claimed</span>\n          ${stats.claimedWithoutDiscovery > 0 ? `\n            <span class=\"stat warning\" title=\"Tokens claimed by GM without player discovery\">\n              ${stats.claimedWithoutDiscovery} GM-only\n            </span>\n          ` : ''}\n        </div>\n      `;\n    }\n\n    // Filter controls\n    if (showFilters) {\n      html += `\n        <div class=\"activity-filters\">\n          <input type=\"text\" id=\"activitySearch\" placeholder=\"Search tokens...\" class=\"search-input\">\n          <select id=\"activityFilter\" class=\"filter-select\">\n            <option value=\"all\">All Tokens</option>\n            <option value=\"available\">Available Only</option>\n            <option value=\"claimed\">Claimed Only</option>\n          </select>\n        </div>\n      `;\n    }\n\n    // Token cards - sorted by MOST RECENT activity (not just discovery)\n    html += '<div class=\"activity-grid\">';\n\n    if (tokens.length === 0) {\n      html += '<div class=\"empty-state\">No token activity yet</div>';\n    } else {\n      // Sort by most recent event per token (last event timestamp)\n      const getLatestTimestamp = (token) => {\n        if (!token.events || !token.events.length) return 0;\n        return new Date(token.events[token.events.length - 1].timestamp);\n      };\n\n      tokens\n        .sort((a, b) => getLatestTimestamp(b) - getLatestTimestamp(a))\n        .forEach(token => {\n          html += this._renderActivityTokenCard(token);\n        });\n    }\n\n    html += '</div>';\n    container.innerHTML = html;\n\n    // Attach filter handlers\n    this._attachActivityFilterHandlers(container);\n  }\n\n  /**\n   * Render a single token card for game activity\n   * @param {Object} token - Token activity data\n   * @returns {string} HTML string\n   */\n  _renderActivityTokenCard(token) {\n    const { tokenId, tokenData, events, status, discoveredByPlayers, potentialValue } = token;\n    const memoryType = tokenData?.SF_MemoryType || 'Unknown';\n    const rating = tokenData?.SF_ValueRating || 0;\n\n    // Count scan events for collapse logic\n    const scanEvents = events.filter(e => e.type === 'scan');\n    const hasMultipleScans = scanEvents.length > 0;\n    const claimEvent = events.find(e => e.type === 'claim');\n\n    // Generate status bar content based on state\n    let statusContent;\n    if (status === 'claimed' && claimEvent?.mode === 'blackmarket') {\n      // Black Market: Show earned value\n      statusContent = `<span class=\"status-icon\">üí∞</span> SOLD to ${this.escapeHtml(claimEvent?.teamId || 'Unknown')}\n        <span class=\"points\">$${(claimEvent?.points || 0).toLocaleString()}</span>`;\n    } else if (status === 'claimed' && claimEvent?.mode === 'detective') {\n      // Detective: Show what they gave up\n      statusContent = `<span class=\"status-icon\">üîç</span> EXPOSED by ${this.escapeHtml(claimEvent?.teamId || 'Unknown')}\n        <span class=\"points potential\">Worth: $${(potentialValue || 0).toLocaleString()}</span>`;\n    } else {\n      // Available: Show potential value\n      statusContent = `‚óã AVAILABLE\n        <span class=\"points potential\">Worth: $${(potentialValue || 0).toLocaleString()}</span>`;\n    }\n\n    return `\n      <div class=\"token-card ${status}\" data-token-id=\"${tokenId}\">\n        <!-- Header: Token ID + Type + Rating -->\n        <div class=\"token-card__header\">\n          <span class=\"token-id\">${this.escapeHtml(tokenId)}</span>\n          <span class=\"token-type type-${memoryType.toLowerCase()}\">${memoryType}</span>\n        </div>\n        <div class=\"token-card__rating\">${'‚òÖ'.repeat(rating)}${'‚òÜ'.repeat(5-rating)}</div>\n\n        <!-- Status Bar: Quick-glance current state with mode-specific styling -->\n        <div class=\"token-card__status status-${status} ${claimEvent?.mode || ''}\">\n          ${statusContent}\n        </div>\n\n        ${tokenData?.summary ? `\n          <div class=\"token-card__summary\">\n            <button class=\"summary-toggle\" onclick=\"this.parentElement.classList.toggle('expanded')\">Intel</button>\n            <div class=\"summary-content\">${this.escapeHtml(tokenData.summary)}</div>\n          </div>\n        ` : ''}\n\n        <!-- Timeline: Full event history (expandable) -->\n        <div class=\"token-card__timeline ${hasMultipleScans ? 'expandable' : ''}\"\n             data-expanded=\"false\">\n\n          ${!discoveredByPlayers && status === 'claimed' ? `\n            <div class=\"event warning\">\n              <span class=\"icon\">‚ö†Ô∏è</span>\n              <span class=\"label\">Not discovered by players</span>\n            </div>\n          ` : ''}\n\n          ${events.map((event, idx) => this._renderTimelineEvent(event, idx, events.length)).join('')}\n\n          ${status === 'available' ? `\n            <div class=\"event status-available\">\n              <span class=\"status-badge\">AWAITING CLAIM</span>\n            </div>\n          ` : ''}\n        </div>\n\n        ${hasMultipleScans ? `\n          <button class=\"timeline-toggle\" onclick=\"this.parentElement.querySelector('.token-card__timeline').dataset.expanded =\n            this.parentElement.querySelector('.token-card__timeline').dataset.expanded === 'true' ? 'false' : 'true'\">\n            <span class=\"expand-text\">Show ${scanEvents.length} more scans</span>\n            <span class=\"collapse-text\">Collapse</span>\n          </button>\n        ` : ''}\n      </div>\n    `;\n  }\n\n  /**\n   * Render a single timeline event\n   * @param {Object} event - Event data\n   * @param {number} index - Event index\n   * @param {number} totalEvents - Total events count\n   * @returns {string} HTML string\n   */\n  _renderTimelineEvent(event, index, totalEvents) {\n    const time = this._formatTime(event.timestamp);\n\n    switch (event.type) {\n      case 'discovery':\n        return `\n          <div class=\"event discovery\">\n            <span class=\"icon\">üëÅ</span>\n            <span class=\"label\">Discovered</span>\n            <span class=\"device\">${this.escapeHtml(event.deviceId)}</span>\n            <span class=\"time\">${time}</span>\n          </div>\n        `;\n\n      case 'scan':\n        // Additional scans - collapsible by default\n        return `\n          <div class=\"event scan collapsible\">\n            <span class=\"icon\">üëÅ</span>\n            <span class=\"label\">Scanned</span>\n            <span class=\"device\">${this.escapeHtml(event.deviceId)}</span>\n            <span class=\"time\">${time}</span>\n          </div>\n        `;\n\n      case 'claim':\n        return `\n          <div class=\"event claim ${event.mode}\">\n            <span class=\"icon\">${event.mode === 'blackmarket' ? 'üí∞' : 'üîç'}</span>\n            <span class=\"label\">${event.mode === 'blackmarket' ? 'Black Market' : 'Detective'}</span>\n            <span class=\"team\">${this.escapeHtml(event.teamId)}</span>\n            <span class=\"time\">${time}</span>\n            <span class=\"points\">$${(event.points || 0).toLocaleString()}</span>\n            ${event.groupProgress ? `\n              <div class=\"group-progress\">\n                ${this.escapeHtml(event.groupProgress.name)} (${event.groupProgress.found}/${event.groupProgress.total})\n              </div>\n            ` : ''}\n            ${event.summary ? `\n              <div class=\"exposed-summary\">\n                <span class=\"summary-label\">Intel:</span>\n                <span class=\"summary-text\">${this.escapeHtml(event.summary)}</span>\n              </div>\n            ` : ''}\n          </div>\n        `;\n\n      default:\n        return '';\n    }\n  }\n\n  /**\n   * Attach filter handlers for game activity\n   * @param {HTMLElement} container - Container element\n   */\n  _attachActivityFilterHandlers(container) {\n    const searchInput = container.querySelector('#activitySearch');\n    const filterSelect = container.querySelector('#activityFilter');\n\n    if (searchInput) {\n      searchInput.addEventListener('input', () => this._filterGameActivity(container));\n    }\n    if (filterSelect) {\n      filterSelect.addEventListener('change', () => this._filterGameActivity(container));\n    }\n  }\n\n  /**\n   * Filter game activity based on search and filter\n   * @param {HTMLElement} container - Container element\n   */\n  _filterGameActivity(container) {\n    const searchInput = container.querySelector('#activitySearch');\n    const filterSelect = container.querySelector('#activityFilter');\n    const cards = container.querySelectorAll('.token-card');\n\n    const searchTerm = searchInput?.value?.toLowerCase() || '';\n    const filterValue = filterSelect?.value || 'all';\n\n    cards.forEach(card => {\n      const tokenId = card.dataset.tokenId?.toLowerCase() || '';\n      const status = card.classList.contains('claimed') ? 'claimed' : 'available';\n\n      const matchesSearch = !searchTerm || tokenId.includes(searchTerm);\n      const matchesFilter = filterValue === 'all' || status === filterValue;\n\n      card.style.display = matchesSearch && matchesFilter ? 'block' : 'none';\n    });\n  }\n}\n\n// Export class (not pre-created instance)\n// Instance created in main.js with proper dependency injection\nexport default UIManager;\nexport { UIManager };\n","/**\n * Settings Manager\n * Manages station configuration (device ID and mode)\n * ES6 Module - Event-Driven Architecture\n *\n * Emits events:\n * - 'settings:loaded' - After loading from localStorage\n * - 'settings:saved' - After saving to localStorage\n * - 'settings:changed' - When any setting value changes\n */\n\nclass Settings extends EventTarget {\n  /**\n   * Create Settings instance\n   * Pure event-driven - no dependencies on UIManager\n   */\n  constructor() {\n    super();\n    this.deviceId = '001';\n    this.mode = 'detective';\n  }\n\n  /**\n   * Load settings from localStorage\n   * Emits 'settings:loaded' event\n   */\n  load() {\n    this.deviceId = localStorage.getItem('deviceId') || '001';\n    this.mode = localStorage.getItem('mode') || 'detective';\n\n    this.dispatchEvent(new CustomEvent('settings:loaded', {\n      detail: { deviceId: this.deviceId, mode: this.mode }\n    }));\n  }\n\n  /**\n   * Save settings to localStorage\n   * Emits 'settings:saved' and 'settings:changed' events\n   */\n  save() {\n    const oldDeviceId = localStorage.getItem('deviceId') || '001';\n    const oldMode = localStorage.getItem('mode') || 'detective';\n\n    localStorage.setItem('deviceId', this.deviceId);\n    localStorage.setItem('mode', this.mode);\n\n    const deviceIdDisplay = document.getElementById('deviceIdDisplay');\n    if (deviceIdDisplay) {\n      deviceIdDisplay.textContent = this.deviceId;\n    }\n\n    this.dispatchEvent(new CustomEvent('settings:saved', {\n      detail: { deviceId: this.deviceId, mode: this.mode }\n    }));\n\n    if (oldDeviceId !== this.deviceId || oldMode !== this.mode) {\n      this.dispatchEvent(new CustomEvent('settings:changed', {\n        detail: { deviceId: this.deviceId, mode: this.mode, oldDeviceId, oldMode }\n      }));\n    }\n  }\n}\n\n// Create singleton instance\nconst settings = new Settings();\n\nexport default settings;\nexport { Settings };\n","/**\n * Token Manager - Token Database and Group Inventory\n * ES6 Module Export\n *\n * Responsibilities:\n * - Load token database from external JSON\n * - Fuzzy token ID matching (case-insensitive, with/without colons)\n * - Build group inventory for bonus calculations\n * - Demo data fallback\n */\n\nimport Debug from '../utils/debug.js';\n\n/**\n * TokenManager Class\n * Manages token database and provides lookup functionality\n */\nclass TokenManagerClass {\n  constructor() {\n    this.database = {};\n    this.groupInventory = null;\n    this._dataManagerHelpers = null; // Injected dependency\n  }\n\n  /**\n   * Inject DataManager helper methods (dependency injection)\n   * @param {Object} helpers - Object with parseGroupInfo and normalizeGroupName methods\n   */\n  setDataManagerHelpers(helpers) {\n    this._dataManagerHelpers = helpers;\n  }\n\n  /**\n   * Load token database from external JSON file\n   * @returns {Promise<boolean>} Success status\n   */\n  async loadDatabase() {\n    try {\n      // Try loading from submodule path first\n      let response = await fetch('data/tokens.json');\n      if (!response.ok) {\n        Debug.log('Trying root directory for tokens.json');\n        // Fallback to root directory for backward compatibility\n        response = await fetch('tokens.json');\n        if (!response.ok) {\n          throw new Error('Failed to load tokens.json from data/ or root');\n        }\n      }\n      this.database = await response.json();\n      Debug.log(`‚úÖ Loaded ${Object.keys(this.database).length} tokens from ${response.url}`);\n      Debug.log(`Sample keys: ${Object.keys(this.database).slice(0, 3).join(', ')}`);\n\n      // Build group inventory for bonus calculations\n      this.groupInventory = this.buildGroupInventory();\n      this.logGroupStats();\n\n      return true;\n    } catch (error) {\n      Debug.log(`Token database error: ${error.message}`, true);\n      // CRITICAL: Fail hard if database cannot be loaded.\n      // Do NOT load demo data.\n      return false;\n    }\n  }\n\n  /**\n   * Build inventory of all groups and their tokens\n   * @returns {Object} Group inventory map\n   */\n  buildGroupInventory() {\n    const groups = {};\n    const issues = [];\n\n    Object.entries(this.database).forEach(([rfid, token]) => {\n      // Use injected helpers or fallback to inline parsing\n      const groupInfo = this._dataManagerHelpers\n        ? this._dataManagerHelpers.parseGroupInfo(token.SF_Group)\n        : this._parseGroupInfoFallback(token.SF_Group);\n\n      const normalizedName = this._dataManagerHelpers\n        ? this._dataManagerHelpers.normalizeGroupName(groupInfo.name)\n        : this._normalizeGroupNameFallback(groupInfo.name);\n\n      if (!groups[normalizedName]) {\n        groups[normalizedName] = {\n          displayName: groupInfo.name,\n          normalizedName: normalizedName,\n          multiplier: groupInfo.multiplier,\n          tokens: new Set(),\n          rawGroupNames: new Set(),\n          memoryTypes: new Set()\n        };\n      }\n\n      // Add token to group\n      groups[normalizedName].tokens.add(rfid);\n      groups[normalizedName].rawGroupNames.add(token.SF_Group);\n      groups[normalizedName].memoryTypes.add(token.SF_MemoryType);\n\n      // Check for multiplier consistency\n      if (groups[normalizedName].multiplier !== groupInfo.multiplier) {\n        issues.push(`Group \"${groupInfo.name}\" has inconsistent multipliers`);\n        // Keep the higher multiplier\n        groups[normalizedName].multiplier = Math.max(\n          groups[normalizedName].multiplier,\n          groupInfo.multiplier\n        );\n      }\n\n      // Update display name if this one is \"better\"\n      if (groupInfo.name.length > groups[normalizedName].displayName.length ||\n        (groupInfo.name.length === groups[normalizedName].displayName.length &&\n          groupInfo.name > groups[normalizedName].displayName)) {\n        groups[normalizedName].displayName = groupInfo.name;\n      }\n    });\n\n    // Log any issues found\n    if (issues.length > 0) {\n      Debug.log('=== Group Inventory Issues ===', true);\n      issues.forEach(issue => Debug.log(issue, true));\n    }\n\n    return groups;\n  }\n\n  /**\n   * Fallback group info parser (until DataManager is converted)\n   * Format: \"Group Name (xN)\" where N is multiplier\n   */\n  _parseGroupInfoFallback(groupString) {\n    if (!groupString) {\n      return { name: '', multiplier: 1 };\n    }\n\n    const match = groupString.match(/^(.+?)\\s*\\(x(\\d+)\\)$/i);\n    if (match) {\n      return {\n        name: match[1].trim(),\n        multiplier: parseInt(match[2], 10)\n      };\n    }\n\n    return { name: groupString.trim(), multiplier: 1 };\n  }\n\n  /**\n   * Fallback group name normalizer (until DataManager is converted)\n   * Lowercase, trim, remove extra whitespace\n   */\n  _normalizeGroupNameFallback(name) {\n    return name.toLowerCase().trim().replace(/\\s+/g, ' ');\n  }\n\n  /**\n   * Log group statistics for debugging\n   */\n  logGroupStats() {\n    if (!this.groupInventory) return;\n\n    Debug.log('=== Group Inventory Summary ===');\n    const groups = Object.values(this.groupInventory);\n\n    Debug.log(`Total Groups: ${groups.length}`);\n\n    const completableGroups = groups.filter(g => g.multiplier > 1 && g.tokens.size > 1);\n    const singleTokenGroups = groups.filter(g => g.tokens.size === 1);\n\n    Debug.log(`Completable Groups: ${completableGroups.length}`);\n    Debug.log(`Single Token Groups: ${singleTokenGroups.length}`);\n\n    // Log details for each group\n    groups.sort((a, b) => b.tokens.size - a.tokens.size).forEach(group => {\n      Debug.log(`\"${group.displayName}\": ${group.tokens.size} tokens, ${group.multiplier}x`);\n\n      if (group.tokens.size === 1 && group.multiplier > 1) {\n        Debug.log(`  ‚ö†Ô∏è Only 1 token but ${group.multiplier}x multiplier`, true);\n      }\n    });\n  }\n\n  /**\n   * Get group inventory with caching\n   * @returns {Object} Group inventory\n   */\n  getGroupInventory() {\n    if (!this.groupInventory) {\n      this.groupInventory = this.buildGroupInventory();\n    }\n    return this.groupInventory;\n  }\n\n  /**\n   * Get all tokens from database\n   * @returns {Array} Array of all token objects\n   */\n  getAllTokens() {\n    return Object.values(this.database);\n  }\n\n  /**\n   * Find token in database with fuzzy matching\n   * Handles: case variations, with/without colons, with/without hyphens\n   * @param {string} id - Token ID to find\n   * @returns {Object|null} Token data and matched ID, or null if not found\n   */\n  findToken(id) {\n    Debug.log(`üîç findToken called with: \"${id}\"`);\n    Debug.log(`Database has ${Object.keys(this.database).length} tokens`);\n    Debug.log(`First 5 keys: ${Object.keys(this.database).slice(0, 5).join(', ')}`);\n\n    // Direct match\n    if (this.database[id]) {\n      Debug.log(`‚úÖ Direct match: ${id}`);\n      return { token: this.database[id], matchedId: id };\n    }\n\n    // Normalize input: remove colons/hyphens, lowercase\n    const normalizedInput = id.replace(/[:-]/g, '').toLowerCase();\n\n    // Try matching against normalized database keys\n    for (const [dbKey, token] of Object.entries(this.database)) {\n      const normalizedDbKey = dbKey.replace(/[:-]/g, '').toLowerCase();\n\n      if (normalizedInput === normalizedDbKey) {\n        Debug.log(`‚úÖ Fuzzy match: \"${id}\" -> \"${dbKey}\"`);\n        return { token, matchedId: dbKey };\n      }\n    }\n\n    Debug.log(`No match found for: ${id}`, true);\n    return null;\n  }\n}\n\n// Create singleton instance\nconst TokenManager = new TokenManagerClass();\n\nexport default TokenManager;\nexport { TokenManagerClass };\n","/**\n * IStorageStrategy - Interface for data storage strategies\n * Implemented by NetworkedStorage and LocalStorage\n *\n * @interface IStorageStrategy\n */\n\n/**\n * @typedef {Object} Transaction\n * @property {string} id - Unique transaction ID\n * @property {string} tokenId - Token identifier (from NFC/manual entry)\n * @property {string} teamId - Team identifier\n * @property {string} mode - Transaction mode ('blackmarket' | 'detective')\n * @property {number} [points] - Score value (blackmarket mode only)\n * @property {number} [valueRating] - Token star rating (1-5)\n * @property {string} [memoryType] - Token type ('Personal' | 'Business' | 'Technical')\n * @property {string} [group] - Group name with multiplier, e.g., \"Server Logs (x5)\"\n * @property {boolean} [isUnknown] - True if token not found in database\n * @property {string} timestamp - ISO timestamp of transaction\n */\n\n/**\n * @typedef {Object} TransactionResult\n * @property {boolean} success - Whether operation succeeded\n * @property {boolean} [pending] - True if operation is pending backend confirmation (NetworkedStorage)\n * @property {Transaction} [transaction] - The processed transaction\n * @property {Object} [teamScore] - Updated team score\n * @property {number} [teamScore.score] - Current total score\n * @property {number} [teamScore.baseScore] - Score from tokens only\n * @property {number} [teamScore.bonusPoints] - Score from group completions\n * @property {number} [teamScore.tokensScanned] - Number of tokens scanned\n * @property {Object} [groupBonusInfo] - Group completion info if applicable\n * @property {string} [groupBonusInfo.groupName] - Name of completed group\n * @property {number} [groupBonusInfo.bonus] - Bonus points awarded\n * @property {string} [error] - Error message if failed\n */\n\n/**\n * @typedef {Object} SessionInfo\n * @property {string} sessionId - Session identifier\n * @property {string} [name] - Session name\n * @property {string} startTime - ISO timestamp\n * @property {string} [status] - Session status ('active' | 'paused' | 'ended')\n */\n\n/**\n * Storage strategy interface - defines contract for data persistence\n *\n * Implementations:\n * - NetworkedStorage: WebSocket communication with backend\n * - LocalStorage: Browser localStorage persistence\n *\n * Extends EventTarget to allow strategies to emit events that can be\n * forwarded by UnifiedDataManager to consumers.\n */\nexport class IStorageStrategy extends EventTarget {\n  constructor() {\n    super();\n  }\n  /**\n   * Initialize the storage strategy\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    throw new Error('IStorageStrategy.initialize() must be implemented');\n  }\n\n  /**\n   * Add a transaction\n   * @param {Transaction} transaction - Transaction data\n   * @returns {Promise<TransactionResult>}\n   */\n  async addTransaction(transaction) {\n    throw new Error('IStorageStrategy.addTransaction() must be implemented');\n  }\n\n  /**\n   * Remove a transaction\n   * @param {string} transactionId - Transaction ID to remove\n   * @returns {Promise<TransactionResult>}\n   */\n  async removeTransaction(transactionId) {\n    throw new Error('IStorageStrategy.removeTransaction() must be implemented');\n  }\n\n  /**\n   * Get all transactions\n   * @returns {Array} Array of transactions\n   */\n  getTransactions() {\n    throw new Error('IStorageStrategy.getTransactions() must be implemented');\n  }\n\n  /**\n   * Get team scores\n   * @returns {Array} Array of team score objects\n   */\n  getTeamScores() {\n    throw new Error('IStorageStrategy.getTeamScores() must be implemented');\n  }\n\n  /**\n   * Adjust team score (admin operation)\n   * @param {string} teamId - Team identifier\n   * @param {number} delta - Score adjustment amount\n   * @param {string} reason - Reason for adjustment\n   * @returns {Promise<TransactionResult>}\n   */\n  async adjustTeamScore(teamId, delta, reason) {\n    throw new Error('IStorageStrategy.adjustTeamScore() must be implemented');\n  }\n\n  /**\n   * Get game activity (player discoveries + GM transactions)\n   * @returns {Object} { tokens: Array, stats: Object }\n   */\n  getGameActivity() {\n    throw new Error('IStorageStrategy.getGameActivity() must be implemented');\n  }\n\n  /**\n   * Create a new session\n   * @param {string} name - Session name\n   * @param {Array} teams - Initial teams array\n   * @returns {Promise<SessionInfo>}\n   */\n  async createSession(name, teams) {\n    throw new Error('IStorageStrategy.createSession() must be implemented');\n  }\n\n  /**\n   * End the current session\n   * @returns {Promise<void>}\n   */\n  async endSession() {\n    throw new Error('IStorageStrategy.endSession() must be implemented');\n  }\n\n  /**\n   * Pause the current session\n   * @returns {Promise<{success: boolean, error?: string}>}\n   */\n  async pauseSession() {\n    throw new Error('IStorageStrategy.pauseSession() must be implemented');\n  }\n\n  /**\n   * Resume a paused session\n   * @returns {Promise<{success: boolean, error?: string}>}\n   */\n  async resumeSession() {\n    throw new Error('IStorageStrategy.resumeSession() must be implemented');\n  }\n\n  /**\n   * Reset all team scores to zero (keeps transactions for audit)\n   * @returns {Promise<{success: boolean}>}\n   */\n  async resetScores() {\n    throw new Error('IStorageStrategy.resetScores() must be implemented');\n  }\n\n  /**\n   * Get current session info\n   * @returns {SessionInfo|null}\n   */\n  getCurrentSession() {\n    throw new Error('IStorageStrategy.getCurrentSession() must be implemented');\n  }\n\n  /**\n   * Check if storage is ready/connected\n   * @returns {boolean}\n   */\n  isReady() {\n    throw new Error('IStorageStrategy.isReady() must be implemented');\n  }\n\n  /**\n   * Dispose of resources\n   */\n  dispose() {\n    // Optional cleanup - default no-op\n  }\n}\n","/**\n * Scoring Module - Shared Scoring Configuration and Utilities\n * ES6 Module Export\n *\n * Loads scoring configuration from shared ALN-TokenData submodule.\n * This ensures frontend and backend use identical scoring values.\n *\n * @module core/scoring\n */\n\n// Import shared config from data submodule (Vite resolves at build time)\nimport sharedConfig from '../../data/scoring-config.json';\n\n/**\n * Scoring configuration for Black Market mode\n * Maps value ratings and memory types to point values\n *\n * NOTE: Values loaded from ALN-TokenData/scoring-config.json\n */\nexport const SCORING_CONFIG = {\n    BASE_VALUES: Object.fromEntries(\n        Object.entries(sharedConfig.baseValues).map(([k, v]) => [parseInt(k), v])\n    ),\n    TYPE_MULTIPLIERS: { ...sharedConfig.typeMultipliers }\n};\n\n/**\n * Parse group info from group name string\n * Extracts group name and multiplier from format: \"Group Name (xN)\"\n *\n * @param {string} groupName - Group name with optional multiplier suffix\n * @returns {Object} Parsed group info with name and multiplier\n *\n * @example\n * parseGroupInfo(\"Marcus Sucks (x2)\")  // { name: \"Marcus Sucks\", multiplier: 2 }\n * parseGroupInfo(\"Ungrouped Token\")    // { name: \"Ungrouped Token\", multiplier: 1 }\n */\nexport function parseGroupInfo(groupName) {\n    if (!groupName) {\n        return { name: 'Unknown', multiplier: 1 };\n    }\n\n    // Trim input first to handle leading/trailing whitespace\n    const trimmed = groupName.trim();\n\n    // Match pattern: \"Group Name (xN)\"\n    const match = trimmed.match(/^(.+?)\\s*\\(x(\\d+)\\)$/i);\n\n    if (match) {\n        const name = match[1].trim();\n        const multiplier = parseInt(match[2]) || 1;\n\n        if (multiplier < 1) {\n            console.warn(`[scoring] Invalid multiplier ${multiplier} for \"${name}\", using 1`);\n            return { name, multiplier: 1 };\n        }\n\n        return { name, multiplier };\n    }\n\n    return { name: trimmed, multiplier: 1 };\n}\n\n/**\n * Normalize group name for consistent matching\n * Handles case insensitivity, whitespace normalization, and apostrophe variants\n *\n * @param {string} name - Group name to normalize\n * @returns {string} Normalized group name\n *\n * @example\n * normalizeGroupName(\"Marcus's Notes\")  // \"marcus's notes\"\n * normalizeGroupName(\"  Spaced  Out  \") // \"spaced out\"\n */\nexport function normalizeGroupName(name) {\n    if (!name) return '';\n\n    return name\n        .trim()\n        .toLowerCase()\n        .replace(/\\s+/g, ' ')\n        .replace(/['\\u2018\\u2019]/g, \"'\");  // Normalize curly apostrophes to straight\n}\n\n/**\n * Calculate base value of a token\n *\n * @param {Object} transaction - Transaction data\n * @param {number} transaction.valueRating - Star rating (1-5)\n * @param {string} transaction.memoryType - Memory type (Personal/Business/Technical)\n * @param {boolean} [transaction.isUnknown] - Whether token is unknown\n * @returns {number} Token value in points\n */\nexport function calculateTokenValue(transaction) {\n    if (transaction.isUnknown) return 0;\n\n    const baseValue = SCORING_CONFIG.BASE_VALUES[transaction.valueRating] || 0;\n    // Use UNKNOWN multiplier (0) for unknown types - matches backend behavior\n    const multiplier = SCORING_CONFIG.TYPE_MULTIPLIERS[transaction.memoryType]\n        ?? SCORING_CONFIG.TYPE_MULTIPLIERS.UNKNOWN\n        ?? 0;\n\n    return baseValue * multiplier;\n}\n","import { calculateTokenValue } from './scoring.js';\n\n/**\n * Build unified game activity from transactions and player scans.\n * Shared implementation for LocalStorage and NetworkedStorage.\n *\n * @param {Object} params\n * @param {Array} params.transactions - GM transaction records\n * @param {Array} params.playerScans - Player scanner discovery records\n * @param {Object} params.tokenManager - TokenManager for token lookup\n * @param {Object} [params.options] - Mode-specific options\n * @param {Function} [params.options.transactionFilter] - Filter function for transactions (networked: exclude non-accepted)\n * @param {Function} [params.options.pointsFallback] - Fallback for missing tx.points (networked: recalculate)\n * @returns {Object} { tokens: Array, stats: Object }\n */\nexport function buildGameActivity({ transactions, playerScans, tokenManager, options = {} }) {\n  const { transactionFilter, pointsFallback } = options;\n  const tokenMap = new Map();\n\n  // Process player scans (discoveries)\n  playerScans.forEach(scan => {\n    if (!tokenMap.has(scan.tokenId)) {\n      const tokenData = scan.tokenData || {};\n      tokenMap.set(scan.tokenId, {\n        tokenId: scan.tokenId,\n        tokenData,\n        potentialValue: calculateTokenValue({\n          valueRating: tokenData.SF_ValueRating,\n          memoryType: tokenData.SF_MemoryType\n        }),\n        events: [{\n          type: 'discovery',\n          timestamp: scan.timestamp,\n          deviceId: scan.deviceId\n        }],\n        status: 'available',\n        discoveredByPlayers: true\n      });\n    } else {\n      tokenMap.get(scan.tokenId).events.push({\n        type: 'scan',\n        timestamp: scan.timestamp,\n        deviceId: scan.deviceId\n      });\n    }\n  });\n\n  // Process GM transactions (claims)\n  transactions.forEach(tx => {\n    if (transactionFilter && !transactionFilter(tx)) return;\n\n    let activity = tokenMap.get(tx.tokenId);\n\n    if (!activity) {\n      const lookedUpToken = tokenManager?.findToken(tx.tokenId);\n      const tokenData = lookedUpToken ? {\n        SF_MemoryType: lookedUpToken.SF_MemoryType,\n        SF_ValueRating: lookedUpToken.SF_ValueRating,\n        SF_Group: lookedUpToken.SF_Group || null,\n        summary: lookedUpToken.summary || null\n      } : {\n        SF_MemoryType: tx.memoryType,\n        SF_ValueRating: tx.valueRating\n      };\n\n      activity = {\n        tokenId: tx.tokenId,\n        tokenData,\n        potentialValue: calculateTokenValue({\n          valueRating: tokenData.SF_ValueRating,\n          memoryType: tokenData.SF_MemoryType\n        }),\n        events: [],\n        status: 'claimed',\n        discoveredByPlayers: false\n      };\n      tokenMap.set(tx.tokenId, activity);\n    }\n\n    const points = pointsFallback && !tx.points\n      ? pointsFallback(tx)\n      : (tx.points || 0);\n\n    activity.events.push({\n      type: 'claim',\n      timestamp: tx.timestamp,\n      mode: tx.mode,\n      teamId: tx.teamId,\n      points,\n      summary: tx.summary || activity.tokenData?.summary || null\n    });\n    activity.status = 'claimed';\n  });\n\n  // Sort events chronologically within each token\n  tokenMap.forEach(activity => {\n    activity.events.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));\n  });\n\n  const tokens = Array.from(tokenMap.values());\n\n  return {\n    tokens,\n    stats: {\n      totalTokens: tokens.length,\n      available: tokens.filter(t => t.status === 'available').length,\n      claimed: tokens.filter(t => t.status === 'claimed').length,\n      claimedWithoutDiscovery: tokens.filter(t => t.status === 'claimed' && !t.discoveredByPlayers).length,\n      totalPlayerScans: playerScans.length\n    }\n  };\n}\n","/**\n * LocalStorage Strategy - Browser localStorage persistence\n * Implements IStorageStrategy for standalone mode operation\n *\n * @module core/storage/LocalStorage\n */\n\nimport { IStorageStrategy } from './IStorageStrategy.js';\nimport {\n  SCORING_CONFIG,\n  parseGroupInfo,\n  calculateTokenValue\n} from '../scoring.js';\nimport { buildGameActivity } from '../gameActivityBuilder.js';\n\nexport class LocalStorage extends IStorageStrategy {\n  /**\n   * Create LocalStorage instance\n   * @param {Object} options - Dependencies\n   * @param {Object} options.tokenManager - TokenManager instance\n   * @param {Object} [options.debug] - Debug instance\n   */\n  constructor({ tokenManager, debug } = {}) {\n    super();\n\n    this.tokenManager = tokenManager;\n    this.debug = debug;\n    this.SCORING_CONFIG = SCORING_CONFIG;\n\n    // Initialize session data\n    this.sessionData = {\n      sessionId: this._generateSessionId(),\n      startTime: new Date().toISOString(),\n      transactions: [],\n      teams: {},\n      mode: 'standalone'\n    };\n\n    // Track scanned tokens for duplicate detection\n    this.scannedTokens = new Set();\n\n    // Player scans (for getGameActivity parity)\n    this.playerScans = [];\n  }\n\n  /**\n   * Generate unique local session ID\n   * @private\n   */\n  _generateSessionId() {\n    return `LOCAL_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;\n  }\n\n  /**\n   * Check if storage is ready\n   * @returns {boolean} Always true for localStorage\n   */\n  isReady() {\n    return true;\n  }\n\n  /**\n   * Initialize storage (load from localStorage)\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    this._loadSession();\n  }\n\n  /**\n   * Load session from localStorage\n   * @private\n   */\n  _loadSession() {\n    const saved = localStorage.getItem('standaloneSession');\n    if (saved) {\n      try {\n        const parsed = JSON.parse(saved);\n        const sessionDate = new Date(parsed.startTime).toDateString();\n        const today = new Date().toDateString();\n\n        if (sessionDate === today) {\n          this.sessionData = parsed;\n          this._repopulateScannedTokens();\n          this.debug?.log(`Loaded session: ${parsed.sessionId}`);\n        }\n      } catch (e) {\n        this.debug?.log('Failed to load session', true);\n      }\n    }\n  }\n\n  /**\n   * Repopulate scannedTokens Set from loaded transactions\n   * @private\n   */\n  _repopulateScannedTokens() {\n    this.scannedTokens.clear();\n    this.sessionData.transactions.forEach(tx => {\n      const tokenId = tx.tokenId || tx.rfid;\n      if (tokenId) {\n        this.scannedTokens.add(tokenId);\n      }\n    });\n  }\n\n  /**\n   * Save session to localStorage\n   * @private\n   */\n  _saveSession() {\n    localStorage.setItem('standaloneSession', JSON.stringify(this.sessionData));\n  }\n\n  /**\n   * Get all transactions\n   * @returns {Array} Array of transactions\n   */\n  getTransactions() {\n    return this.sessionData.transactions;\n  }\n\n  /**\n   * Get team scores\n   * @returns {Array} Array of team score objects\n   */\n  getTeamScores() {\n    return Object.values(this.sessionData.teams)\n      .map(team => ({\n        teamId: team.teamId,\n        score: team.score,\n        baseScore: team.baseScore,\n        bonusScore: team.bonusPoints,\n        tokenCount: team.tokensScanned,\n        completedGroups: team.completedGroups?.length || 0,\n        isFromBackend: false\n      }))\n      .sort((a, b) => b.score - a.score);\n  }\n\n  /**\n   * Get current session info\n   * @returns {SessionInfo}\n   */\n  getCurrentSession() {\n    return {\n      sessionId: this.sessionData.sessionId,\n      name: this.sessionData.name,\n      startTime: this.sessionData.startTime,\n      status: this.sessionData.status || 'active'\n    };\n  }\n\n  /**\n   * Create a new session\n   * @param {string} name - Session name\n   * @param {Array} teams - Initial teams array\n   * @returns {Promise<SessionInfo>}\n   */\n  async createSession(name, teams) {\n    this.sessionData = {\n      sessionId: this._generateSessionId(),\n      name: name,\n      status: 'active',\n      startTime: new Date().toISOString(),\n      transactions: [],\n      teams: {},\n      mode: 'standalone'\n    };\n    this.scannedTokens.clear();\n    this._saveSession();\n\n    return this.getCurrentSession();\n  }\n\n  /**\n   * End the current session\n   * @returns {Promise<void>}\n   */\n  async endSession() {\n    this._saveSession();\n  }\n\n  /**\n   * Pause the current session\n   * Blocks scanning while paused\n   * @returns {Promise<{success: boolean, error?: string}>}\n   */\n  async pauseSession() {\n    // Check for explicit session with status (created via createSession)\n    if (!this.sessionData?.sessionId || !this.sessionData?.status) {\n      return { success: false, error: 'No active session to pause' };\n    }\n\n    if (this.sessionData.status === 'paused') {\n      return { success: false, error: 'Session already paused' };\n    }\n\n    this.sessionData.status = 'paused';\n    this.sessionData.pausedAt = new Date().toISOString();\n    this._saveSession();\n\n    // Emit event for UI updates\n    this.dispatchEvent(new CustomEvent('session:updated', {\n      detail: { session: this.getCurrentSession() }\n    }));\n\n    return { success: true };\n  }\n\n  /**\n   * Resume a paused session\n   * @returns {Promise<{success: boolean, error?: string}>}\n   */\n  async resumeSession() {\n    // Check for explicit session with status (created via createSession)\n    if (!this.sessionData?.sessionId || !this.sessionData?.status) {\n      return { success: false, error: 'No session to resume' };\n    }\n\n    if (this.sessionData.status !== 'paused') {\n      return { success: false, error: 'Session is not paused' };\n    }\n\n    this.sessionData.status = 'active';\n    delete this.sessionData.pausedAt;\n    this._saveSession();\n\n    // Emit event for UI updates\n    this.dispatchEvent(new CustomEvent('session:updated', {\n      detail: { session: this.getCurrentSession() }\n    }));\n\n    return { success: true };\n  }\n\n  /**\n   * Reset all team scores to zero\n   * Keeps transactions for audit trail\n   * @returns {Promise<{success: boolean}>}\n   */\n  async resetScores() {\n    // Zero all team scores\n    Object.keys(this.sessionData.teams).forEach(teamId => {\n      const team = this.sessionData.teams[teamId];\n      team.score = 0;\n      team.baseScore = 0;\n      team.bonusPoints = 0;\n      team.adminAdjustments = [];\n    });\n\n    this._saveSession();\n\n    // Emit event for UI updates\n    this.dispatchEvent(new CustomEvent('scores:cleared', {\n      detail: {}\n    }));\n\n    return { success: true };\n  }\n\n  /**\n   * Add transaction to local storage\n   * @param {Transaction} transaction - Transaction data\n   * @returns {Promise<TransactionResult>}\n   */\n  async addTransaction(transaction) {\n    // Check if session is paused\n    if (this.sessionData?.status === 'paused') {\n      return {\n        success: false,\n        error: 'Cannot add transaction: session is paused'\n      };\n    }\n\n    // Validate required fields\n    if (!transaction || !transaction.teamId) {\n      return {\n        success: false,\n        error: 'Transaction must have teamId'\n      };\n    }\n\n    // Add to transactions array\n    this.sessionData.transactions.push(transaction);\n\n    // Mark token as scanned\n    const tokenId = transaction.tokenId || transaction.rfid;\n    if (tokenId) {\n      this.scannedTokens.add(tokenId);\n    }\n\n    // Update team scores\n    this._updateTeamScore(transaction);\n\n    // Persist\n    this._saveSession();\n\n    // Emit event for ScreenUpdateManager (badge, stats, screen-specific handlers)\n    this.dispatchEvent(new CustomEvent('transaction:added', {\n      detail: { transaction, teamScore: this.sessionData.teams[transaction.teamId] }\n    }));\n\n    return {\n      success: true,\n      transaction,\n      teamScore: this.sessionData.teams[transaction.teamId]\n    };\n  }\n\n  /**\n   * Update team score from transaction\n   * @private\n   */\n  _updateTeamScore(transaction) {\n    const teamId = transaction.teamId;\n\n    if (!this.sessionData.teams[teamId]) {\n      this.sessionData.teams[teamId] = {\n        teamId,\n        score: 0,\n        baseScore: 0,\n        bonusPoints: 0,\n        tokensScanned: 0,\n        completedGroups: [],\n        lastScanTime: null\n      };\n    }\n\n    const team = this.sessionData.teams[teamId];\n\n    // Only score blackmarket mode\n    if (transaction.mode === 'blackmarket' && transaction.points) {\n      team.baseScore += transaction.points;\n      team.score = team.baseScore + team.bonusPoints;\n    }\n\n    team.tokensScanned++;\n    team.lastScanTime = transaction.timestamp;\n\n    // Check group completion\n    if (transaction.mode === 'blackmarket' && transaction.group) {\n      this._checkGroupCompletion(teamId, transaction.group);\n    }\n  }\n\n  /**\n   * Check and award group completion bonus\n   * @private\n   */\n  _checkGroupCompletion(teamId, groupName) {\n    const groupInfo = parseGroupInfo(groupName);\n    if (groupInfo.multiplier <= 1) return;\n\n    const team = this.sessionData.teams[teamId];\n    if (team.completedGroups.includes(groupInfo.name)) return;\n\n    // Get all team transactions for this group\n    const teamTxs = this.sessionData.transactions.filter(tx =>\n      tx.teamId === teamId && tx.mode === 'blackmarket'\n    );\n\n    const groupTxs = teamTxs.filter(tx => {\n      const txGroupInfo = parseGroupInfo(tx.group);\n      return txGroupInfo.name === groupInfo.name;\n    });\n\n    // Check if all group tokens collected (requires tokenManager)\n    if (!this.tokenManager) return;\n\n    const allTokens = this.tokenManager.getAllTokens();\n    const groupTokens = allTokens.filter(token => {\n      if (!token.SF_Group) return false;\n      const tokenGroupInfo = parseGroupInfo(token.SF_Group);\n      return tokenGroupInfo.name === groupInfo.name;\n    });\n\n    const scannedIds = groupTxs.map(tx => tx.tokenId);\n    const allGroupIds = groupTokens.map(t => t.SF_RFID);\n    const allScanned = allGroupIds.every(id => scannedIds.includes(id));\n\n    if (allScanned && groupTokens.length > 0) {\n      const groupBaseScore = groupTxs.reduce((sum, tx) => sum + (tx.points || 0), 0);\n      const bonus = (groupInfo.multiplier - 1) * groupBaseScore;\n\n      team.bonusPoints += bonus;\n      team.score = team.baseScore + team.bonusPoints;\n      team.completedGroups.push(groupInfo.name);\n\n      this.debug?.log(`Group completed: ${groupInfo.name}, bonus: ${bonus}`);\n    }\n  }\n\n  /**\n   * Remove transaction and recalculate team scores\n   * @param {string} transactionId - Transaction ID\n   * @returns {Promise<TransactionResult>}\n   */\n  async removeTransaction(transactionId) {\n    const index = this.sessionData.transactions.findIndex(tx => tx.id === transactionId);\n\n    if (index === -1) {\n      return {\n        success: false,\n        error: `Transaction not found: ${transactionId}`\n      };\n    }\n\n    const removedTx = this.sessionData.transactions.splice(index, 1)[0];\n    const tokenId = removedTx.tokenId || removedTx.rfid;\n    const teamId = removedTx.teamId;\n\n    // Allow re-scanning if no other transactions have this token\n    const tokenStillExists = this.sessionData.transactions.some(\n      tx => (tx.tokenId || tx.rfid) === tokenId\n    );\n    if (!tokenStillExists && tokenId) {\n      this.scannedTokens.delete(tokenId);\n    }\n\n    // Recalculate team scores from scratch\n    if (teamId && this.sessionData.teams[teamId]) {\n      this._recalculateTeamScores(teamId);\n    }\n\n    this._saveSession();\n\n    return {\n      success: true,\n      transaction: removedTx\n    };\n  }\n\n  /**\n   * Recalculate team scores from remaining transactions\n   * @private\n   */\n  _recalculateTeamScores(teamId) {\n    const team = this.sessionData.teams[teamId];\n\n    // Reset\n    team.baseScore = 0;\n    team.bonusPoints = 0;\n    team.score = 0;\n    team.tokensScanned = 0;\n    team.completedGroups = [];\n\n    // Replay transactions\n    this.sessionData.transactions\n      .filter(tx => tx.teamId === teamId)\n      .forEach(tx => this._updateTeamScore(tx));\n  }\n\n  /**\n   * Adjust team score (admin operation)\n   * @param {string} teamId - Team identifier\n   * @param {number} delta - Score adjustment\n   * @param {string} reason - Reason for adjustment\n   * @returns {Promise<TransactionResult>}\n   */\n  async adjustTeamScore(teamId, delta, reason = 'Manual adjustment') {\n    if (!this.sessionData.teams[teamId]) {\n      return {\n        success: false,\n        error: `Team not found: ${teamId}`\n      };\n    }\n\n    const team = this.sessionData.teams[teamId];\n\n    if (!team.adminAdjustments) {\n      team.adminAdjustments = [];\n    }\n\n    const adjustment = {\n      delta: parseInt(delta),\n      reason,\n      timestamp: new Date().toISOString()\n    };\n\n    team.adminAdjustments.push(adjustment);\n    team.score += adjustment.delta;\n\n    this._saveSession();\n\n    return {\n      success: true,\n      teamScore: { ...team }\n    };\n  }\n\n  /**\n   * Get unified game activity\n   * Matches DataManager.getGameActivity() API for parity\n   *\n   * Note: LocalStorage doesn't have player scans (no backend to receive them)\n   * but we maintain the same structure for API compatibility.\n   *\n   * @returns {Object} { tokens: Array, stats: Object }\n   */\n  getGameActivity() {\n    return buildGameActivity({\n      transactions: this.sessionData.transactions,\n      playerScans: this.playerScans,\n      tokenManager: this.tokenManager\n    });\n  }\n\n  /**\n   * Dispose of resources\n   * LocalStorage has no resources requiring cleanup\n   */\n  dispose() {\n    // No-op for LocalStorage - localStorage persists automatically\n  }\n}\n","/**\n * NetworkedStorage Strategy - WebSocket backend communication\n * Implements IStorageStrategy for networked mode operation\n *\n * @module core/storage/NetworkedStorage\n */\n\nimport { IStorageStrategy } from './IStorageStrategy.js';\nimport { calculateTokenValue } from '../scoring.js';\nimport { buildGameActivity } from '../gameActivityBuilder.js';\n\nexport class NetworkedStorage extends IStorageStrategy {\n  /**\n   * Create NetworkedStorage instance\n   * @param {Object} options - Dependencies\n   * @param {Object} options.socket - Socket.io client\n   * @param {Object} options.tokenManager - TokenManager instance\n   * @param {Object} [options.debug] - Debug instance\n   */\n  constructor({ socket, tokenManager, debug } = {}) {\n    super();\n\n    this.socket = socket;\n    this.tokenManager = tokenManager;\n    this.debug = debug;\n\n    // Local cache (synced from backend)\n    this.transactions = [];\n    this.backendScores = new Map();\n    this.scannedTokens = new Set();\n    this.playerScans = [];\n    this.currentSessionId = null;\n  }\n\n  /**\n   * Check if storage is ready/connected\n   * @returns {boolean}\n   */\n  isReady() {\n    return this.socket?.connected === true;\n  }\n\n  /**\n   * Initialize storage\n   * Event listeners are handled by NetworkedSession which owns the socket.\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    // No-op: NetworkedSession handles socket event wiring\n  }\n\n  /**\n   * Add transaction - delegates to backend\n   * @param {Transaction} transaction - Transaction data\n   * @returns {Promise<TransactionResult>}\n   */\n  async addTransaction(transaction) {\n    // Validate required fields\n    if (!transaction || !transaction.teamId) {\n      return {\n        success: false,\n        error: 'Transaction must have teamId'\n      };\n    }\n\n    // Check socket connection\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot add transaction: socket not connected', true);\n      return {\n        success: false,\n        error: 'Socket not connected'\n      };\n    }\n\n    this.debug?.log(`[NetworkedStorage] Submitting transaction: ${transaction.tokenId} for team ${transaction.teamId}`);\n\n    this.socket.emit('transaction:submit', {\n      tokenId: transaction.tokenId,\n      teamId: transaction.teamId,\n      deviceId: transaction.deviceId,\n      deviceType: 'gm',\n      mode: transaction.mode,\n      timestamp: transaction.timestamp || new Date().toISOString()\n    });\n\n    // Mark locally for duplicate prevention\n    if (transaction.tokenId) {\n      this.scannedTokens.add(transaction.tokenId);\n    }\n\n    // Return pending - actual result comes via WebSocket broadcast\n    return {\n      success: true,\n      pending: true\n    };\n  }\n\n  /**\n   * Remove transaction - delegates to backend\n   * @param {string} transactionId - Transaction ID\n   * @returns {Promise<TransactionResult>}\n   */\n  async removeTransaction(transactionId) {\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot remove transaction: socket not connected', true);\n      return { success: false, error: 'Socket not connected' };\n    }\n\n    this.debug?.log(`[NetworkedStorage] Removing transaction: ${transactionId}`);\n\n    this.socket.emit('gm:command', {\n      event: 'gm:command',\n      data: {\n        action: 'transaction:delete',\n        payload: { transactionId }\n      },\n      timestamp: new Date().toISOString()\n    });\n\n    return { success: true, pending: true };\n  }\n\n  /**\n   * Get all transactions from local cache\n   * @returns {Array}\n   */\n  getTransactions() {\n    return this.transactions;\n  }\n\n  /**\n   * Get team scores from backend cache\n   * @returns {Array}\n   */\n  getTeamScores() {\n    if (this.backendScores.size === 0) {\n      return [];\n    }\n\n    return Array.from(this.backendScores.entries())\n      .map(([teamId, score]) => ({\n        teamId,\n        score: score.currentScore,\n        baseScore: score.baseScore,\n        bonusScore: score.bonusPoints,\n        tokenCount: score.tokensScanned,\n        completedGroups: score.completedGroups?.length || 0,\n        isFromBackend: true\n      }))\n      .sort((a, b) => b.score - a.score);\n  }\n\n  /**\n   * Adjust team score - delegates to backend\n   * @param {string} teamId - Team identifier\n   * @param {number} delta - Score adjustment\n   * @param {string} reason - Reason for adjustment\n   * @returns {Promise<TransactionResult>}\n   */\n  async adjustTeamScore(teamId, delta, reason) {\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot adjust score: socket not connected', true);\n      return { success: false, error: 'Socket not connected' };\n    }\n\n    this.debug?.log(`[NetworkedStorage] Adjusting score for team ${teamId}: ${delta > 0 ? '+' : ''}${delta} (${reason})`);\n\n    this.socket.emit('gm:command', {\n      event: 'gm:command',\n      data: {\n        action: 'score:adjust',\n        payload: { teamId, delta, reason }\n      },\n      timestamp: new Date().toISOString()\n    });\n\n    return { success: true, pending: true };\n  }\n\n  /**\n   * Get unified game activity\n   * Matches LocalStorage.getGameActivity() API for parity\n   * @returns {Object} { tokens: Array, stats: Object }\n   */\n  getGameActivity() {\n    return buildGameActivity({\n      transactions: this.transactions,\n      playerScans: this.playerScans,\n      tokenManager: this.tokenManager,\n      options: {\n        transactionFilter: (tx) => !tx.status || tx.status === 'accepted',\n        pointsFallback: (tx) => calculateTokenValue({\n          valueRating: tx.valueRating,\n          memoryType: tx.memoryType\n        })\n      }\n    });\n  }\n\n  /**\n   * Create a new session - delegates to backend\n   * @param {string} name - Session name\n   * @param {Array} teams - Initial teams\n   * @returns {Promise<Object>}\n   */\n  async createSession(name, teams) {\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot create session: socket not connected', true);\n      return { success: false, error: 'Socket not connected' };\n    }\n\n    this.debug?.log(`[NetworkedStorage] Creating session: ${name}`);\n\n    this.socket.emit('gm:command', {\n      event: 'gm:command',\n      data: {\n        action: 'session:create',\n        payload: { name, teams }\n      },\n      timestamp: new Date().toISOString()\n    });\n\n    return { pending: true };\n  }\n\n  /**\n   * End the current session - delegates to backend\n   * @returns {Promise<void>}\n   */\n  async endSession() {\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot end session: socket not connected', true);\n      return;\n    }\n\n    this.debug?.log('[NetworkedStorage] Ending session');\n\n    this.socket.emit('gm:command', {\n      event: 'gm:command',\n      data: { action: 'session:end', payload: {} },\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  /**\n   * Get current session info\n   * @returns {SessionInfo|null}\n   */\n  getCurrentSession() {\n    return this.currentSessionId ? {\n      sessionId: this.currentSessionId,\n      status: 'active'\n    } : null;\n  }\n\n  /**\n   * Pause the current session - delegates to backend\n   * @returns {Promise<Object>}\n   */\n  async pauseSession() {\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot pause session: socket not connected', true);\n      return { success: false, error: 'Socket not connected' };\n    }\n\n    this.debug?.log('[NetworkedStorage] Pausing session');\n\n    this.socket.emit('gm:command', {\n      event: 'gm:command',\n      data: { action: 'session:pause', payload: {} },\n      timestamp: new Date().toISOString()\n    });\n\n    return { success: true, pending: true };\n  }\n\n  /**\n   * Resume the current session - delegates to backend\n   * @returns {Promise<Object>}\n   */\n  async resumeSession() {\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot resume session: socket not connected', true);\n      return { success: false, error: 'Socket not connected' };\n    }\n\n    this.debug?.log('[NetworkedStorage] Resuming session');\n\n    this.socket.emit('gm:command', {\n      event: 'gm:command',\n      data: { action: 'session:resume', payload: {} },\n      timestamp: new Date().toISOString()\n    });\n\n    return { success: true, pending: true };\n  }\n\n  /**\n   * Reset all scores - delegates to backend\n   * @returns {Promise<Object>}\n   */\n  async resetScores() {\n    if (!this.isReady()) {\n      this.debug?.log('[NetworkedStorage] Cannot reset scores: socket not connected', true);\n      return { success: false, error: 'Socket not connected' };\n    }\n\n    this.debug?.log('[NetworkedStorage] Resetting all scores');\n\n    this.socket.emit('gm:command', {\n      event: 'gm:command',\n      data: { action: 'scores:reset', payload: {} },\n      timestamp: new Date().toISOString()\n    });\n\n    return { success: true, pending: true };\n  }\n\n  // ========================================\n  // Cache update methods for NetworkedSession\n  // ========================================\n\n  /**\n   * Set transactions from sync:full\n   * @param {Array} transactions\n   */\n  setTransactions(transactions) {\n    this.transactions = transactions;\n  }\n\n  /**\n   * Add transaction from broadcast (prevents duplicates)\n   * @param {Object} tx\n   */\n  addTransactionFromBroadcast(tx) {\n    const exists = this.transactions.some(t => t.id === tx.id);\n    if (!exists) {\n      this.transactions.push(tx);\n    }\n  }\n\n  /**\n   * Set backend scores for a team\n   * @param {string} teamId\n   * @param {Object} scoreData\n   */\n  setBackendScores(teamId, scoreData) {\n    this.backendScores.set(teamId, scoreData);\n  }\n\n  /**\n   * Reset all backend scores to zero (preserves team entries)\n   * @returns {Array<string>} Team IDs that were reset\n   */\n  resetBackendScores() {\n    const teamIds = Array.from(this.backendScores.keys());\n    for (const teamId of teamIds) {\n      const scoreData = this.backendScores.get(teamId);\n      this.backendScores.set(teamId, {\n        ...scoreData,\n        currentScore: 0,\n        baseScore: 0,\n        bonusPoints: 0,\n        tokensScanned: 0,\n        completedGroups: [],\n        adminAdjustments: []\n      });\n    }\n    return teamIds;\n  }\n\n  /**\n   * Clear all backend scores (removes all entries)\n   */\n  clearBackendScores() {\n    this.backendScores.clear();\n  }\n\n  /**\n   * Set scanned tokens from sync\n   * @param {Array} tokens\n   */\n  setScannedTokens(tokens) {\n    this.scannedTokens = new Set(tokens);\n  }\n\n  /**\n   * Set player scans from sync:full\n   * @param {Array} scans\n   */\n  setPlayerScans(scans) {\n    this.playerScans = scans;\n  }\n\n  /**\n   * Add player scan from broadcast (prevents duplicates)\n   * @param {Object} scan\n   */\n  addPlayerScan(scan) {\n    const exists = this.playerScans.some(s => s.id === scan.id);\n    if (!exists) {\n      this.playerScans.push(scan);\n    }\n  }\n\n  /**\n   * Set current session ID\n   * @param {string} sessionId\n   */\n  setSessionId(sessionId) {\n    this.currentSessionId = sessionId;\n  }\n\n  /**\n   * Dispose of resources\n   */\n  dispose() {\n    // NetworkedStorage doesn't own the socket, just references it\n    // Cleanup is handled by NetworkedSession\n  }\n}\n","/**\n * UnifiedDataManager - Single entry point for data operations\n * Delegates to LocalStorage or NetworkedStorage based on session mode\n *\n * @module core/unifiedDataManager\n */\n\nimport { LocalStorage } from './storage/LocalStorage.js';\nimport { NetworkedStorage } from './storage/NetworkedStorage.js';\nimport {\n  SCORING_CONFIG,\n  calculateTokenValue as calcTokenValue,\n  parseGroupInfo as parseGroup,\n  normalizeGroupName as sharedNormalizeGroupName\n} from './scoring.js';\n\nexport class UnifiedDataManager extends EventTarget {\n  /**\n   * Create UnifiedDataManager instance\n   * @param {Object} options - Dependencies\n   * @param {Object} options.tokenManager - TokenManager instance\n   * @param {Object} options.sessionModeManager - SessionModeManager instance\n   * @param {Object} [options.debug] - Debug instance\n   */\n  constructor({ tokenManager, sessionModeManager, debug } = {}) {\n    super();\n\n    this.tokenManager = tokenManager;\n    this.sessionModeManager = sessionModeManager;\n    this.debug = debug;\n\n    // Strategy instances (created on mode selection)\n    this._localStrategy = null;\n    this._networkedStrategy = null;\n    this._activeStrategy = null;\n\n    // Store event listener references for cleanup\n    this._strategyListeners = new Map();\n\n    // Expose scannedTokens for backward compatibility\n    // NOTE: This is a shared reference to the strategy's Set\n    this.scannedTokens = new Set();\n\n    // Expose SCORING_CONFIG for UIManager.renderTokenCard()\n    // This follows the pattern from DataManager and LocalStorage\n    this.SCORING_CONFIG = SCORING_CONFIG;\n\n    // Session tracking for boundary detection\n    this.currentSessionId = null;\n\n    // Ephemeral state (video, cues, etc.)\n    this.videoState = {\n      nowPlaying: null,\n      isPlaying: false,\n      progress: 0,\n      duration: 0\n    };\n\n    // Phase 2: Cue State\n    this.cueState = {\n      cues: new Map(),        // Static definitions: id -> { name, type, ... }\n      activeCues: new Map(),  // Running cues: Map<cueId, { state, progress, duration }>\n      disabledCues: new Set() // Manually disabled: Set<cueId>\n    };\n\n    // Phase 3: Environment State\n    this.environmentState = {\n      lighting: {\n        connected: false,\n        activeScene: null,\n        scenes: []\n      },\n      audio: {\n        routes: {}, // stream -> sink\n        ducking: {}, // stream -> { ducked, volume }\n        availableSinks: [] // list of sink objects\n      },\n      bluetooth: {\n        scanning: false,\n        foundedDevices: [], // Discovered during scan\n        pairedDevices: [],\n        connectedDevices: []\n      }\n    };\n\n    // Phase 3: Session State (Reactive)\n    this.sessionState = {\n      id: null,\n      name: null,\n      status: 'disconnected',\n      teams: [],\n      metadata: {}\n    };\n\n    // Bind methods\n    // this.handleUpdate = this.handleUpdate.bind(this); // Removed: unused\n    // this.handleSync = this.handleSync.bind(this); // Removed: unused\n  }\n\n  /**\n   * Initialize standalone mode (LocalStorage strategy)\n   * @returns {Promise<void>}\n   */\n  async initializeStandaloneMode() {\n    this._log('Initializing standalone mode');\n\n    this._localStrategy = new LocalStorage({\n      tokenManager: this.tokenManager,\n      debug: this.debug\n    });\n\n    await this._localStrategy.initialize();\n    this._activeStrategy = this._localStrategy;\n\n    // Sync scannedTokens from strategy\n    this._syncScannedTokens();\n\n    // Wire up event forwarding\n    this._wireStrategyEvents(this._localStrategy);\n\n    this._log('Standalone mode initialized');\n  }\n\n  /**\n   * Initialize networked mode (NetworkedStorage strategy)\n   * @param {Object} socket - Socket.io client instance (or object with .socket property)\n   * @returns {Promise<void>}\n   */\n  async initializeNetworkedMode(socket) {\n    this._log('Initializing networked mode');\n\n    // Handle both direct socket and networkedSession-like objects\n    const actualSocket = socket?.socket || socket;\n\n    this._networkedStrategy = new NetworkedStorage({\n      tokenManager: this.tokenManager,\n      socket: actualSocket,\n      debug: this.debug\n    });\n\n    await this._networkedStrategy.initialize();\n    this._activeStrategy = this._networkedStrategy;\n\n    // Sync scannedTokens from strategy\n    this._syncScannedTokens();\n\n    // Wire up event forwarding\n    this._wireStrategyEvents(this._networkedStrategy);\n\n    this._log('Networked mode initialized');\n  }\n\n  /**\n   * Check if manager is ready\n   * @returns {boolean}\n   */\n  isReady() {\n    return this._activeStrategy?.isReady() ?? false;\n  }\n\n  /**\n   * Get active strategy type\n   * @returns {string|null} 'local' | 'networked' | null\n   */\n  getActiveStrategyType() {\n    if (!this._activeStrategy) return null;\n    if (this._activeStrategy === this._localStrategy) return 'local';\n    if (this._activeStrategy === this._networkedStrategy) return 'networked';\n    return null;\n  }\n\n  /**\n   * Sync scannedTokens from active strategy\n   * NOTE: Creates a shared reference for backward compatibility.\n   * The scannedTokens Set is owned by the strategy - if strategy\n   * replaces its Set, call this method again to re-sync.\n   * @private\n   */\n  _syncScannedTokens() {\n    if (this._activeStrategy?.scannedTokens) {\n      this.scannedTokens = this._activeStrategy.scannedTokens;\n    }\n  }\n\n  /**\n   * Wire event forwarding from strategy to manager\n   * Stores listener references for cleanup via _unwireStrategyEvents\n   * @private\n   * @param {IStorageStrategy} strategy\n   */\n  _wireStrategyEvents(strategy) {\n    const events = [\n      'transaction:added',\n      'transaction:deleted',\n      'team-score:updated',\n      'scores:cleared',\n      'data:cleared',\n      'game-state:updated',\n      'player-scan:added',\n      'session:updated'\n    ];\n\n    const listeners = [];\n    events.forEach(eventName => {\n      const handler = (event) => {\n        this.dispatchEvent(new CustomEvent(eventName, { detail: event.detail }));\n      };\n      strategy.addEventListener(eventName, handler);\n      listeners.push({ eventName, handler });\n    });\n\n    this._strategyListeners.set(strategy, listeners);\n  }\n\n  /**\n   * Remove event listeners from strategy\n   * @private\n   * @param {IStorageStrategy} strategy\n   */\n  _unwireStrategyEvents(strategy) {\n    const listeners = this._strategyListeners.get(strategy);\n    if (listeners) {\n      listeners.forEach(({ eventName, handler }) => {\n        strategy.removeEventListener(eventName, handler);\n      });\n      this._strategyListeners.delete(strategy);\n    }\n  }\n\n  /**\n   * Log message if debug available\n   * @private\n   */\n  _log(message) {\n    if (this.debug?.log) {\n      this.debug.log(`[UnifiedDataManager] ${message}`);\n    }\n  }\n\n  // ============================================================================\n  // DELEGATED OPERATIONS - Core IStorageStrategy methods\n  // ============================================================================\n\n  /**\n   * Add a transaction\n   * @param {Object} transaction - Transaction data\n   * @returns {Promise<Object>} Transaction result\n   */\n  async addTransaction(transaction) {\n    this._requireActiveStrategy();\n    return this._activeStrategy.addTransaction(transaction);\n  }\n\n  /**\n   * Remove a transaction\n   * @param {string} transactionId - Transaction ID\n   * @returns {Promise<Object>} Result\n   */\n  async removeTransaction(transactionId) {\n    this._requireActiveStrategy();\n    return this._activeStrategy.removeTransaction(transactionId);\n  }\n\n  /**\n   * Add transaction from broadcast (networked mode only)\n   * Used when receiving transaction:new events from backend\n   * @param {Object} tx - Transaction from broadcast\n   */\n  addTransactionFromBroadcast(tx) {\n    // Only NetworkedStorage has this method\n    if (typeof this._activeStrategy?.addTransactionFromBroadcast === 'function') {\n      this._activeStrategy.addTransactionFromBroadcast(tx);\n      // Emit event so UI can update\n      this.dispatchEvent(new CustomEvent('transaction:added', {\n        detail: { transaction: tx }\n      }));\n    }\n  }\n\n  /**\n   * Get all transactions\n   * @returns {Array} Transactions\n   */\n  getTransactions() {\n    this._requireActiveStrategy();\n    return this._activeStrategy.getTransactions();\n  }\n\n  /**\n   * Get team scores\n   * @returns {Array} Team scores sorted by score descending\n   */\n  getTeamScores() {\n    this._requireActiveStrategy();\n    return this._activeStrategy.getTeamScores();\n  }\n\n  /**\n   * Adjust team score\n   * @param {string} teamId - Team ID\n   * @param {number} delta - Score adjustment\n   * @param {string} reason - Reason for adjustment\n   * @returns {Promise<Object>} Result\n   */\n  async adjustTeamScore(teamId, delta, reason) {\n    this._requireActiveStrategy();\n    return this._activeStrategy.adjustTeamScore(teamId, delta, reason);\n  }\n\n  /**\n   * Get game activity\n   * @returns {Object} { tokens, stats }\n   */\n  getGameActivity() {\n    this._requireActiveStrategy();\n    return this._activeStrategy.getGameActivity();\n  }\n\n  /**\n   * Get current session info\n   * @returns {Object|null}\n   */\n  getCurrentSession() {\n    return this._activeStrategy?.getCurrentSession() ?? null;\n  }\n\n  /**\n   * Create a new session\n   * @param {string} name - Session name\n   * @param {Array} teams - Initial teams\n   * @returns {Promise<Object>}\n   */\n  async createSession(name, teams) {\n    this._requireActiveStrategy();\n    return this._activeStrategy.createSession(name, teams);\n  }\n\n  /**\n   * End current session\n   * @returns {Promise<void>}\n   */\n  async endSession() {\n    this._requireActiveStrategy();\n    return this._activeStrategy.endSession();\n  }\n\n  /**\n   * Pause the current session\n   * @returns {Promise<{success: boolean, error?: string}>}\n   */\n  async pauseSession() {\n    this._requireActiveStrategy();\n    return this._activeStrategy.pauseSession();\n  }\n\n  /**\n   * Resume a paused session\n   * @returns {Promise<{success: boolean, error?: string}>}\n   */\n  async resumeSession() {\n    this._requireActiveStrategy();\n    return this._activeStrategy.resumeSession();\n  }\n\n  /**\n   * Reset all team scores to zero\n   * @returns {Promise<{success: boolean}>}\n   */\n  async resetScores() {\n    this._requireActiveStrategy();\n    return this._activeStrategy.resetScores();\n  }\n\n  /**\n   * Dispose of resources - clean up event listeners and strategies\n   * Call when manager is no longer needed to prevent memory leaks\n   */\n  dispose() {\n    // Unwire event listeners from all strategies\n    if (this._localStrategy) {\n      this._unwireStrategyEvents(this._localStrategy);\n      this._localStrategy.dispose();\n    }\n    if (this._networkedStrategy) {\n      this._unwireStrategyEvents(this._networkedStrategy);\n      this._networkedStrategy.dispose();\n    }\n\n    // Clear references\n    this._activeStrategy = null;\n    this._localStrategy = null;\n    this._networkedStrategy = null;\n    this._strategyListeners.clear();\n    this.scannedTokens = new Set();\n\n    this._log('Disposed');\n  }\n\n  /**\n   * Ensure active strategy exists\n   * @private\n   */\n  _requireActiveStrategy() {\n    if (!this._activeStrategy) {\n      throw new Error('UnifiedDataManager: No active strategy. Call initializeStandaloneMode() or initializeNetworkedMode() first.');\n    }\n  }\n\n  // ============================================================================\n  // UTILITY METHODS - Backward compatibility with DataManager/StandaloneDataManager\n  // ============================================================================\n\n  /**\n   * Check if token has been scanned\n   * @param {string} tokenId\n   * @returns {boolean}\n   */\n  isTokenScanned(tokenId) {\n    return this.scannedTokens.has(tokenId);\n  }\n\n  /**\n   * Mark token as scanned\n   * @param {string} tokenId\n   */\n  markTokenAsScanned(tokenId) {\n    this.scannedTokens.add(tokenId);\n  }\n\n  /**\n   * Unmark token as scanned (for re-scanning after deletion)\n   * @param {string} tokenId\n   */\n  unmarkTokenAsScanned(tokenId) {\n    this.scannedTokens.delete(tokenId);\n  }\n\n  /**\n   * Calculate token value based on rating and type\n   * @param {Object} transaction - Transaction with valueRating and memoryType\n   * @returns {number}\n   */\n  calculateTokenValue(transaction) {\n    return calcTokenValue(transaction);\n  }\n\n  /**\n   * Get transactions for a specific team\n   * @param {string} teamId\n   * @returns {Array}\n   */\n  getTeamTransactions(teamId) {\n    const transactions = this.getTransactions();\n    return transactions.filter(tx => tx.teamId === teamId);\n  }\n\n  // ============================================================================\n  // ADVANCED METHODS - Group completion, session reset, etc.\n  // ============================================================================\n\n  /**\n   * Parse group info from group string\n   * @param {string} groupString - e.g., \"Server Logs (x5)\"\n   * @returns {Object} { name, multiplier }\n   */\n  parseGroupInfo(groupString) {\n    return parseGroup(groupString);\n  }\n\n  /**\n   * Normalize group name for comparison\n   * Delegates to shared scoring.js implementation for consistency\n   * @param {string} groupName\n   * @returns {string}\n   */\n  normalizeGroupName(groupName) {\n    return sharedNormalizeGroupName(groupName);\n  }\n\n  /**\n   * Reset for new session - clears scannedTokens and emits data:cleared\n   * @param {string|null} sessionId - New session ID (null to clear)\n   */\n  resetForNewSession(sessionId = null) {\n    this.currentSessionId = sessionId;\n    this.scannedTokens.clear();\n\n    if (this._localStrategy) {\n      this._localStrategy.scannedTokens?.clear();\n    }\n    if (this._networkedStrategy) {\n      this._networkedStrategy.scannedTokens?.clear();\n      this._networkedStrategy.transactions = [];\n      this._networkedStrategy.playerScans = [];\n      this._networkedStrategy.backendScores?.clear();\n      this._networkedStrategy.setSessionId?.(sessionId);\n    }\n\n    this._log(`Reset for new session: ${sessionId || 'none'}`);\n    this.dispatchEvent(new CustomEvent('data:cleared'));\n  }\n\n  /**\n   * Get team completed groups\n   * @param {string} teamId\n   * @returns {Array} Completed group names\n   */\n  getTeamCompletedGroups(teamId) {\n    // Delegate to strategy if available\n    if (this._activeStrategy?.getTeamCompletedGroups) {\n      return this._activeStrategy.getTeamCompletedGroups(teamId);\n    }\n    return [];\n  }\n\n  /**\n   * Get enhanced team transactions with grouping for team details display\n   * @param {string} teamId - Team ID\n   * @returns {Object} Grouped transaction data with completed/incomplete groups\n   */\n  getEnhancedTeamTransactions(teamId) {\n    const transactions = this.getTeamTransactions(teamId);\n    const groupInventory = this.tokenManager?.getGroupInventory() || {};\n    const completedGroups = this.getTeamCompletedGroups(teamId);\n    const completedGroupNames = new Set(completedGroups.map(g => g.normalizedName));\n\n    // Calculate bonus values\n    const groupBonusData = {};\n    completedGroups.forEach(group => {\n      groupBonusData[group.normalizedName] = {\n        displayName: group.name,\n        multiplier: group.multiplier,\n        tokens: [],\n        totalBaseValue: 0,\n        bonusValue: 0\n      };\n    });\n\n    // Organize transactions\n    const completedGroupTokens = {};\n    const incompleteGroupTokens = {};\n    const ungroupedTokens = [];\n    const unknownTokens = [];\n\n    transactions.forEach(t => {\n      if (t.isUnknown) {\n        unknownTokens.push(t);\n        return;\n      }\n\n      const groupInfo = this.parseGroupInfo(t.group);\n      const normalizedGroupName = this.normalizeGroupName(groupInfo.name);\n      const groupData = groupInventory[normalizedGroupName];\n\n      if (!groupData || groupData.tokens.size <= 1) {\n        ungroupedTokens.push(t);\n        return;\n      }\n\n      const tokenValue = this.calculateTokenValue(t);\n\n      if (completedGroupNames.has(normalizedGroupName)) {\n        // Completed group\n        if (!completedGroupTokens[normalizedGroupName]) {\n          completedGroupTokens[normalizedGroupName] = [];\n        }\n        completedGroupTokens[normalizedGroupName].push(t);\n\n        if (groupBonusData[normalizedGroupName]) {\n          groupBonusData[normalizedGroupName].tokens.push(t);\n          groupBonusData[normalizedGroupName].totalBaseValue += tokenValue;\n          groupBonusData[normalizedGroupName].bonusValue += tokenValue * (groupInfo.multiplier - 1);\n        }\n      } else {\n        // Incomplete group\n        if (!incompleteGroupTokens[normalizedGroupName]) {\n          incompleteGroupTokens[normalizedGroupName] = {\n            displayName: groupData.displayName,\n            multiplier: groupData.multiplier,\n            tokens: [],\n            totalTokens: groupData.tokens.size,\n            collectedTokens: 0\n          };\n        }\n        incompleteGroupTokens[normalizedGroupName].tokens.push(t);\n      }\n    });\n\n    // Calculate progress\n    Object.keys(incompleteGroupTokens).forEach(normalizedName => {\n      const group = incompleteGroupTokens[normalizedName];\n      group.collectedTokens = group.tokens.length;\n      group.progress = `${group.collectedTokens}/${group.totalTokens}`;\n      group.percentage = Math.round((group.collectedTokens / group.totalTokens) * 100);\n    });\n\n    // Convert to arrays and sort\n    const completedGroupsArray = Object.entries(completedGroupTokens).map(([normalizedName, tokens]) => ({\n      ...groupBonusData[normalizedName],\n      normalizedName,\n      tokens\n    })).sort((a, b) => b.bonusValue - a.bonusValue);\n\n    const incompleteGroupsArray = Object.values(incompleteGroupTokens)\n      .sort((a, b) => b.percentage - a.percentage);\n\n    return {\n      completedGroups: completedGroupsArray,\n      incompleteGroups: incompleteGroupsArray,\n      ungroupedTokens,\n      unknownTokens,\n      hasCompletedGroups: completedGroupsArray.length > 0,\n      hasIncompleteGroups: incompleteGroupsArray.length > 0,\n      hasUngroupedTokens: ungroupedTokens.length > 0,\n      hasUnknownTokens: unknownTokens.length > 0\n    };\n  }\n\n  /**\n   * Calculate team score with group completion bonuses\n   * @param {string} teamId - Team ID\n   * @returns {Object} Score breakdown\n   */\n  calculateTeamScoreWithBonuses(teamId) {\n    const transactions = this.getTeamTransactions(teamId).filter(t =>\n      t.mode === 'blackmarket' && !t.isUnknown\n    );\n\n    const completedGroups = this.getTeamCompletedGroups(teamId);\n    const completedGroupNames = new Set(\n      completedGroups.map(g => g.normalizedName)\n    );\n\n    let baseScore = 0;\n    let bonusScore = 0;\n    const groupBreakdown = {};\n\n    // Initialize breakdown for completed groups\n    completedGroups.forEach(group => {\n      groupBreakdown[group.name] = {\n        tokens: 0,\n        baseValue: 0,\n        bonusValue: 0,\n        multiplier: group.multiplier\n      };\n    });\n\n    // Calculate scores for each transaction\n    transactions.forEach(t => {\n      const tokenBaseValue = this.calculateTokenValue(t);\n      baseScore += tokenBaseValue;\n\n      // Check if this token's group is completed\n      const groupInfo = this.parseGroupInfo(t.group);\n      const normalizedGroupName = this.normalizeGroupName(groupInfo.name);\n\n      if (completedGroupNames.has(normalizedGroupName)) {\n        // Apply bonus (multiplier - 1) √ó base value\n        const bonusAmount = tokenBaseValue * (groupInfo.multiplier - 1);\n        bonusScore += bonusAmount;\n\n        // Track in breakdown\n        if (groupBreakdown[groupInfo.name]) {\n          groupBreakdown[groupInfo.name].tokens++;\n          groupBreakdown[groupInfo.name].baseValue += tokenBaseValue;\n          groupBreakdown[groupInfo.name].bonusValue += bonusAmount;\n        }\n      }\n    });\n\n    this._log(`Team ${teamId}: Base=$${baseScore}, Bonus=$${bonusScore}`);\n\n    return {\n      baseScore,\n      bonusScore,\n      totalScore: baseScore + bonusScore,\n      completedGroups: completedGroups.length,\n      groupBreakdown\n    };\n  }\n\n  /**\n   * Get session stats for the current team\n   * @returns {Object} { count, totalValue, totalScore }\n   */\n  getSessionStats() {\n    const currentTeamId = this.app?.currentTeamId;\n\n    if (!currentTeamId) {\n      return { count: 0, totalValue: 0, totalScore: 0 };\n    }\n\n    const teamTransactions = this.getTeamTransactions(currentTeamId);\n    const count = teamTransactions.length;\n    const knownTokens = teamTransactions.filter(t => !t.isUnknown);\n    const totalValue = knownTokens.reduce((sum, t) => sum + (t.valueRating || 0), 0);\n\n    // Get team score from teamScores\n    const scores = this.getTeamScores();\n    const teamScore = scores.find(s => s.teamId === currentTeamId);\n    const totalScore = teamScore?.score || 0;\n\n    return { count, totalValue, totalScore };\n  }\n\n  /**\n   * Get global stats across all teams\n   * @returns {Object} { total, teams, totalValue, avgValue, blackMarketScore }\n   */\n  getGlobalStats() {\n    const transactions = this.getTransactions();\n    const total = transactions.length;\n\n    // Count unique teams\n    const teamIds = [...new Set(transactions.map(t => t.teamId))];\n    const teams = teamIds.length;\n\n    // Calculate black market score from team scores\n    const teamScores = this.getTeamScores();\n    const blackMarketScore = teamScores.reduce((sum, ts) => sum + (ts.score || 0), 0);\n\n    // totalValue derived from blackMarketScore (display format)\n    const totalValue = Math.floor(blackMarketScore / 1000);\n    const known = transactions.filter(t => !t.isUnknown);\n    const avgValue = known.length > 0 ? (totalValue / known.length).toFixed(1) : 0;\n\n    return { total, teams, totalValue, avgValue, blackMarketScore };\n  }\n\n  // ============================================================================\n  // WEBSOCKET EVENT HANDLERS - Facade methods for NetworkedSession\n  // These delegate storage updates to the active strategy and emit UI events\n  // ============================================================================\n\n  /**\n   * Update team score from backend WebSocket event\n   * Called by NetworkedSession on 'score:updated' and 'sync:full'\n   * @param {Object} scoreData - Score data from backend\n   */\n  updateTeamScoreFromBackend(scoreData) {\n    if (!this._networkedStrategy) {\n      this._log('updateTeamScoreFromBackend called but no networked strategy active', true);\n      return;\n    }\n\n    // Delegate storage update to strategy\n    this._networkedStrategy.setBackendScores(scoreData.teamId, {\n      currentScore: scoreData.currentScore,\n      baseScore: scoreData.baseScore,\n      bonusPoints: scoreData.bonusPoints,\n      tokensScanned: scoreData.tokensScanned,\n      completedGroups: scoreData.completedGroups,\n      adminAdjustments: scoreData.adminAdjustments || [],\n      lastUpdate: scoreData.lastUpdate\n    });\n\n    // Emit event for UI updates\n    this.dispatchEvent(new CustomEvent('team-score:updated', {\n      detail: {\n        teamId: scoreData.teamId,\n        scoreData,\n        transactions: this.getTeamTransactions(scoreData.teamId)\n      }\n    }));\n\n    this._log(`Score updated from backend for team ${scoreData.teamId}: $${scoreData.currentScore}`);\n  }\n\n  /**\n   * Handle player scan event from WebSocket broadcast\n   * Called by NetworkedSession on 'player:scan'\n   * @param {Object} payload - Player scan event payload\n   */\n  handlePlayerScan(payload) {\n    if (!this._networkedStrategy) {\n      this._log('handlePlayerScan called but no networked strategy active', true);\n      return;\n    }\n\n    const playerScan = {\n      id: payload.scanId,\n      tokenId: payload.tokenId,\n      deviceId: payload.deviceId,\n      timestamp: payload.timestamp,\n      memoryType: payload.memoryType || null,\n      videoQueued: payload.videoQueued || false,\n      tokenData: payload.tokenData || null\n    };\n\n    // Delegate storage update to strategy\n    this._networkedStrategy.addPlayerScan(playerScan);\n\n    // Emit event for UI updates\n    this.dispatchEvent(new CustomEvent('player-scan:added', {\n      detail: { playerScan }\n    }));\n\n    this._log(`Player scan added: ${payload.tokenId} from ${payload.deviceId}`);\n  }\n\n  /**\n   * Set player scans from sync:full payload\n   * Called by NetworkedSession on reconnect to restore state\n   * @param {Array} playerScans - Array of player scan records from server\n   */\n  setPlayerScansFromServer(playerScans) {\n    if (!this._networkedStrategy) {\n      this._log('setPlayerScansFromServer called but no networked strategy active', true);\n      return;\n    }\n\n    if (!Array.isArray(playerScans)) {\n      this._log('setPlayerScansFromServer: invalid input (not array)', true);\n      return;\n    }\n\n    this._networkedStrategy.setPlayerScans(playerScans);\n    this._log(`Synced ${playerScans.length} player scans from server`);\n\n    // Emit event for UI updates\n    this.dispatchEvent(new CustomEvent('player-scans:synced', {\n      detail: { count: playerScans.length }\n    }));\n  }\n\n  /**\n   * Set scanned tokens from sync:full payload\n   * Called by NetworkedSession on reconnect to restore duplicate tracking\n   * @param {Array} tokens - Array of token IDs that have been scanned\n   */\n  setScannedTokensFromServer(tokens) {\n    if (!this._networkedStrategy) {\n      this._log('setScannedTokensFromServer called but no networked strategy active', true);\n      return;\n    }\n\n    if (!Array.isArray(tokens)) {\n      this._log('setScannedTokensFromServer: invalid input (not array)', true);\n      return;\n    }\n\n    this._networkedStrategy.setScannedTokens(tokens);\n    // Sync local reference\n    this._syncScannedTokens();\n    this._log(`Synced ${tokens.length} scanned tokens from server`);\n  }\n\n  // ============================================================================\n  // EPHEMERAL STATE MANAGEMENT - New State Store Pattern\n  // ============================================================================\n\n  /**\n   * Get current video state\n   * @returns {Object} { nowPlaying, isPlaying, progress, duration }\n   */\n  getVideoState() {\n    return { ...this.videoState };\n  }\n\n  /**\n   * Update video state and emit event\n   * @param {Object} payload - Partial video state\n   */\n  updateVideoState(payload) {\n    // Phase 1: Map backend payload to UI state\n    // Backend sends: { status: 'playing'|'paused'|'idle', tokenId, progress, duration }\n    // UI expects: { isPlaying: boolean, nowPlaying: string (filename/name), progress: number, duration: number }\n\n    const newState = { ...this.videoState, ...payload };\n\n    // 1. Map status to isPlaying\n    if (payload.status) {\n      newState.isPlaying = (payload.status === 'playing' || payload.status === 'loading');\n    }\n\n    // 2. Map tokenId to nowPlaying (filename)\n    if (payload.tokenId) {\n      // TokenManager uses findToken which returns { token, matchedId }\n      const result = this.tokenManager?.findToken(payload.tokenId);\n      const token = result?.token;\n\n      if (token) {\n        newState.nowPlaying = token.video || token.name || 'Unknown Video';\n      } else {\n        newState.nowPlaying = `Token: ${payload.tokenId}`;\n      }\n    } else if (payload.status === 'idle') {\n      newState.nowPlaying = null; // Clear title on idle\n    }\n\n    this.videoState = newState;\n\n    this.dispatchEvent(new CustomEvent('video-state:updated', {\n      detail: this.getVideoState()\n    }));\n  }\n\n  /**\n   * Reset all backend scores to zero\n   * Called by NetworkedSession on 'scores:reset'\n   * Preserves team entries so the scoreboard shows teams with $0\n   * (sync:full follows immediately to confirm state)\n   */\n  clearBackendScores() {\n    if (!this._networkedStrategy) {\n      this._log('clearBackendScores called but no networked strategy active', true);\n      return;\n    }\n\n    const resetTeamIds = this._networkedStrategy.resetBackendScores();\n    this._log(`Backend scores reset to zero for ${resetTeamIds.length} teams`);\n\n    // Emit team-score:updated for each team so the scoreboard re-renders with $0\n    for (const teamId of resetTeamIds) {\n      this.dispatchEvent(new CustomEvent('team-score:updated', {\n        detail: {\n          teamId,\n          scoreData: { teamId, currentScore: 0 },\n          transactions: this.getTeamTransactions(teamId)\n        }\n      }));\n    }\n  }\n\n  // ============================================================================\n  // PHASE 2: CUE STATE MANAGEMENT\n  // ============================================================================\n\n  /**\n   * Get current cue state\n   * @returns {Object} { cues: Map, activeCues: Set, disabledCues: Set }\n   */\n  getCueState() {\n    return {\n      cues: this.cueState.cues,\n      activeCues: this.cueState.activeCues,\n      disabledCues: this.cueState.disabledCues\n    };\n  }\n\n  /**\n   * Load static cue definitions\n   * @param {Array} cues - Array of cue objects\n   */\n  loadCues(cues) {\n    this.cueState.cues.clear();\n    if (Array.isArray(cues)) {\n      cues.forEach(cue => {\n        this.cueState.cues.set(cue.id, cue);\n      });\n    }\n    this._log(`Loaded ${this.cueState.cues.size} cue definitions`);\n  }\n\n  /**\n   * Update cue status (started, completed, paused, etc.)\n   * @param {Object} payload - { cueId, state, progress, duration }\n   */\n  updateCueStatus(payload) {\n    const { cueId, state } = payload;\n\n    // Update active map based on state\n    if (state === 'running' || state === 'paused') {\n      this.cueState.activeCues.set(cueId, payload);\n    } else if (state === 'completed' || state === 'stopped' || state === 'idle' || state === 'error') {\n      this.cueState.activeCues.delete(cueId);\n    }\n\n    this._dispatchCueUpdate();\n    this._log(`Cue status updated: ${cueId} -> ${state}`);\n  }\n\n  /**\n   * Update cue configuration (enable/disable)\n   * @param {Object} payload - { cueId, enabled }\n   */\n  updateCueConfig(payload) {\n    const { cueId, enabled } = payload;\n\n    if (enabled) {\n      this.cueState.disabledCues.delete(cueId);\n    } else {\n      this.cueState.disabledCues.add(cueId);\n    }\n\n    this._dispatchCueUpdate();\n    this._log(`Cue config updated: ${cueId} -> enabled=${enabled}`);\n  }\n\n  /**\n   * Handle cue conflict event\n   * @param {Object} payload - { cueId, conflictType, details }\n   */\n  handleCueConflict(payload) {\n    this.dispatchEvent(new CustomEvent('cue:conflict', {\n      detail: payload\n    }));\n    this._log(`Cue conflict reported: ${payload.cueId} (${payload.conflictType})`);\n  }\n\n  /**\n   * Helper to dispatch cue state update\n   * @private\n   */\n  _dispatchCueUpdate() {\n    this.dispatchEvent(new CustomEvent('cue-state:updated', {\n      detail: this.getCueState()\n    }));\n  }\n\n  // ============================================================================\n  // PHASE 3: ENVIRONMENT & SESSION STATE MANAGEMENT\n  // ============================================================================\n\n  /**\n   * Update Lighting State\n   * @param {Object} payload - { connected, sceneId, sceneName, scenes }\n   */\n  updateLightingState(payload) {\n    const { lighting } = this.environmentState;\n    let changed = false;\n\n    if (payload.connected !== undefined && lighting.connected !== payload.connected) {\n      lighting.connected = payload.connected;\n      changed = true;\n    }\n\n    if (payload.sceneId) {\n      lighting.activeScene = { id: payload.sceneId, name: payload.sceneName || payload.sceneId };\n      changed = true;\n    }\n\n    if (Array.isArray(payload.scenes)) {\n      lighting.scenes = payload.scenes;\n      changed = true;\n    }\n\n    if (changed) {\n      this.dispatchEvent(new CustomEvent('lighting-state:updated', {\n        detail: { lighting: { ...lighting } }\n      }));\n    }\n  }\n\n  /**\n   * Update Audio Routing State\n   * @param {Object} payload - { stream, sink }\n   */\n  updateAudioState(payload) {\n    let changed = false;\n\n    if (payload.availableSinks) {\n      this.environmentState.audio.availableSinks = payload.availableSinks;\n      changed = true;\n    }\n\n    if (payload.routes) {\n      this.environmentState.audio.routes = { ...payload.routes };\n      changed = true;\n    }\n\n    if (payload.stream && payload.sink) {\n      this.environmentState.audio.routes[payload.stream] = payload.sink;\n      changed = true;\n    }\n\n    if (changed) {\n      this.dispatchEvent(new CustomEvent('audio-state:updated', {\n        detail: { audio: { ...this.environmentState.audio } }\n      }));\n    }\n  }\n\n  /**\n   * Update Audio Ducking Status\n   * @param {Object} payload - { stream, ducked, volume }\n   */\n  updateAudioDucking(payload) {\n    if (payload.stream) {\n      this.environmentState.audio.ducking[payload.stream] = {\n        ducked: payload.ducked,\n        volume: payload.volume\n      };\n      this.dispatchEvent(new CustomEvent('audio-state:updated', {\n        detail: { audio: { ...this.environmentState.audio } }\n      }));\n    }\n  }\n\n  /**\n   * Update Bluetooth Scanning Status\n   * @param {Object} payload - { scanning }\n   */\n  updateBluetoothScan(payload) {\n    if (payload.scanning !== undefined) {\n      this.environmentState.bluetooth.scanning = payload.scanning;\n      // Clear founded devices on scan start? Maybe prefer manual clear.\n      // For now, just update status.\n      this.dispatchEvent(new CustomEvent('bluetooth-state:updated', {\n        detail: { bluetooth: { ...this.environmentState.bluetooth } }\n      }));\n    }\n  }\n\n  /**\n   * Update Bluetooth Device List\n   * @param {Object} payload - { type: 'discovered'|'connected'|'paired'|..., device }\n   */\n  updateBluetoothDevice(payload) {\n    const { type, device } = payload;\n    const btState = this.environmentState.bluetooth;\n\n    if (!device || !device.address) return;\n\n    if (type === 'discovered') {\n      // Add or update in foundedDevices\n      const idx = btState.foundedDevices.findIndex(d => d.address === device.address);\n      if (idx >= 0) {\n        btState.foundedDevices[idx] = device;\n      } else {\n        btState.foundedDevices.push(device);\n      }\n    } else if (type === 'connected') {\n      // Add to connectedDevices\n      const idx = btState.connectedDevices.findIndex(d => d.address === device.address);\n      if (idx >= 0) {\n        btState.connectedDevices[idx] = device;\n      } else {\n        btState.connectedDevices.push(device);\n      }\n    } else if (type === 'disconnected') {\n      // Remove from connectedDevices\n      btState.connectedDevices = btState.connectedDevices.filter(d => d.address !== device.address);\n    } else if (type === 'paired') {\n      // Add to pairedDevices\n      const idx = btState.pairedDevices.findIndex(d => d.address === device.address);\n      if (idx >= 0) {\n        btState.pairedDevices[idx] = device;\n      } else {\n        btState.pairedDevices.push(device);\n      }\n    } else if (type === 'unpaired') {\n      // Remove from pairedDevices AND connectedDevices\n      btState.pairedDevices = btState.pairedDevices.filter(d => d.address !== device.address);\n      btState.connectedDevices = btState.connectedDevices.filter(d => d.address !== device.address);\n    }\n\n    this.dispatchEvent(new CustomEvent('bluetooth-state:updated', {\n      detail: { bluetooth: { ...btState } }\n    }));\n  }\n\n  /**\n   * Update full Bluetooth state (from sync:full)\n   * @param {Object} payload - { scanning, pairedDevices, connectedDevices }\n   */\n  updateBluetoothState(payload) {\n    if (!payload) return;\n\n    const btState = this.environmentState.bluetooth;\n    let changed = false;\n\n    if (payload.scanning !== undefined) {\n      btState.scanning = payload.scanning;\n      changed = true;\n    }\n\n    if (Array.isArray(payload.pairedDevices)) {\n      btState.pairedDevices = payload.pairedDevices; // Replace entire list\n      changed = true;\n    }\n\n    if (Array.isArray(payload.connectedDevices)) {\n      btState.connectedDevices = payload.connectedDevices; // Replace entire list\n      changed = true;\n    }\n\n    // Merge discovered devices if needed, or keep existing ephemeral ones\n    // Usually sync:full doesn't send discovered devices (unless we add it to defaults)\n\n    if (changed) {\n      this.dispatchEvent(new CustomEvent('bluetooth-state:updated', {\n        detail: { bluetooth: { ...btState } }\n      }));\n    }\n  }\n\n  /**\n   * Update Session State\n   * @param {Object|null} payload - Session object, or null to clear session\n   */\n  updateSessionState(payload) {\n    if (!payload) {\n      this.sessionState = {};\n      this.currentSessionId = null;\n      this.dispatchEvent(new CustomEvent('session-state:updated', {\n        detail: { session: this.sessionState }\n      }));\n      return;\n    }\n\n    this.sessionState = {\n      ...this.sessionState,\n      ...payload\n    };\n\n    // Also update tracking property for consistency\n    if (payload.id) {\n      this.currentSessionId = payload.id;\n    }\n\n    this.dispatchEvent(new CustomEvent('session-state:updated', {\n      detail: { session: this.sessionState }\n    }));\n  }\n}\n","/**\n * TeamRegistry - Unified Team Management\n * ES6 Module Export\n *\n * Provides a unified interface for team management across both networked\n * and standalone modes. This enables UI PARITY - identical team selection\n * experience regardless of mode.\n *\n * Architecture:\n * - Networked mode: populated from sync:full / session:update WebSocket events\n * - Standalone mode: populated from StandaloneDataManager.sessionData.teams\n *\n * Events:\n * - 'teams:updated' - Team list changed (add/remove/clear)\n * - 'team:added' - Single team added\n *\n * @module core/teamRegistry\n */\n\nclass TeamRegistry extends EventTarget {\n    constructor() {\n        super();\n\n        /**\n         * Map of team ID to team info\n         * @type {Map<string, {teamId: string, score: number, tokensScanned: number}>}\n         */\n        this.teams = new Map();\n\n        /**\n         * Current mode for context\n         * @type {'networked'|'standalone'|null}\n         */\n        this.mode = null;\n\n        /**\n         * SessionModeManager for mode detection\n         * @type {Object|null}\n         */\n        this.sessionModeManager = null;\n\n        /**\n         * OrchestratorClient for networked team creation\n         * @type {Object|null}\n         */\n        this.orchestratorClient = null;\n    }\n\n    /**\n     * Set the current mode\n     * @param {'networked'|'standalone'} mode\n     */\n    setMode(mode) {\n        this.mode = mode;\n    }\n\n    /**\n     * Get all teams as an array\n     * @returns {Array<{teamId: string, score: number, tokensScanned: number}>}\n     */\n    getTeams() {\n        return Array.from(this.teams.values());\n    }\n\n    /**\n     * Get a single team by ID\n     * @param {string} teamId\n     * @returns {Object|undefined}\n     */\n    getTeam(teamId) {\n        return this.teams.get(teamId);\n    }\n\n    /**\n     * Check if a team exists\n     * @param {string} teamId\n     * @returns {boolean}\n     */\n    hasTeam(teamId) {\n        return this.teams.has(teamId);\n    }\n\n    /**\n     * Add a team to the registry\n     * Does NOT send to backend - that's the caller's responsibility\n     * @param {string} teamId - Team identifier\n     * @param {Object} [teamInfo={}] - Optional team metadata\n     */\n    addTeam(teamId, teamInfo = {}) {\n        if (!teamId || typeof teamId !== 'string') {\n            console.warn('[TeamRegistry] Invalid teamId:', teamId);\n            return false;\n        }\n\n        const normalizedId = teamId.trim();\n        if (!normalizedId) {\n            console.warn('[TeamRegistry] Empty teamId after trim');\n            return false;\n        }\n\n        const existingTeam = this.teams.get(normalizedId);\n        if (existingTeam) {\n            // Update existing team info\n            this.teams.set(normalizedId, { ...existingTeam, ...teamInfo, teamId: normalizedId });\n        } else {\n            // Add new team\n            this.teams.set(normalizedId, {\n                teamId: normalizedId,\n                score: 0,\n                tokensScanned: 0,\n                ...teamInfo\n            });\n\n            // Emit team:added for new teams only\n            this.dispatchEvent(new CustomEvent('team:added', {\n                detail: { teamId: normalizedId, teamInfo: this.teams.get(normalizedId) }\n            }));\n        }\n\n        // Always emit teams:updated\n        this.dispatchEvent(new CustomEvent('teams:updated', {\n            detail: { teams: this.getTeams() }\n        }));\n\n        return true;\n    }\n\n    /**\n     * Remove a team from the registry\n     * @param {string} teamId\n     * @returns {boolean} True if team was removed\n     */\n    removeTeam(teamId) {\n        const removed = this.teams.delete(teamId);\n        if (removed) {\n            this.dispatchEvent(new CustomEvent('teams:updated', {\n                detail: { teams: this.getTeams() }\n            }));\n        }\n        return removed;\n    }\n\n    /**\n     * Clear all teams (e.g., on session end)\n     */\n    clear() {\n        this.teams.clear();\n        this.dispatchEvent(new CustomEvent('teams:updated', {\n            detail: { teams: [] }\n        }));\n    }\n\n    /**\n     * Populate from session data (networked mode)\n     * Called on sync:full or session:update\n     * @param {Object} sessionData - Session object from backend\n     */\n    populateFromSession(sessionData) {\n        if (!sessionData) return;\n\n        // Clear existing and repopulate\n        this.teams.clear();\n\n        // Extract teams from session scores\n        if (sessionData.scores && Array.isArray(sessionData.scores)) {\n            sessionData.scores.forEach(scoreData => {\n                this.teams.set(scoreData.teamId, {\n                    teamId: scoreData.teamId,\n                    score: scoreData.currentScore || scoreData.score || 0,\n                    tokensScanned: scoreData.tokensScanned || 0,\n                    baseScore: scoreData.baseScore || 0,\n                    bonusPoints: scoreData.bonusPoints || 0\n                });\n            });\n        }\n\n        // Also check for teams array (some events have this)\n        if (sessionData.teams && Array.isArray(sessionData.teams)) {\n            sessionData.teams.forEach(teamId => {\n                if (!this.teams.has(teamId)) {\n                    this.teams.set(teamId, {\n                        teamId,\n                        score: 0,\n                        tokensScanned: 0\n                    });\n                }\n            });\n        }\n\n        this.dispatchEvent(new CustomEvent('teams:updated', {\n            detail: { teams: this.getTeams() }\n        }));\n    }\n\n    /**\n     * Populate from standalone session data\n     * Called when StandaloneDataManager loads session\n     * @param {Object} standaloneSessionData - Session object from localStorage\n     */\n    populateFromStandaloneSession(standaloneSessionData) {\n        if (!standaloneSessionData?.teams) return;\n\n        this.teams.clear();\n\n        Object.entries(standaloneSessionData.teams).forEach(([teamId, teamData]) => {\n            this.teams.set(teamId, {\n                teamId,\n                score: teamData.score || 0,\n                tokensScanned: teamData.tokensScanned || 0,\n                baseScore: teamData.baseScore || 0,\n                bonusPoints: teamData.bonusPoints || 0\n            });\n        });\n\n        this.dispatchEvent(new CustomEvent('teams:updated', {\n            detail: { teams: this.getTeams() }\n        }));\n    }\n\n    /**\n     * Populate a select element with team options\n     * Used for dropdown UI\n     * @param {HTMLSelectElement} selectElement - Select element to populate\n     * @param {Object} [options={}] - Options\n     * @param {string} [options.placeholder='Select Team...'] - Placeholder text\n     * @param {string} [options.selectedTeamId] - Currently selected team ID\n     */\n    populateDropdown(selectElement, options = {}) {\n        if (!selectElement) return;\n\n        const { placeholder = 'Select Team...', selectedTeamId = null } = options;\n\n        // Clear existing options\n        selectElement.innerHTML = '';\n\n        // Add placeholder option\n        const placeholderOption = document.createElement('option');\n        placeholderOption.value = '';\n        placeholderOption.textContent = placeholder;\n        placeholderOption.disabled = true;\n        placeholderOption.selected = !selectedTeamId;\n        selectElement.appendChild(placeholderOption);\n\n        // Add team options\n        const teams = this.getTeams().sort((a, b) =>\n            a.teamId.localeCompare(b.teamId)\n        );\n\n        teams.forEach(team => {\n            const option = document.createElement('option');\n            option.value = team.teamId;\n            option.textContent = team.teamId;\n            if (team.teamId === selectedTeamId) {\n                option.selected = true;\n            }\n            selectElement.appendChild(option);\n        });\n    }\n\n    // ============================================================================\n    // UNIFIED API - Mode-agnostic team operations\n    // ============================================================================\n\n    /**\n     * Select/create a team - UNIFIED API\n     * Standalone: Adds to localStorage recent history\n     * Networked: Sends session:addTeam if new, then selects\n     * @param {string} teamName\n     * @returns {Promise<{success: boolean, error?: string}>}\n     */\n    async selectTeam(teamName) {\n        if (!teamName?.trim()) {\n            return { success: false, error: 'Team name required' };\n        }\n\n        const normalized = teamName.trim();\n\n        if (this.sessionModeManager?.isStandalone()) {\n            // Standalone: track in recent history\n            this._addToRecentTeams(normalized);\n            return { success: true };\n        } else {\n            // Networked: create on backend if new\n            if (!this.hasTeam(normalized)) {\n                const result = await this._createTeamOnBackend(normalized);\n                if (!result.success) return result;\n            }\n            return { success: true };\n        }\n    }\n\n    /**\n     * Get teams for display - UNIFIED API\n     * Standalone: Returns recent teams from localStorage\n     * Networked: Returns teams from session (internal Map)\n     * @returns {Array<string>} Team names\n     */\n    getTeamsForDisplay() {\n        if (this.sessionModeManager?.isStandalone()) {\n            return this._getRecentTeams();\n        } else {\n            return this.getTeams().map(t => t.teamId);\n        }\n    }\n\n    /**\n     * Get label for team list - UNIFIED API\n     * @returns {string} Label text\n     */\n    getTeamListLabel() {\n        return this.sessionModeManager?.isStandalone()\n            ? 'Recent Teams:'\n            : 'Session Teams:';\n    }\n\n    // ============================================================================\n    // PRIVATE: localStorage recent teams (standalone mode)\n    // ============================================================================\n\n    /**\n     * Get recent teams from localStorage\n     * @returns {Array<string>} Recent team names (most recent first)\n     * @private\n     */\n    _getRecentTeams() {\n        try {\n            return JSON.parse(localStorage.getItem('aln_recent_teams') || '[]');\n        } catch {\n            return [];\n        }\n    }\n\n    /**\n     * Add team to recent history in localStorage\n     * Keeps max 10 teams, dedupes, most-recent-first\n     * @param {string} teamName\n     * @private\n     */\n    _addToRecentTeams(teamName) {\n        const recent = this._getRecentTeams().filter(t => t !== teamName);\n        recent.unshift(teamName);\n        const limited = recent.slice(0, 10);\n        localStorage.setItem('aln_recent_teams', JSON.stringify(limited));\n    }\n\n    // ============================================================================\n    // PRIVATE: Backend team creation (networked mode)\n    // ============================================================================\n\n    /**\n     * Create team on backend via session:addTeam command\n     * @param {string} teamName\n     * @returns {Promise<{success: boolean, error?: string}>}\n     * @private\n     */\n    async _createTeamOnBackend(teamName) {\n        if (!this.orchestratorClient) {\n            return { success: false, error: 'Not connected' };\n        }\n\n        try {\n            const response = await this.orchestratorClient.sendCommand(\n                'session:addTeam',\n                { teamId: teamName },\n                10000 // Increased timeout for reliability\n            );\n\n            if (response.success) {\n                this.addTeam(teamName); // Update local registry\n                return { success: true };\n            } else {\n                return { success: false, error: response.message || 'Failed to create team' };\n            }\n        } catch (e) {\n            return { success: false, error: e.message };\n        }\n    }\n}\n\n// Export class (instance created in main.js)\nexport default TeamRegistry;\nexport { TeamRegistry };\n","/**\n * NFC Handler Module\n * Manages NFC scanning using Web NFC API\n * ES6 Module Export\n */\n\nimport Debug from './debug.js';\n\nclass NFCHandlerClass {\n  constructor() {\n    this.reader = null;\n    this.isScanning = false;\n    this.lastRead = null;       // { id: string, timestamp: number }\n    this.debounceMs = 2000;     // Ignore same tag within 2 seconds\n  }\n\n  /**\n   * Initialize NFC and check for support\n   * @returns {Promise<boolean>} Whether NFC is supported\n   */\n  async init() {\n    return 'NDEFReader' in window;\n  }\n\n  /**\n   * Start NFC scanning\n   * @param {Function} onRead - Callback for successful reads\n   * @param {Function} onError - Callback for errors\n   */\n  async startScan(onRead, onError) {\n    if (!('NDEFReader' in window)) {\n      throw new Error('NFC not supported');\n    }\n\n    try {\n      this.reader = new NDEFReader();\n\n      // CRITICAL: Attach event listeners BEFORE calling scan()\n      // Otherwise events may fire before listeners are registered\n      this.reader.addEventListener(\"reading\", ({ message, serialNumber }) => {\n        try {\n          const result = this.extractTokenId(message, serialNumber);\n          const now = Date.now();\n\n          // Debounce check - use tokenId for success, serialNumber for errors\n          const debounceKey = result.id || serialNumber;\n          if (debounceKey) {\n            if (this.lastRead &&\n                this.lastRead.id === debounceKey &&\n                (now - this.lastRead.timestamp) < this.debounceMs) {\n              Debug.log(`Debounced duplicate ${result.id ? 'read' : 'error'}: ${debounceKey}`);\n              return; // Silently ignore\n            }\n\n            // Update last read\n            this.lastRead = { id: debounceKey, timestamp: now };\n          }\n\n          onRead(result);\n        } catch (error) {\n          console.error('Exception in NFC reading handler:', error);\n          Debug.log(`Exception in NFC reading handler: ${error.message}`, true);\n        }\n      });\n\n      this.reader.addEventListener(\"readingerror\", (event) => {\n        Debug.log(`NFC Read Error: ${event}`, true);\n        if (onError) onError(event);\n      });\n\n      // NOW start scanning - listeners are ready to catch events\n      await this.reader.scan();\n      this.isScanning = true;\n\n    } catch (error) {\n      Debug.log(`Error starting NFC: ${error.message}`, true);\n      throw error;\n    }\n  }\n\n  /**\n   * Extract token ID from NFC message\n   * Uses Web NFC API's built-in NDEF parsing\n   * @param {NDEFMessage} message - NFC message\n   * @param {string} serialNumber - Tag serial number\n   * @returns {Object} Token ID and metadata, or error object\n   */\n  extractTokenId(message, serialNumber) {\n    Debug.log('‚ïê‚ïê‚ïê NFC TAG DETECTED ‚ïê‚ïê‚ïê');\n    Debug.log(`Serial: ${serialNumber}`);\n    Debug.log(`Records: ${message.records?.length || 0}`);\n\n    // No records? Return error instead of serial fallback\n    if (!message.records || message.records.length === 0) {\n      Debug.log('No NDEF records found - returning error');\n      return {\n        id: null,\n        source: 'error',\n        error: 'no-ndef-records',\n        raw: serialNumber\n      };\n    }\n\n    // Process records using the Web NFC API\n    for (const record of message.records) {\n      Debug.log(`Record type: ${record.recordType}`);\n\n      if (record.recordType === \"text\") {\n        const decoder = new TextDecoder(record.encoding || \"utf-8\");\n        const text = decoder.decode(record.data);\n        Debug.log(`‚úÖ Text record: ${text}`);\n        return {\n          id: text.trim(),\n          source: 'text-record',\n          raw: text\n        };\n      }\n\n      if (record.recordType === \"url\") {\n        const decoder = new TextDecoder();\n        const url = decoder.decode(record.data);\n        Debug.log(`‚úÖ URL record: ${url}`);\n        return {\n          id: url,\n          source: 'url-record',\n          raw: url\n        };\n      }\n\n      // Try generic text decoding for other types\n      if (record.data) {\n        try {\n          const text = new TextDecoder().decode(record.data);\n          if (text && text.trim()) {\n            Debug.log(`‚úÖ Generic decode: ${text}`);\n            return {\n              id: text.trim(),\n              source: 'generic-decode',\n              raw: text\n            };\n          }\n        } catch (e) {\n          Debug.log(`Decode failed: ${e.message}`);\n        }\n      }\n    }\n\n    // No readable records? Return error instead of serial fallback\n    Debug.log('No readable records found - returning error');\n    return {\n      id: null,\n      source: 'error',\n      error: 'unreadable-records',\n      raw: serialNumber\n    };\n  }\n\n  /**\n   * Stop NFC scanning\n   * Note: Web NFC doesn't have explicit stop - scan continues until page closes\n   */\n  stopScan() {\n    this.isScanning = false;\n  }\n\n  /**\n   * Simulate NFC scan for testing\n   * @returns {Object} Simulated token data\n   */\n  simulateScan() {\n    const testIds = [\n      'a1b2c3d4',\n      'deadbeef',\n      'cafe1234',\n      'babe2468',\n      'feed5678',\n      'unknown_' + Math.random().toString(36).substr(2, 9)\n    ];\n    const randomId = testIds[Math.floor(Math.random() * testIds.length)];\n\n    return {\n      id: randomId,\n      source: 'simulated',\n      raw: randomId\n    };\n  }\n}\n\n// Create singleton instance\nconst NFCHandler = new NFCHandlerClass();\n\nexport default NFCHandler;\nexport { NFCHandlerClass };\n","/**\n * Validate JWT token expiration with 1-minute safety buffer.\n * Shared utility ‚Äî replaces 4 duplicate implementations.\n *\n * @param {string} token - JWT token string\n * @returns {boolean} True if token exists, is well-formed, and not expired\n */\nexport function isTokenValid(token) {\n  if (!token) return false;\n\n  try {\n    const parts = token.split('.');\n    if (parts.length !== 3) return false;\n\n    const decode = typeof atob !== 'undefined'\n      ? (str) => atob(str)\n      : (str) => Buffer.from(str, 'base64').toString();\n\n    const payload = JSON.parse(decode(parts[1]));\n    if (!payload.exp) return false;\n\n    const now = Math.floor(Date.now() / 1000);\n    const BUFFER_SECONDS = 60;\n    return (payload.exp - BUFFER_SECONDS) > now;\n  } catch {\n    return false;\n  }\n}\n","/**\n * StateValidationService - Validates system state before mode restoration\n *\n * Problem solved: Users must clear cache when reconnecting after session ends.\n * This service validates the entire system state before restoring networked mode,\n * ensuring a clean UX without manual cache clearing.\n *\n * Validation checks:\n * 1. JWT token exists and is not expired (with 1-minute buffer)\n * 2. Orchestrator is reachable (GET /health)\n * 3. Session exists on backend (GET /api/session)\n *\n * If ANY check fails, the service signals that stale state should be cleared\n * and the user should be shown the mode selection screen.\n */\n\nimport Debug from '../utils/debug.js';\nimport { isTokenValid as validateToken } from '../utils/jwtUtils.js';\n\n/**\n * @typedef {Object} ValidationResult\n * @property {boolean} valid - True if all validations passed\n * @property {string|null} reason - Failure reason (null if valid)\n * @property {Object} details - Detailed validation results\n * @property {boolean} details.tokenValid - JWT token is valid\n * @property {boolean} details.orchestratorReachable - Backend health check passed\n * @property {boolean} details.sessionExists - Backend has active session\n */\n\nclass StateValidationService {\n  /**\n   * @param {Object} options - Configuration options\n   * @param {number} [options.timeout=5000] - Request timeout in ms\n   */\n  constructor(options = {}) {\n    this.timeout = options.timeout || 5000;\n  }\n\n  /**\n   * Validate all system state for networked mode restoration\n   *\n   * @param {string} orchestratorUrl - Backend URL (e.g., \"https://10.0.0.1:3000\")\n   * @returns {Promise<ValidationResult>} Validation result\n   */\n  async validateAll(orchestratorUrl) {\n    Debug.log('[StateValidation] Starting full validation...');\n\n    const result = {\n      valid: false,\n      reason: null,\n      details: {\n        tokenValid: false,\n        orchestratorReachable: false,\n        sessionExists: false\n      }\n    };\n\n    // 1. Validate JWT token\n    const token = localStorage.getItem('aln_auth_token');\n    if (!token) {\n      result.reason = 'No authentication token found';\n      Debug.log(`[StateValidation] FAIL: ${result.reason}`);\n      return result;\n    }\n\n    if (!this.isTokenValid(token)) {\n      result.reason = 'Authentication token expired';\n      Debug.log(`[StateValidation] FAIL: ${result.reason}`);\n      return result;\n    }\n    result.details.tokenValid = true;\n    Debug.log('[StateValidation] Token valid');\n\n    // 2. Validate orchestrator reachability\n    if (!orchestratorUrl) {\n      result.reason = 'No orchestrator URL configured';\n      Debug.log(`[StateValidation] FAIL: ${result.reason}`);\n      return result;\n    }\n\n    const healthOk = await this.checkOrchestratorHealth(orchestratorUrl);\n    if (!healthOk) {\n      result.reason = 'Orchestrator unreachable';\n      Debug.log(`[StateValidation] FAIL: ${result.reason}`);\n      return result;\n    }\n    result.details.orchestratorReachable = true;\n    Debug.log('[StateValidation] Orchestrator reachable');\n\n    // 3. Validate session exists\n    const sessionExists = await this.checkSessionExists(orchestratorUrl);\n    if (!sessionExists) {\n      result.reason = 'No active session on orchestrator';\n      Debug.log(`[StateValidation] FAIL: ${result.reason}`);\n      return result;\n    }\n    result.details.sessionExists = true;\n    Debug.log('[StateValidation] Session exists');\n\n    // All validations passed\n    result.valid = true;\n    Debug.log('[StateValidation] All validations PASSED');\n    return result;\n  }\n\n  /**\n   * Check if JWT token is valid (not expired, with 1-minute buffer)\n   * @param {string} token - JWT token string\n   * @returns {boolean} True if valid\n   */\n  isTokenValid(token) {\n    return validateToken(token);\n  }\n\n  /**\n   * Check if orchestrator is reachable via health endpoint\n   * @param {string} orchestratorUrl - Backend URL\n   * @returns {Promise<boolean>} True if reachable\n   */\n  async checkOrchestratorHealth(orchestratorUrl) {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n      const response = await fetch(`${orchestratorUrl}/health`, {\n        method: 'GET',\n        signal: controller.signal\n      });\n\n      clearTimeout(timeoutId);\n      return response.ok;\n    } catch (error) {\n      Debug.log(`[StateValidation] Health check error: ${error.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * Check if session exists on backend\n   * @param {string} orchestratorUrl - Backend URL\n   * @returns {Promise<boolean>} True if session exists\n   */\n  async checkSessionExists(orchestratorUrl) {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n      const response = await fetch(`${orchestratorUrl}/api/session`, {\n        method: 'GET',\n        signal: controller.signal\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        return false;\n      }\n\n      const data = await response.json();\n      // Session exists if we get a valid session object (not null/empty)\n      return !!(data && data.id);\n    } catch (error) {\n      Debug.log(`[StateValidation] Session check error: ${error.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * Clear all stale state from localStorage\n   * Called when validation fails to ensure clean state\n   */\n  clearStaleState() {\n    Debug.log('[StateValidation] Clearing stale state...');\n\n    // Clear auth token\n    localStorage.removeItem('aln_auth_token');\n\n    // Clear saved orchestrator URL (optional - user might want to keep this)\n    // localStorage.removeItem('aln_orchestrator_url');\n\n    // Clear game session mode\n    localStorage.removeItem('aln_game_session_mode');\n\n    // Clear any cached session data\n    localStorage.removeItem('aln_session_data');\n\n    Debug.log('[StateValidation] Stale state cleared');\n  }\n}\n\n// Export singleton instance and class\nconst stateValidationService = new StateValidationService();\nexport { StateValidationService };\nexport default stateValidationService;\n","/**\n * Initialization Steps - Application Bootstrap Sequence\n * ES6 Module\n *\n * Provides 11-phase initialization sequence for ALNScanner application.\n * Coordinates loading of all app modules with proper dependency ordering.\n *\n * Phase 0: Show loading screen\n * Phase 1A: Token Database Loading\n * Phase 1B: URL Parameter Mode Override\n * Phase 1C: Connection Restoration Logic (with State Validation)\n * Phase 1D: Initialize UIManager\n * Phase 1E: Create SessionModeManager\n * Phase 1F: Initialize view controller\n * Phase 1G: Load settings\n * Phase 1H: Load DataManager\n * Phase 1I: Detect NFC support\n * Phase 1J: Register service worker\n */\n\nimport Debug from '../utils/debug.js';\nimport { isTokenValid } from '../utils/jwtUtils.js';\nimport stateValidationService from '../services/StateValidationService.js';\n\n/**\n * Initialize UIManager\n * Simple wrapper for UIManager.init()\n *\n * @param {Object} uiManager - UIManager instance\n */\nexport function initializeUIManager(uiManager) {\n  uiManager.init();\n}\n\n/**\n * Create SessionModeManager singleton\n * Returns instance for storage on app object (no window global assignment)\n * CRITICAL: Must be called before viewController.init()\n *\n * @param {Function} SessionModeManagerClass - SessionModeManager constructor\n * @returns {Object} The created SessionModeManager instance\n */\nexport function createSessionModeManager(SessionModeManagerClass) {\n  const instance = new SessionModeManagerClass();\n  Debug.log('SessionModeManager initialized');\n  return instance;\n}\n\n/**\n * Initialize view controller\n * Depends on window.sessionModeManager existing\n *\n * @param {Object} viewController - ViewController instance\n */\nexport function initializeViewController(viewController) {\n  viewController.init();\n}\n\n/**\n * Load settings from localStorage\n *\n * @param {Object} settings - Settings object\n */\nexport function loadSettings(settings) {\n  settings.load();\n}\n\n/**\n * Initialize DataManager UI state (data loading deferred to sync:full / loadLocalSession)\n */\nexport function loadDataManager(dataManager, uiManager) {\n  uiManager.updateHistoryBadge();\n}\n\n/**\n * Detect NFC support\n *\n * @param {Object} nfcHandler - NFCHandler instance\n * @returns {Promise<boolean>} True if NFC is supported\n */\nexport async function detectNFCSupport(nfcHandler) {\n  const supported = await nfcHandler.init();\n  Debug.log(`NFC support: ${supported}`);\n  return supported;\n}\n\n/**\n * Register service worker for PWA functionality\n *\n * @param {Object} navigatorObj - Navigator object\n * @param {Object} uiManager - UIManager instance\n * @returns {Promise<boolean>} True if registration succeeded\n */\nexport async function registerServiceWorker(navigatorObj, uiManager) {\n  if (!('serviceWorker' in navigatorObj)) {\n    return false;\n  }\n\n  try {\n    // Use dynamic base path to support orchestrator subdirectory serving\n    // If served from https://IP:3000/gm-scanner/, this resolves to /gm-scanner/sw.js\n    // If served locally, resolves to /sw.js or ./sw.js\n    const swPath = new URL('sw.js', window.location.href).pathname;\n\n    const registration = await navigatorObj.serviceWorker.register(swPath);\n    Debug.log('Service Worker registered successfully');\n    console.log('Service Worker registration successful:', registration.scope);\n    return true;\n  } catch (error) {\n    // Check if this is an SSL certificate error (expected with self-signed certs)\n    const isSSLError = error.name === 'SecurityError' &&\n      error.message.includes('SSL certificate error');\n\n    if (isSSLError) {\n      // SSL errors are expected when using self-signed certificates\n      // Service Worker provides offline PWA functionality, not critical for networked mode\n      Debug.log('Service Worker registration skipped due to SSL certificate (self-signed cert)');\n      console.warn('Service Worker not available due to self-signed certificate. Offline features disabled.');\n      return false;\n    } else {\n      // Other errors should still be reported\n      Debug.log('Service Worker registration failed');\n      console.error('Service Worker registration failed:', error);\n      uiManager.showError('Service Worker registration failed. Offline features may not work.');\n      return false;\n    }\n  }\n}\n\n/**\n * Load token database from TokenManager\n *\n * @param {Object} tokenManager - TokenManager instance\n * @param {Object} uiManager - UIManager instance\n * @returns {Promise<boolean>} True if database loaded successfully\n * @throws {Error} If database load fails\n */\nexport async function loadTokenDatabase(tokenManager, uiManager) {\n  const dbLoaded = await tokenManager.loadDatabase();\n\n  if (!dbLoaded) {\n    const errorMsg = 'CRITICAL: Token database failed to load. Cannot initialize scanner.';\n    Debug.log(errorMsg, true);\n    uiManager.showError(errorMsg);\n    throw new Error('Token database initialization failed');\n  }\n\n  Debug.log('Token database loaded successfully');\n  return true;\n}\n\n/**\n * Apply URL parameter mode override\n * Checks for ?mode=blackmarket or ?mode=black-market and sets station mode\n *\n * @param {string} locationSearch - window.location.search (query string)\n * @param {Object} settings - Settings object with mode and save()\n * @returns {boolean} True if mode was applied, false otherwise\n */\nexport function applyURLModeOverride(locationSearch, settings) {\n  const urlParams = new URLSearchParams(locationSearch);\n  const modeParam = urlParams.get('mode');\n\n  if (modeParam === 'blackmarket' || modeParam === 'black-market') {\n    settings.mode = 'blackmarket';\n    settings.save();\n    Debug.log('Station mode set to blackmarket via URL parameter');\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Determine initial screen based on connection restoration logic\n * Pure function - no side effects, only decision logic\n *\n * NOTE: For networked mode, use validateAndDetermineInitialScreen() instead\n * to perform full state validation (token + orchestrator + session).\n *\n * @param {Object} sessionModeManager - SessionModeManager instance\n * @returns {Object} Decision object with {screen, action, savedMode}\n */\nexport function determineInitialScreen(sessionModeManager) {\n  const savedMode = sessionModeManager.restoreMode();\n\n  // Case 1: No saved mode (first-time user)\n  if (!savedMode) {\n    return { screen: 'gameModeScreen', action: null, savedMode: null };\n  }\n\n  // Case 2: Standalone mode - initialize and go to team entry\n  if (savedMode === 'standalone') {\n    return { screen: 'teamEntry', action: 'initStandalone', savedMode };\n  }\n\n  // Case 3: Networked mode - check if we have valid token for auto-connect\n  if (savedMode === 'networked') {\n    const token = localStorage.getItem('aln_auth_token');\n\n    if (token && isTokenValid(token)) {\n      // Valid token - try auto-connect\n      return { screen: 'loading', action: 'autoConnect', savedMode };\n    } else {\n      // No valid token - need to show wizard\n      return { screen: 'gameModeScreen', action: 'clearModeAndShowWizard', savedMode };\n    }\n  }\n\n  // Fallback\n  return { screen: 'gameModeScreen', action: null, savedMode: null };\n}\n\n/**\n * Validate system state and determine initial screen for networked mode\n * Async version that performs full validation before deciding action.\n *\n * Phase 4.1 enhancement: Validates orchestrator + session in addition to token.\n * If any validation fails, clears stale state and shows mode selection screen.\n *\n * @param {Object} sessionModeManager - SessionModeManager instance\n * @returns {Promise<Object>} Decision object with {screen, action, savedMode, validationResult}\n */\nexport async function validateAndDetermineInitialScreen(sessionModeManager) {\n  const savedMode = sessionModeManager.restoreMode();\n\n  // Case 1: No saved mode (first-time user)\n  if (!savedMode) {\n    return { screen: 'gameModeScreen', action: null, savedMode: null, validationResult: null };\n  }\n\n  // Case 2: Standalone mode - no validation needed\n  if (savedMode === 'standalone') {\n    return { screen: 'teamEntry', action: 'initStandalone', savedMode, validationResult: null };\n  }\n\n  // Case 3: Networked mode - perform full validation\n  if (savedMode === 'networked') {\n    const orchestratorUrl = localStorage.getItem('aln_orchestrator_url');\n\n    // Validate full system state: token + orchestrator + session\n    Debug.log('[InitSteps] Performing full state validation for networked mode...');\n    const validationResult = await stateValidationService.validateAll(orchestratorUrl);\n\n    if (validationResult.valid) {\n      // All validations passed - try auto-connect\n      Debug.log('[InitSteps] Validation passed - attempting auto-connect');\n      return { screen: 'loading', action: 'autoConnect', savedMode, validationResult };\n    } else {\n      // Validation failed - clear stale state and show wizard\n      Debug.log(`[InitSteps] Validation failed: ${validationResult.reason}`);\n      stateValidationService.clearStaleState();\n      return {\n        screen: 'gameModeScreen',\n        action: 'clearModeAndShowWizard',\n        savedMode,\n        validationResult\n      };\n    }\n  }\n\n  // Fallback\n  return { screen: 'gameModeScreen', action: null, savedMode: null, validationResult: null };\n}\n\n\n/**\n * Apply initial screen decision (executes side effects)\n * Handles UI changes, mode clearing, wizard display, and auto-connect\n *\n * @param {Object} decision - Decision from determineInitialScreen()\n * @param {Object} sessionModeManager - SessionModeManager instance\n * @param {Object} uiManager - UIManager instance\n * @param {Function} showWizardFn - showConnectionWizard function\n * @param {Function} initNetworkedModeFn - Async function to initialize networked mode (from app._initializeNetworkedMode)\n */\nexport async function applyInitialScreenDecision(decision, sessionModeManager, uiManager, showWizardFn, initNetworkedModeFn = null) {\n  Debug.log(`Applying screen decision: screen=${decision.screen}, action=${decision.action}`);\n\n  if (decision.action === 'clearModeAndShowWizard') {\n    // Networked mode restored but no valid token - clear and show wizard\n    Debug.log('Networked mode restored but no valid token - showing wizard');\n    sessionModeManager.clearMode();\n    uiManager.showScreen(decision.screen);\n    showWizardFn();\n\n  } else if (decision.action === 'initStandalone') {\n    // Standalone mode - lock mode and show team entry\n    Debug.log('Restoring standalone mode');\n    sessionModeManager.setMode('standalone');\n    uiManager.showScreen(decision.screen);\n\n  } else if (decision.action === 'autoConnect') {\n    // Networked mode with valid token - attempt auto-connect\n    Debug.log('Valid token found - attempting auto-connect');\n    uiManager.showScreen(decision.screen); // Show loading screen\n\n    try {\n      // Lock networked mode and initialize NetworkedSession\n      sessionModeManager.setMode('networked');\n\n      if (initNetworkedModeFn) {\n        await initNetworkedModeFn();\n        Debug.log('Auto-connect successful - showing team entry');\n        uiManager.showScreen('teamEntry');\n      } else {\n        throw new Error('initNetworkedModeFn not provided for auto-connect');\n      }\n    } catch (error) {\n      Debug.log('Auto-connect failed - showing wizard');\n      console.error('Auto-connect error:', error);\n      sessionModeManager.clearMode();\n      uiManager.showScreen('gameModeScreen');\n      showWizardFn();\n    }\n\n  } else {\n    // Simple screen change, no special action needed\n    Debug.log(`Showing initial screen: ${decision.screen}`);\n    uiManager.showScreen(decision.screen);\n  }\n}\n\n/**\n * Show loading screen with paint delay\n * Ensures loading screen is visible before JavaScript continues executing\n *\n * @param {Object} uiManager - UIManager instance\n * @returns {Promise<void>}\n */\nexport async function showLoadingScreen(uiManager) {\n  uiManager.showScreen('loading');\n  // Ensure browser paints the loading screen before continuing\n  await new Promise(resolve => setTimeout(resolve, 100));\n  Debug.log('Loading screen displayed');\n}\n\n// Default export for convenience\nexport default {\n  initializeUIManager,\n  createSessionModeManager,\n  initializeViewController,\n  loadSettings,\n  loadDataManager,\n  detectNFCSupport,\n  registerServiceWorker,\n  loadTokenDatabase,\n  applyURLModeOverride,\n  determineInitialScreen,\n  validateAndDetermineInitialScreen,\n  applyInitialScreenDecision,\n  showLoadingScreen\n};\n","/**\n * SessionModeManager - Mode Locking and Persistence\n * ES6 Module - Simple State Manager\n *\n * Manages the dual operation modes (networked/standalone) with locking mechanism.\n * Once a mode is set, it cannot be changed until page reload.\n *\n * Key responsibilities:\n * - Mode locking (networked vs standalone)\n * - Mode persistence (localStorage)\n * - Mode detection and validation\n *\n * Does NOT:\n * - Initialize networked sessions (that's NetworkedSession's job)\n * - Handle UI (that's UIManager's job)\n * - Manage connections (that's ConnectionManager's job)\n */\n\nexport class SessionModeManager {\n  constructor() {\n    this.mode = null; // 'networked' | 'standalone' | null\n    this.locked = false; // Once set, cannot change during session\n  }\n\n  /**\n   * Set the session mode and lock it\n   * @param {string} mode - 'networked' or 'standalone'\n   * @throws {Error} If mode is already locked or invalid mode provided\n   */\n  setMode(mode) {\n    if (this.locked) {\n      throw new Error('Cannot change session mode after it is locked');\n    }\n\n    if (mode !== 'networked' && mode !== 'standalone') {\n      throw new Error(`Invalid session mode: ${mode}. Must be 'networked' or 'standalone'`);\n    }\n\n    this.mode = mode;\n    this.locked = true;\n    this._persistMode(mode);\n  }\n\n  /**\n   * Check if current mode is networked\n   * @returns {boolean}\n   */\n  isNetworked() {\n    return this.mode === 'networked';\n  }\n\n  /**\n   * Check if current mode is standalone\n   * @returns {boolean}\n   */\n  isStandalone() {\n    return this.mode === 'standalone';\n  }\n\n  /**\n   * Restore mode from localStorage without locking\n   * Allows user to change mode on fresh start\n   * @returns {string|null} Restored mode or null\n   */\n  restoreMode() {\n    const savedMode = this._getPersistedMode();\n    if (savedMode && (savedMode === 'networked' || savedMode === 'standalone')) {\n      this.mode = savedMode;\n      // Don't lock it yet - allow user to change on fresh start\n      return savedMode;\n    }\n    return null;\n  }\n\n  /**\n   * Clear the current mode and unlock\n   * Removes mode from localStorage\n   */\n  clearMode() {\n    this.mode = null;\n    this.locked = false;\n    this._clearPersistedMode();\n  }\n\n  /**\n   * Get the current mode\n   * @returns {string|null}\n   */\n  getMode() {\n    return this.mode;\n  }\n\n  /**\n   * Check if mode is locked\n   * @returns {boolean}\n   */\n  isLocked() {\n    return this.locked;\n  }\n\n  /**\n   * Persist mode to localStorage\n   * @private\n   */\n  _persistMode(mode) {\n    try {\n      localStorage.setItem('gameSessionMode', mode);\n    } catch (error) {\n      console.error('Failed to persist session mode:', error);\n    }\n  }\n\n  /**\n   * Get persisted mode from localStorage\n   * @private\n   * @returns {string|null}\n   */\n  _getPersistedMode() {\n    try {\n      return localStorage.getItem('gameSessionMode');\n    } catch (error) {\n      console.error('Failed to read persisted session mode:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Clear persisted mode from localStorage\n   * @private\n   */\n  _clearPersistedMode() {\n    try {\n      localStorage.removeItem('gameSessionMode');\n    } catch (error) {\n      console.error('Failed to clear persisted session mode:', error);\n    }\n  }\n}\n\n// Create singleton instance\nconst sessionModeManager = new SessionModeManager();\n\n// Export both named class and singleton instance\nexport default sessionModeManager;\n","/**\n * OrchestratorClient - WebSocket Communication Layer\n * ES6 Module - Browser Only\n *\n * Responsibilities:\n * - Create/destroy Socket.io connection\n * - Send messages with AsyncAPI envelope wrapper\n * - Forward all received messages as events\n * - Clean connection lifecycle (connect, disconnect)\n *\n * Does NOT handle:\n * - Token validation (ConnectionManager)\n * - Retry logic (ConnectionManager)\n * - Reconnection handling (ConnectionManager)\n * - Health checks (ConnectionManager)\n * - Message processing (consumers listen to events)\n * - Admin module initialization (AdminController)\n */\n\nexport class OrchestratorClient extends EventTarget {\n  constructor(config = {}) {\n    super();\n\n    this.config = {\n      url: config.url || 'https://localhost:3000',\n      deviceId: config.deviceId || 'GM_STATION_UNKNOWN',\n      version: '1.0.0',\n      transports: ['websocket']\n    };\n\n    this.socket = null;\n    this.isConnected = false;\n    this.connectionTimeout = null; // Track timeout for cleanup\n  }\n\n  /**\n   * Connect to orchestrator WebSocket\n   * @param {string} token - JWT authentication token\n   * @param {Object} auth - Authentication payload { deviceId, deviceType }\n   * @returns {Promise<void>}\n   * @emits socket:connected - Connection established\n   * @emits socket:error - Connection failed\n   */\n  async connect(token, auth) {\n    // Cleanup old socket first (allows reconnection)\n    if (this.socket?.connected) {\n      console.warn('OrchestratorClient: Already connected, cleaning up old socket');\n    }\n\n    this._cleanup();\n\n    this.socket = io(this.config.url, {\n      transports: this.config.transports,\n      reconnection: false, // ConnectionManager handles reconnection\n      timeout: 10000,\n      auth: {\n        token: token,\n        deviceId: auth.deviceId,\n        deviceType: auth.deviceType,\n        version: this.config.version\n      }\n    });\n\n    this._setupSocketHandlers();\n\n    return new Promise((resolve, reject) => {\n      const onConnect = () => {\n        if (this.connectionTimeout) {\n          clearTimeout(this.connectionTimeout);\n          this.connectionTimeout = null;\n        }\n        // No need to manually remove 'once' listeners - they auto-remove after firing\n        this.isConnected = true;\n        this.dispatchEvent(new CustomEvent('socket:connected'));\n        resolve();\n      };\n\n      const onError = (error) => {\n        if (this.connectionTimeout) {\n          clearTimeout(this.connectionTimeout);\n          this.connectionTimeout = null;\n        }\n        // No need to manually remove 'once' listeners - they auto-remove after firing\n        this.dispatchEvent(new CustomEvent('socket:error', { detail: { error } }));\n        reject(error);\n      };\n\n      // Setup timeout handler\n      this.connectionTimeout = setTimeout(() => {\n        // Guard against socket being null (e.g., if destroy() called during connection)\n        if (this.socket) {\n          this.socket.off('connect', onConnect);\n          this.socket.off('connect_error', onError);\n        }\n        this.connectionTimeout = null;\n        reject(new Error('Connection timeout'));\n      }, 10000);\n\n      this.socket.once('connect', onConnect);\n      this.socket.once('connect_error', onError);\n    });\n  }\n\n  /**\n   * Send message to orchestrator with AsyncAPI envelope\n   * @param {string} eventType - Event name (e.g., 'transaction:submit')\n   * @param {Object} data - Event payload\n   * @throws {Error} If socket not connected\n   */\n  send(eventType, data) {\n    if (!this.socket?.connected) {\n      throw new Error('Socket not connected');\n    }\n\n    this.socket.emit(eventType, {\n      event: eventType,\n      data: data,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  /**\n   * Send gm:command and wait for acknowledgment\n   * Follows AsyncAPI contract for admin commands\n   *\n   * @param {string} action - Command action (e.g., 'session:addTeam')\n   * @param {Object} payload - Command payload\n   * @param {number} timeout - Timeout in ms (default 5000)\n   * @returns {Promise<{success: boolean, message: string}>}\n   * @throws {Error} If socket not connected or command times out\n   */\n  async sendCommand(action, payload = {}, timeout = 5000) {\n    if (!this.socket?.connected) {\n      throw new Error('Socket not connected');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        cleanup();\n        reject(new Error(`Command ${action} timed out`));\n      }, timeout);\n\n      const handler = (envelope) => {\n        const data = envelope.data || envelope;\n        if (data.action === action) {\n          cleanup();\n          resolve({\n            success: data.success,\n            message: data.message || ''\n          });\n        }\n      };\n\n      const cleanup = () => {\n        clearTimeout(timeoutId);\n        this.socket.off('gm:command:ack', handler);\n      };\n\n      this.socket.on('gm:command:ack', handler);\n\n      // Send with proper gm:command envelope (NOT raw action name)\n      this.socket.emit('gm:command', {\n        event: 'gm:command',\n        data: { action, payload },\n        timestamp: new Date().toISOString()\n      });\n    });\n  }\n\n  /**\n   * Disconnect from orchestrator\n   * @returns {Promise<void>}\n   * @emits socket:disconnected - Disconnection complete\n   */\n  async disconnect() {\n    if (!this.socket) return;\n\n    return new Promise((resolve) => {\n      if (!this.socket.connected) {\n        this._cleanup();\n        resolve();\n        return;\n      }\n\n      this.socket.once('disconnect', (reason) => {\n        this.dispatchEvent(new CustomEvent('socket:disconnected', { detail: { reason } }));\n        this._cleanup();\n        resolve();\n      });\n\n      this.socket.disconnect();\n\n      // Timeout fallback\n      setTimeout(() => {\n        this._cleanup();\n        resolve();\n      }, 1000);\n    });\n  }\n\n  /**\n   * Destroy client (cleanup without graceful disconnect)\n   */\n  destroy() {\n    this._cleanup();\n  }\n\n  /**\n   * Setup Socket.io event handlers\n   * @private\n   */\n  _setupSocketHandlers() {\n    if (!this.socket) return;\n\n    // Connection lifecycle events\n    this.socket.on('connect', () => {\n      this.isConnected = true;\n      this.dispatchEvent(new CustomEvent('socket:connected'));\n    });\n\n    this.socket.on('disconnect', (reason) => {\n      this.isConnected = false;\n      this.dispatchEvent(new CustomEvent('socket:disconnected', { detail: { reason } }));\n    });\n\n    this.socket.on('connect_error', (error) => {\n      this.dispatchEvent(new CustomEvent('socket:error', { detail: { error } }));\n    });\n\n    // Forward all AsyncAPI message types\n\n    this._setupMessageHandlers();\n  }\n\n  /**\n   * Setup message forwarding for all AsyncAPI event types\n   * @private\n   */\n  _setupMessageHandlers() {\n    const messageTypes = [\n      'sync:full',\n      'transaction:result',\n      'transaction:new',\n      'transaction:deleted',\n      'score:updated',\n      'scores:reset',\n      'video:status',\n      'session:update',\n      'session:overtime',\n      'device:connected',\n      'device:disconnected',\n      'group:completed',\n      'display:mode',  // Phase 4.2: Display control events\n      'video:progress',      // Video playback progress (1s interval)\n      'video:queue:update',  // Video queue changes\n      'gm:command:ack',\n      'offline:queue:processed',\n      'batch:ack',\n      'error',\n      'player:scan',  // Phase 3: Unified Game Activity - player scan broadcasts\n      'bluetooth:device',        // Phase 0: Environment Control - BT device state changes\n      'bluetooth:scan',          // Phase 0: Environment Control - BT scan start/stop\n      'audio:routing',           // Phase 0: Environment Control - audio route changes\n      'audio:routing:fallback',  // Phase 0: Environment Control - audio HDMI fallback\n      'lighting:scene',          // Phase 0: Environment Control - scene activated\n      'lighting:status',         // Phase 0: Environment Control - HA connection/scene refresh\n      'gameclock:status',        // Phase 1: Game clock state (running/paused/stopped)\n      'cue:fired',               // Phase 1: Cue triggered\n      'cue:status',              // Phase 2: Compound cue progress\n      'cue:completed',           // Phase 1: Cue action sequence completed\n      'cue:error',               // Phase 1: Cue action failed\n      'cue:conflict',            // Phase 2: Compound cue video conflict detection\n      'sound:status',            // Phase 1: Sound playback status\n      'spotify:status',          // Phase 2: Spotify playback status\n      'audio:ducking:status',    // Phase 3: Audio ducking state change\n      'audio:sinks'              // Phase 3: PipeWire sink added/removed (refresh dropdown)\n    ];\n\n    messageTypes.forEach(type => {\n      this.socket.on(type, (envelope) => {\n        // Extract payload from AsyncAPI envelope\n        const payload = envelope.data || envelope;\n        // Forward as generic message:received event\n        this.dispatchEvent(new CustomEvent('message:received', {\n          detail: { type, payload }\n        }));\n      });\n    });\n  }\n\n  /**\n   * Cleanup socket and listeners\n   * @private\n   */\n  _cleanup() {\n    // Clear connection timeout if still pending\n    if (this.connectionTimeout) {\n      clearTimeout(this.connectionTimeout);\n      this.connectionTimeout = null;\n    }\n\n    if (this.socket) {\n      this.socket.removeAllListeners();\n      if (this.socket.connected) {\n        this.socket.disconnect();\n      }\n      this.socket = null;\n    }\n    this.isConnected = false;\n  }\n}\n\n// Default export for convenience\nexport default OrchestratorClient;\n","/**\n * ConnectionManager - Connection Lifecycle Manager\n * ES6 Module - Browser Only\n *\n * Responsibilities:\n * - Token validation (JWT expiry check with 1-minute buffer)\n * - Health checks (orchestrator reachability)\n * - Retry logic with exponential backoff\n * - Reconnection handling (on server-initiated disconnect)\n * - Auth:required event emission (token expiry, max retries)\n *\n * Does NOT handle:\n * - WebSocket connection (OrchestratorClient)\n * - Message sending (OrchestratorClient)\n * - Message processing (consumers)\n * - Admin operations (AdminController)\n */\n\nimport { isTokenValid as validateToken } from '../utils/jwtUtils.js';\n\nexport class ConnectionManager extends EventTarget {\n  constructor(config = {}) {\n    super();\n\n    this.config = {\n      url: config.url || 'https://localhost:3000',\n      deviceId: config.deviceId || 'GM_STATION_UNKNOWN',\n      deviceType: 'gm'\n    };\n\n    this.client = config.client; // OrchestratorClient instance\n    this.token = config.token || null;\n    this.state = 'disconnected'; // disconnected, connecting, connected\n    this.retryCount = 0;\n    this.maxRetries = config.maxRetries || 5;\n    this.retryTimer = null;\n    this.disconnectHandler = null;\n\n    // Wire global connection status indicator updates\n    this.addEventListener('connecting', () => this._updateGlobalConnectionStatus('connecting'));\n    this.addEventListener('connected', () => this._updateGlobalConnectionStatus('connected'));\n    this.addEventListener('disconnected', () => this._updateGlobalConnectionStatus('disconnected'));\n  }\n\n  /**\n   * Validate JWT token expiry with 1-minute buffer\n   * @returns {boolean}\n   */\n  isTokenValid() {\n    return validateToken(this.token);\n  }\n\n  /**\n   * Check orchestrator health\n   * @returns {Promise<boolean>}\n   */\n  async checkHealth() {\n    try {\n      const controller = new AbortController();\n      const timeout = setTimeout(() => controller.abort(), 5000);\n\n      const response = await fetch(`${this.config.url}/health`, {\n        method: 'GET',\n        mode: 'cors',\n        signal: controller.signal\n      });\n\n      clearTimeout(timeout);\n      return response.ok;\n    } catch {\n      // Health check failed - orchestrator unreachable\n      return false;\n    }\n  }\n\n  /**\n   * Connect to orchestrator\n   * @returns {Promise<void>}\n   * @emits connecting - Connection attempt started\n   * @emits connected - Connection established\n   * @emits auth:required - Token invalid/expired\n   * @throws {Error} If validation or connection fails\n   */\n  async connect() {\n    // Validate token\n    if (!this.isTokenValid()) {\n      this.dispatchEvent(new CustomEvent('auth:required', {\n        detail: { reason: 'invalid_token' }\n      }));\n      throw new Error('Invalid or expired token');\n    }\n\n    // Check health\n    const healthy = await this.checkHealth();\n    if (!healthy) {\n      throw new Error('Orchestrator unreachable');\n    }\n\n    // Clear any pending retry timer\n    this._clearRetryTimer();\n\n    // Update state\n    this.state = 'connecting';\n    this.dispatchEvent(new CustomEvent('connecting'));\n\n    try {\n      // Delegate WebSocket connection to OrchestratorClient\n      await this.client.connect(this.token, {\n        deviceId: this.config.deviceId,\n        deviceType: this.config.deviceType\n      });\n\n      // Connection successful\n      this.state = 'connected';\n      this.retryCount = 0;\n      this.dispatchEvent(new CustomEvent('connected'));\n\n      // Setup reconnection handler\n      this._setupReconnectionHandler();\n\n    } catch (error) {\n      this.state = 'disconnected';\n\n      // Schedule retry\n      this.retryCount++;\n      if (this.retryCount < this.maxRetries) {\n        this._scheduleRetry();\n      } else {\n        this.dispatchEvent(new CustomEvent('auth:required', {\n          detail: { reason: 'max_retries' }\n        }));\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Disconnect from orchestrator\n   * @returns {Promise<void>}\n   */\n  async disconnect() {\n    this._clearRetryTimer();\n    this._removeReconnectionHandler();\n\n    if (this.client) {\n      await this.client.disconnect();\n    }\n\n    this.state = 'disconnected';\n  }\n\n  /**\n   * Update authentication token\n   * @param {string} token - New JWT token\n   */\n  updateToken(token) {\n    this.token = token;\n  }\n\n  /**\n   * Setup reconnection handler for server-initiated disconnects\n   * @private\n   */\n  _setupReconnectionHandler() {\n    if (this.disconnectHandler) {\n      this._removeReconnectionHandler();\n    }\n\n    this.disconnectHandler = (event) => {\n      const reason = event.detail?.reason;\n\n      this.state = 'disconnected';\n      this.dispatchEvent(new CustomEvent('disconnected', { detail: { reason } }));\n\n      // Only auto-reconnect on server-initiated disconnect\n      if (reason === 'io server disconnect') {\n        // Check if token still valid\n        if (!this.isTokenValid()) {\n          this.dispatchEvent(new CustomEvent('auth:required', {\n            detail: { reason: 'token_expired' }\n          }));\n          return;\n        }\n\n        // Schedule reconnection\n        setTimeout(() => {\n          this.connect().catch(() => {\n            // Retry logic handles failures\n          });\n        }, 1000);\n      }\n    };\n\n    this.client.addEventListener('socket:disconnected', this.disconnectHandler);\n  }\n\n  /**\n   * Remove reconnection handler\n   * @private\n   */\n  _removeReconnectionHandler() {\n    if (this.disconnectHandler) {\n      this.client.removeEventListener('socket:disconnected', this.disconnectHandler);\n      this.disconnectHandler = null;\n    }\n  }\n\n  /**\n   * Schedule retry with exponential backoff\n   * @private\n   */\n  _scheduleRetry() {\n    const delay = this._calculateRetryDelay();\n\n    this.retryTimer = setTimeout(() => {\n      this.connect().catch(() => {\n        // Retry logic handles failures\n      });\n    }, delay);\n  }\n\n  /**\n   * Calculate retry delay with exponential backoff\n   * @returns {number} Delay in milliseconds\n   * @private\n   */\n  _calculateRetryDelay() {\n    const baseDelay = 1000; // 1 second\n    const maxDelay = 30000; // 30 seconds\n    const delay = baseDelay * Math.pow(2, this.retryCount);\n    return Math.min(delay, maxDelay);\n  }\n\n  /**\n   * Clear retry timer\n   * @private\n   */\n  _clearRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n\n  /**\n   * Update global connection status indicator in header\n   * @param {string} status - Connection status: 'connecting', 'connected', 'disconnected'\n   * @private\n   */\n  _updateGlobalConnectionStatus(status) {\n    const statusElement = document.getElementById('connectionStatus');\n    if (!statusElement) return;\n\n    // Remove all status classes\n    statusElement.classList.remove('connected', 'connecting', 'disconnected');\n\n    // Add current status class\n    statusElement.classList.add(status);\n\n    // Update text\n    const textElement = statusElement.querySelector('.status-text');\n    if (textElement) {\n      const statusText = {\n        connecting: 'Connecting...',\n        connected: 'Connected',\n        disconnected: 'Disconnected'\n      };\n      textElement.textContent = statusText[status] || 'Unknown';\n    }\n  }\n}\n\nexport default ConnectionManager;\n","/**\n * NetworkedQueueManager - Offline Transaction Queue Manager\n * ES6 Module - Browser Only\n *\n * Responsibilities:\n * - Offline transaction queue (localStorage persistence)\n * - Auto-sync on reconnect\n * - Queue management (add, retry, clear)\n * - Transaction replay via WebSocket for proper scoring\n *\n * Does NOT handle:\n * - WebSocket connection (OrchestratorClient)\n * - Event emission (managed by NetworkedSession)\n * - Transaction processing (backend)\n */\n\nexport class NetworkedQueueManager extends EventTarget {\n  constructor(config = {}) {\n    super();\n\n    this.client = config.client; // OrchestratorClient instance (dependency injection)\n    this.debug = config.debug || console; // Debug utility (dependency injection)\n    this.deviceId = config.deviceId || 'GM_STATION_UNKNOWN';\n\n    this.tempQueue = [];\n    this.syncing = false;\n    this.activeHandlers = new Map(); // Track active replay handlers for cleanup\n\n    // Load any persisted queue\n    this.loadQueue();\n  }\n\n  /**\n   * Queue a transaction for submission\n   * @param {Object} transaction - Transaction to queue\n   * @emits queue:changed - Queue status updated\n   */\n  queueTransaction(transaction) {\n    // Check if we have a connection and it's connected\n    if (!this.client || !this.client.isConnected) {\n      // Not connected - add to temp queue\n      this.tempQueue.push(transaction);\n      this.saveQueue();\n      this.debug.log('Transaction queued for later submission', {\n        tokenId: transaction.tokenId,\n        queueSize: this.tempQueue.length\n      });\n\n      // Emit event for UI updates (event-driven, no polling needed)\n      this.dispatchEvent(new CustomEvent('queue:changed', {\n        detail: this.getStatus()\n      }));\n    } else {\n      // Connected - send immediately via OrchestratorClient\n      this.client.send('transaction:submit', transaction);\n\n      this.debug.log('Transaction sent immediately', {\n        tokenId: transaction.tokenId\n      });\n    }\n  }\n\n  /**\n   * Sync queued transactions when connection restored\n   * Replays each transaction via WebSocket for proper scoring/game mechanics\n   *\n   * NOTE: GM offline scans MUST use transaction:submit (not batch endpoint)\n   * Batch endpoint has NO SCORING OR GAME MECHANICS (player-only)\n   * Replay ensures duplicate detection, scoring, bonuses all work correctly\n   *\n   * @returns {Promise<void>}\n   */\n  async syncQueue() {\n    if (this.syncing || this.tempQueue.length === 0 || !this.client || !this.client.isConnected) {\n      return;\n    }\n\n    this.syncing = true;\n    this.debug.log('Starting queue sync via WebSocket replay', { queueSize: this.tempQueue.length });\n\n    const batch = [...this.tempQueue]; // Copy for sending\n    const results = [];\n\n    try {\n      // Replay each transaction via WebSocket (transaction:submit)\n      // This ensures proper scoring, duplicate detection, and game mechanics\n      for (let i = 0; i < batch.length; i++) {\n        const transaction = batch[i];\n\n        this.debug.log(`Replaying transaction ${i + 1}/${batch.length}`, {\n          tokenId: transaction.tokenId,\n          teamId: transaction.teamId\n        });\n\n        try {\n          // Replay via WebSocket (same path as live scans)\n          const result = await this.replayTransaction(transaction);\n          results.push({ success: true, transaction, result });\n        } catch (error) {\n          this.debug.error?.('Transaction replay failed', {\n            tokenId: transaction.tokenId,\n            error: error.message\n          });\n\n          results.push({ success: false, transaction, error: error.message });\n        }\n      }\n\n      const successCount = results.filter(r => r.success).length;\n      const failCount = results.length - successCount;\n\n      this.debug.log('Queue sync complete', {\n        total: batch.length,\n        success: successCount,\n        failed: failCount\n      });\n\n      // Clear queue after ALL transactions processed (even if some failed)\n      // Failed transactions are lost but logged - operator can manually re-scan\n      // This prevents infinite retry loops for permanently invalid transactions\n      this.tempQueue = [];\n      this.saveQueue();\n\n    } catch (error) {\n      this.debug.error?.('Queue sync failed - keeping queue for retry', {\n        error: error.message,\n        queueSize: this.tempQueue.length\n      });\n      // Queue preserved for retry on failure\n    } finally {\n      this.syncing = false;\n\n      // Emit event to update UI AFTER syncing flag is reset\n      this.dispatchEvent(new CustomEvent('queue:changed', {\n        detail: this.getStatus()\n      }));\n    }\n  }\n\n  /**\n   * Replay a single transaction via WebSocket\n   * Returns Promise that resolves with result or rejects on error/timeout\n   *\n   * @param {Object} transaction - Transaction to replay\n   * @returns {Promise<Object>} - Transaction result\n   * @private\n   */\n  replayTransaction(transaction) {\n    return new Promise((resolve, reject) => {\n      const handlerKey = `${transaction.tokenId}-${transaction.teamId}`;\n\n      // Helper to cleanup handler and timeout\n      const cleanup = (timeout, handler) => {\n        clearTimeout(timeout);\n        this.client.removeEventListener('message:received', handler);\n        this.activeHandlers.delete(handlerKey);\n      };\n\n      const timeout = setTimeout(() => {\n        const handler = this.activeHandlers.get(handlerKey);\n        if (handler) {\n          cleanup(timeout, handler);\n        }\n        reject(new Error(`Transaction replay timeout after 30s: ${transaction.tokenId}`));\n      }, 30000);\n\n      const handler = (event) => {\n        const { type, payload } = event.detail;\n\n        // Only process transaction:result events\n        if (type !== 'transaction:result') return;\n\n        // Check if this result matches our transaction\n        // (tokenId + teamId should be unique enough for matching)\n        if (payload.tokenId === transaction.tokenId &&\n            payload.teamId === transaction.teamId) {\n          cleanup(timeout, handler);\n\n          if (payload.status === 'error') {\n            reject(new Error(payload.message || 'Transaction failed'));\n          } else {\n            resolve(payload);\n          }\n        }\n        // If doesn't match, keep listening (might be from another concurrent scan)\n      };\n\n      // Track handler for cleanup\n      this.activeHandlers.set(handlerKey, handler);\n\n      // Register listener for transaction:result (via OrchestratorClient's message:received)\n      this.client.addEventListener('message:received', handler);\n\n      // Send transaction via OrchestratorClient\n      this.client.send('transaction:submit', transaction);\n\n      this.debug.log('Transaction submitted for replay', {\n        tokenId: transaction.tokenId,\n        teamId: transaction.teamId\n      });\n    });\n  }\n\n  /**\n   * Save queue to localStorage\n   */\n  saveQueue() {\n    try {\n      if (this.tempQueue.length > 0) {\n        localStorage.setItem('networkedTempQueue', JSON.stringify(this.tempQueue));\n      } else {\n        localStorage.removeItem('networkedTempQueue');\n      }\n    } catch (error) {\n      // Handle QuotaExceededError or other storage errors\n      if (error.name === 'QuotaExceededError') {\n        this.debug.error?.('localStorage quota exceeded - unable to save queue', {\n          queueSize: this.tempQueue.length,\n          error: error.message\n        });\n        // Attempt to clear oldest items or notify user\n        alert('Storage full: Unable to queue transactions offline. Please sync or clear data.');\n      } else {\n        this.debug.error?.('Failed to save queue to localStorage', error);\n      }\n    }\n  }\n\n  /**\n   * Load queue from localStorage\n   */\n  loadQueue() {\n    try {\n      const saved = localStorage.getItem('networkedTempQueue');\n      if (saved) {\n        this.tempQueue = JSON.parse(saved);\n        this.debug.log('Loaded queued transactions', { count: this.tempQueue.length });\n      }\n    } catch (error) {\n      this.debug.error?.('Failed to load queue', error);\n      this.tempQueue = [];\n    }\n  }\n\n  /**\n   * Clear the queue (only after successful sync)\n   */\n  clearQueue() {\n    this.tempQueue = [];\n    localStorage.removeItem('networkedTempQueue');\n    this.debug.log('Queue cleared');\n  }\n\n  /**\n   * Get queue status\n   * @returns {Object} Queue status { queuedCount, syncing }\n   */\n  getStatus() {\n    return {\n      queuedCount: this.tempQueue.length,\n      syncing: this.syncing\n    };\n  }\n\n  /**\n   * Cleanup handlers (call on destroy)\n   */\n  destroy() {\n    // Clear all active handlers\n    for (const [key, handler] of this.activeHandlers.entries()) {\n      this.client.removeEventListener('message:received', handler);\n    }\n    this.activeHandlers.clear();\n\n    // Remove all event listeners\n    this.client = null;\n  }\n}\n\n// Default export for convenience\nexport default NetworkedQueueManager;\n","/**\n * CommandSender - Shared WebSocket Command Utility\n * Eliminates duplicated _sendCommand code across admin modules\n *\n * Pattern: Send gm:command via WebSocket, wait for gm:command:ack\n * Timeout: 5 seconds (configurable)\n *\n * @module admin/utils/CommandSender\n */\n\n/**\n * Send an admin command via WebSocket and wait for acknowledgment\n *\n * @param {Object} connection - OrchestratorClient instance (EventTarget)\n * @param {string} action - Command action (e.g., 'session:create', 'video:play')\n * @param {Object} payload - Command payload data\n * @param {number} [timeout=5000] - Timeout in milliseconds\n * @returns {Promise<Object>} Resolves with response data on success\n * @throws {Error} On timeout or command failure\n *\n * @example\n * // Create a session\n * const response = await sendCommand(connection, 'session:create', { name: 'Game Night', teams: ['001', '002'] });\n *\n * @example\n * // Play video with custom timeout\n * const response = await sendCommand(connection, 'video:play', {}, 10000);\n */\nexport function sendCommand(connection, action, payload, timeout = 5000) {\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      connection.removeEventListener('message:received', ackHandler);\n      reject(new Error(`${action} timeout after ${timeout}ms`));\n    }, timeout);\n\n    // One-time handler for gm:command:ack\n    const ackHandler = (event) => {\n      const { type, payload: response } = event.detail;\n\n      // Only process gm:command:ack events\n      if (type !== 'gm:command:ack') return;\n\n      // Cleanup\n      clearTimeout(timeoutId);\n      connection.removeEventListener('message:received', ackHandler);\n\n      // Check response (response IS the data, already unwrapped by OrchestratorClient)\n      if (response.success) {\n        resolve(response);\n      } else {\n        reject(new Error(response.message || `Command failed: ${action}`));\n      }\n    };\n\n    // Register one-time listener\n    connection.addEventListener('message:received', ackHandler);\n\n    // Send command via OrchestratorClient (uses AsyncAPI envelope wrapper)\n    connection.send('gm:command', {\n      action: action,\n      payload: payload\n    });\n  });\n}\n\n/**\n * Create a bound command sender for a specific connection\n * Useful for modules that send many commands\n *\n * @param {Object} connection - OrchestratorClient instance\n * @returns {Function} Bound sendCommand function\n *\n * @example\n * const send = createCommandSender(this.connection);\n * await send('session:pause', {});\n */\nexport function createCommandSender(connection) {\n  return (action, payload, timeout) => sendCommand(connection, action, payload, timeout);\n}\n\nexport default { sendCommand, createCommandSender };\n","/**\n * SessionManager - Session Lifecycle Management\n * Handles create/pause/resume/end via WebSocket commands\n *\n * User Stories:\n * - GM creates new session with team configuration\n * - GM pauses session during breaks\n * - GM resumes session after breaks\n * - GM ends session when game concludes\n *\n * @module admin/SessionManager\n */\n\nimport { sendCommand } from './utils/CommandSender.js';\n\nexport class SessionManager {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (EventTarget)\n   */\n  constructor(connection) {\n    this.connection = connection;\n    this.currentSession = null;\n\n    // Bind handler for cleanup\n    this._messageHandler = this._handleMessage.bind(this);\n\n    // Listen to session-related broadcasts\n    this.connection.addEventListener('message:received', this._messageHandler);\n  }\n\n  /**\n   * Handle incoming session-related messages\n   * @private\n   */\n  _handleMessage(event) {\n    const { type, payload } = event.detail;\n\n    // Update local session state from broadcasts\n    if (type === 'session:update') {\n      this.currentSession = payload;\n    }\n\n    // Update from sync:full for initial state on connection\n    if (type === 'sync:full' && payload.session) {\n      this.currentSession = payload.session;\n    }\n  }\n\n  /**\n   * Create a new game session\n   * @param {string} name - Session name (e.g., \"Friday Night Game\")\n   * @param {string[]} [teams=[]] - Initial team IDs (teams are typically added dynamically)\n   * @returns {Promise<Object>} Session creation response\n   */\n  async createSession(name, teams = []) {\n    return sendCommand(this.connection, 'session:create', { name, teams });\n  }\n\n  /**\n   * Start the game (transition from setup to active)\n   * Phase 1: Cue Engine integration\n   * @returns {Promise<Object>} Start response\n   */\n  async startGame() {\n    if (!this.currentSession) return;\n    return sendCommand(this.connection, 'session:start', {});\n  }\n\n  /**\n   * Pause the current session\n   * @returns {Promise<Object>} Pause response\n   */\n  async pauseSession() {\n    if (!this.currentSession) return;\n    return sendCommand(this.connection, 'session:pause', {});\n  }\n\n  /**\n   * Resume a paused session\n   * @returns {Promise<Object>} Resume response\n   */\n  async resumeSession() {\n    if (!this.currentSession) return;\n    return sendCommand(this.connection, 'session:resume', {});\n  }\n\n  /**\n   * End the current session\n   * @returns {Promise<Object>} End response\n   */\n  async endSession() {\n    if (!this.currentSession) return;\n    return sendCommand(this.connection, 'session:end', {});\n  }\n\n  /**\n   * Get current session state\n   * @returns {Object|null} Current session or null\n   */\n  getSession() {\n    return this.currentSession;\n  }\n\n  /**\n   * Check if a session is active\n   * @returns {boolean}\n   */\n  isActive() {\n    return this.currentSession?.status === 'active';\n  }\n\n  /**\n   * Check if session is paused\n   * @returns {boolean}\n   */\n  isPaused() {\n    return this.currentSession?.status === 'paused';\n  }\n\n  /**\n   * Cleanup event listeners\n   */\n  destroy() {\n    if (this.connection && this._messageHandler) {\n      this.connection.removeEventListener('message:received', this._messageHandler);\n    }\n  }\n}\n\nexport default SessionManager;\n","/**\n * VideoController - Video Playback Control\n * Manages video queue and playback commands via WebSocket\n *\n * User Stories:\n * - GM plays/pauses/stops/skips video playback\n * - GM adds videos manually to the queue\n * - GM reorders or clears the video queue\n * - GM monitors current video and queue length\n *\n * @module admin/VideoController\n */\n\nimport { sendCommand } from './utils/CommandSender.js';\n\nexport class VideoController {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (EventTarget)\n   */\n  constructor(connection) {\n    this.connection = connection;\n    this.currentVideo = null;\n    this.queueLength = 0;\n  }\n\n  /**\n   * Start or resume video playback\n   * @returns {Promise<Object>} Play response\n   */\n  async playVideo() {\n    return sendCommand(this.connection, 'video:play', {});\n  }\n\n  /**\n   * Pause video playback\n   * @returns {Promise<Object>} Pause response\n   */\n  async pauseVideo() {\n    return sendCommand(this.connection, 'video:pause', {});\n  }\n\n  /**\n   * Stop video playback (returns to idle loop)\n   * @returns {Promise<Object>} Stop response\n   */\n  async stopVideo() {\n    return sendCommand(this.connection, 'video:stop', {});\n  }\n\n  /**\n   * Skip current video and play next in queue\n   * @returns {Promise<Object>} Skip response\n   */\n  async skipVideo() {\n    return sendCommand(this.connection, 'video:skip', {});\n  }\n\n  /**\n   * Add a video to the playback queue\n   * @param {string} videoFile - Video filename (e.g., \"jaw001.mp4\")\n   * @returns {Promise<Object>} Add response\n   */\n  async addToQueue(videoFile) {\n    return sendCommand(this.connection, 'video:queue:add', { videoFile });\n  }\n\n  /**\n   * Reorder videos in the queue\n   * @param {number} fromIndex - Current position\n   * @param {number} toIndex - New position\n   * @returns {Promise<Object>} Reorder response\n   */\n  async reorderQueue(fromIndex, toIndex) {\n    return sendCommand(this.connection, 'video:queue:reorder', { fromIndex, toIndex });\n  }\n\n  /**\n   * Clear all videos from the queue\n   * @returns {Promise<Object>} Clear response\n   */\n  async clearQueue() {\n    return sendCommand(this.connection, 'video:queue:clear', {});\n  }\n\n\n\n  /**\n   * Cleanup (no persistent listeners)\n   */\n  destroy() {\n    // VideoController uses one-time listeners per command via CommandSender\n    // No persistent listeners to cleanup\n  }\n}\n\nexport default VideoController;\n","/**\n * DisplayController - HDMI Display Mode Control\n * Manages display state machine (IDLE_LOOP <-> SCOREBOARD) via WebSocket\n *\n * User Stories:\n * - GM toggles between Idle Loop and Scoreboard\n * - GM sees current display status\n *\n * @module admin/DisplayController\n */\n\nimport { sendCommand } from './utils/CommandSender.js';\n\nexport class DisplayController {\n    /**\n     * @param {Object} connection - OrchestratorClient instance (EventTarget)\n     */\n    constructor(connection) {\n        this.connection = connection;\n    }\n\n    /**\n     * Set display to Idle Loop mode (VLC plays idle-loop.mp4)\n     * @returns {Promise<Object>} Response with { success, mode: 'IDLE_LOOP' }\n     */\n    async setIdleLoop() {\n        return sendCommand(this.connection, 'display:idle-loop', {});\n    }\n\n    /**\n     * Set display to Scoreboard mode (browser shows scoreboard.html)\n     * @returns {Promise<Object>} Response with { success, mode: 'SCOREBOARD' }\n     */\n    async setScoreboard() {\n        return sendCommand(this.connection, 'display:scoreboard', {});\n    }\n\n    /**\n     * Toggle between Idle Loop and Scoreboard modes\n     * @returns {Promise<Object>} Response with { success, mode: 'IDLE_LOOP'|'SCOREBOARD' }\n     */\n    async toggleDisplayMode() {\n        return sendCommand(this.connection, 'display:toggle', {});\n    }\n\n    /**\n     * Get current display status\n     * @returns {Promise<Object>} Response with { currentMode, previousMode, pendingVideo, timestamp }\n     */\n    async getDisplayStatus() {\n        return sendCommand(this.connection, 'display:status', {});\n    }\n\n    /**\n     * Cleanup\n     */\n    destroy() {\n        // No persistent listeners to cleanup\n    }\n}\n\nexport default DisplayController;\n","/**\n * SystemMonitor - Health Monitoring\n * Checks backend and VLC connectivity via HTTP\n *\n * User Stories:\n * - GM monitors orchestrator health status\n * - GM monitors VLC connection status\n * - System displays health indicators in admin panel\n *\n * Note: Uses HTTP fetch (not WebSocket) for health checks\n *\n * @module admin/SystemMonitor\n */\n\nexport class SystemMonitor {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (for config.url)\n   */\n  constructor(connection) {\n    this.connection = connection;\n    this.backendHealth = null;\n    this.vlcHealth = null;\n  }\n\n  /**\n   * Check backend health via HTTP\n   * @returns {Promise<string>} Health status: 'healthy' | 'unhealthy' | 'error'\n   */\n  async checkHealth() {\n    try {\n      const baseUrl = this.connection?.config?.url || 'http://localhost:3000';\n      const response = await fetch(`${baseUrl}/health`);\n      this.backendHealth = response.ok ? 'healthy' : 'unhealthy';\n      return this.backendHealth;\n    } catch (error) {\n      this.backendHealth = 'error';\n      throw error;\n    }\n  }\n\n  /**\n   * Get cached backend health status\n   * @returns {string|null} Last known health status\n   */\n  getBackendHealth() {\n    return this.backendHealth;\n  }\n\n  /**\n   * Get cached VLC health status\n   * @returns {string|null} Last known VLC status\n   */\n  getVlcHealth() {\n    return this.vlcHealth;\n  }\n\n  /**\n   * Update VLC health from sync:full data\n   * @param {string} status - VLC status from backend\n   */\n  setVlcHealth(status) {\n    this.vlcHealth = status;\n  }\n\n  /**\n   * Cleanup (no event listeners)\n   */\n  destroy() {\n    // SystemMonitor uses HTTP fetch only, no WebSocket listeners\n  }\n}\n\nexport default SystemMonitor;\n","/**\n * AdminOperations - System-Level Commands\n * Handles score management, transaction deletion, and system operations\n *\n * User Stories:\n * - GM resets all team scores to zero\n * - GM adjusts individual team scores (add/subtract points)\n * - GM deletes erroneous transactions\n * - GM restarts system or clears data (emergency operations)\n *\n * @module admin/AdminOperations\n */\n\nimport { sendCommand } from './utils/CommandSender.js';\nimport Debug from '../utils/debug.js';\n\nexport class AdminOperations {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (EventTarget)\n   */\n  constructor(connection) {\n    this.connection = connection;\n\n    // Bind handler for cleanup\n    this._messageHandler = this._handleMessage.bind(this);\n\n    // Listen for command acknowledgments and broadcasts\n    this.connection.addEventListener('message:received', this._messageHandler);\n  }\n\n  /**\n   * Handle incoming messages (informational logging)\n   * @private\n   */\n  _handleMessage(event) {\n    const { type } = event.detail;\n\n    // Handle scores:reset broadcast (informational)\n    if (type === 'scores:reset') {\n      Debug.log('[AdminOperations] Scores reset broadcast received');\n      // sync:full will follow automatically\n      // MonitoringDisplay handles the actual UI update\n    }\n  }\n\n  /**\n   * Restart the orchestrator system\n   * @returns {Promise<Object>} Restart response\n   */\n  async restartSystem() {\n    return sendCommand(this.connection, 'system:restart', {});\n  }\n\n  /**\n   * Clear all system data\n   * @returns {Promise<Object>} Clear response\n   */\n  async clearData() {\n    return sendCommand(this.connection, 'system:clear', {});\n  }\n\n  /**\n   * Reset all team scores to zero\n   * @returns {Promise<Object>} Reset response\n   */\n  async resetScores() {\n    return sendCommand(this.connection, 'score:reset', {});\n  }\n\n  /**\n   * Adjust a team's score by a delta amount\n   * @param {string} teamId - Team identifier (e.g., '001', '002')\n   * @param {number} delta - Score adjustment (positive or negative)\n   * @param {string} [reason='Admin adjustment'] - Reason for audit trail\n   * @returns {Promise<Object>} Adjustment response\n   */\n  async adjustScore(teamId, delta, reason = 'Admin adjustment') {\n    return sendCommand(this.connection, 'score:adjust', { teamId, delta, reason });\n  }\n\n  /**\n   * Delete a transaction by ID\n   * Reverses the transaction's score impact and removes from history\n   * @param {string} transactionId - Transaction ID to delete\n   * @returns {Promise<Object>} Deletion response\n   */\n  async deleteTransaction(transactionId) {\n    return sendCommand(this.connection, 'transaction:delete', { transactionId });\n  }\n\n  /**\n   * Cleanup event listeners\n   */\n  destroy() {\n    if (this.connection && this._messageHandler) {\n      this.connection.removeEventListener('message:received', this._messageHandler);\n    }\n  }\n}\n\nexport default AdminOperations;\n","/**\n * CueRenderer - DOM Rendering for Cue System\n * Handles Quick Fire Grid, Standing Cues List, and Active Cues List\n */\n\nexport class CueRenderer {\n  /**\n   * @param {Object} elements - DOM elements map\n   * @param {HTMLElement} [elements.quickFireGrid]\n   * @param {HTMLElement} [elements.standingCuesList]\n   * @param {HTMLElement} [elements.activeCuesList]\n   */\n  constructor(elements = {}) {\n    this.gridEl = elements.quickFireGrid || document.getElementById('quick-fire-grid');\n    this.standingListEl = elements.standingCuesList || document.getElementById('standing-cues-list');\n    this.activeListEl = elements.activeCuesList || document.getElementById('active-cues-list');\n  }\n\n  /**\n   * Render all cue views based on state\n   * @param {Object} state - { cues: Map, activeCues: Set, disabledCues: Set }\n   */\n  render(state) {\n    if (!state || !state.cues) return;\n\n    this._renderQuickFireGrid(state.cues);\n    this._renderStandingCuesList(state.cues, state.disabledCues);\n    this._renderActiveCues(state.cues, state.activeCues);\n  }\n\n  /**\n   * Render Quick Fire grid\n   * @param {Map} cuesMap\n   * @private\n   */\n  _renderQuickFireGrid(cuesMap) {\n    if (!this.gridEl) return;\n\n    const quickFireCues = Array.from(cuesMap.values()).filter(cue => cue.quickFire === true);\n\n    if (quickFireCues.length === 0) {\n      this.gridEl.innerHTML = '<p class=\"empty-state\">No Quick Fire cues available</p>';\n      return;\n    }\n\n    this.gridEl.innerHTML = quickFireCues.map(cue => {\n      const icon = cue.icon || 'default';\n      const label = cue.label || cue.id;\n      return `\n        <button \n          class=\"cue-tile cue-tile--${icon}\" \n          data-action=\"admin.fireCue\" \n          data-cue-id=\"${this._escapeHtml(cue.id)}\"\n          title=\"${this._escapeHtml(label)}\"\n        >\n          <span class=\"cue-tile__icon cue-icon--${icon}\"></span>\n          <span class=\"cue-tile__label\">${this._escapeHtml(label)}</span>\n        </button>\n      `;\n    }).join('');\n  }\n\n  /**\n   * Render Standing Cues list\n   * @param {Map} cuesMap\n   * @param {Set} disabledCuesSet\n   * @private\n   */\n  _renderStandingCuesList(cuesMap, disabledCuesSet) {\n    if (!this.standingListEl) return;\n\n    const standingCues = Array.from(cuesMap.values()).filter(cue => cue.triggerType && !cue.quickFire);\n\n    if (standingCues.length === 0) {\n      this.standingListEl.innerHTML = '<p class=\"empty-state\">No standing cues configured</p>';\n      return;\n    }\n\n    this.standingListEl.innerHTML = standingCues.map(cue => {\n      const isDisabled = disabledCuesSet.has(cue.id) || cue.enabled === false;\n      const statusClass = isDisabled ? 'standing-cue-item--disabled' : 'standing-cue-item--enabled';\n      const triggerLabel = cue.triggerType === 'clock' ? '\\u23F1 clock' : '\\u26A1 event';\n\n      return `\n        <div class=\"standing-cue-item ${statusClass}\">\n          <div class=\"standing-cue-item__info\">\n            <span class=\"standing-cue-item__label\">${this._escapeHtml(cue.label || cue.id)}</span>\n            <span class=\"standing-cue-item__trigger\">${this._escapeHtml(triggerLabel)}</span>\n          </div>\n          <div class=\"standing-cue-item__actions\">\n            ${isDisabled ?\n          `<button class=\"btn btn-sm btn-success\" data-action=\"admin.enableCue\" data-cue-id=\"${this._escapeHtml(cue.id)}\">Enable</button>` :\n          `<button class=\"btn btn-sm btn-secondary\" data-action=\"admin.disableCue\" data-cue-id=\"${this._escapeHtml(cue.id)}\">Disable</button>`\n        }\n          </div>\n        </div>\n      `;\n    }).join('');\n  }\n\n  /**\n   * Render Active Cues list\n   * @param {Map} cuesMap\n   * @param {Map} activeCuesMap\n   */\n  _renderActiveCues(cuesMap, activeCuesMap) {\n    if (!this.activeListEl) return;\n\n    const entries = activeCuesMap instanceof Map ? Array.from(activeCuesMap.entries()) : [];\n\n    if (entries.length === 0) {\n      this.activeListEl.innerHTML = '<p class=\"empty-state\">No active cues</p>';\n      return;\n    }\n\n    this.activeListEl.innerHTML = entries.map(([cueId, details]) => {\n      const { state, progress, duration } = details || { state: 'running', progress: 0, duration: 0 };\n      const progressPercent = Math.round(progress * 100); // Assuming progress 0-1\n      const isPaused = state === 'paused';\n\n      const cueDef = cuesMap.get(cueId);\n      const cueLabel = cueDef ? (cueDef.label || cueDef.name || cueId) : cueId;\n\n      return `\n        <div class=\"active-cue-item\" data-cue-id=\"${this._escapeHtml(cueId)}\">\n          <div class=\"active-cue-item__header\">\n            <span class=\"active-cue-item__label\">${this._escapeHtml(cueLabel)}</span>\n            <span class=\"active-cue-item__state ${isPaused ? 'state-paused' : 'state-running'}\">\n              ${isPaused ? 'Paused' : 'Running'}\n            </span>\n          </div>\n          <div class=\"active-cue-item__progress\">\n            <div class=\"progress-bar\">\n              <div class=\"progress-bar__fill\" style=\"width: ${progressPercent}%\"></div>\n            </div>\n            <span class=\"progress-bar__text\">${progressPercent}%</span>\n          </div>\n          <div class=\"active-cue-item__actions\">\n            ${isPaused ?\n          `<button class=\"btn btn-sm btn-primary\" data-action=\"admin.resumeCue\" data-cue-id=\"${this._escapeHtml(cueId)}\">Resume</button>` :\n          `<button class=\"btn btn-sm btn-secondary\" data-action=\"admin.pauseCue\" data-cue-id=\"${this._escapeHtml(cueId)}\">Pause</button>`\n        }\n            <button class=\"btn btn-sm btn-danger\" data-action=\"admin.stopCue\" data-cue-id=\"${this._escapeHtml(cueId)}\">Stop</button>\n          </div>\n        </div>\n      `;\n    }).join('');\n  }\n\n  _escapeHtml(str) {\n    if (!str) return '';\n    return String(str)\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#039;');\n  }\n\n  /**\n   * Render conflict banner (Phase 2)\n   * @param {Object} payload - {cueId, reason, currentVideo, autoCancelMs}\n   */\n  renderConflict(payload) {\n    const { cueId, reason, currentVideo, autoCancelMs = 10000 } = payload;\n\n    // Use a dedicated container, or fall back to body/toast if needed\n    let container = document.getElementById('cue-conflict-container');\n    if (!container) {\n      console.warn('[CueRenderer] No conflict container found');\n      return;\n    }\n\n    container.innerHTML = `\n          <div class=\"cue-conflict-banner\" data-cue-id=\"${this._escapeHtml(cueId)}\">\n            <div class=\"cue-conflict-banner__info\">\n              <span class=\"cue-conflict-banner__icon\">‚ö†Ô∏è</span>\n              <div class=\"cue-conflict-banner__text\">\n                <strong>Video Conflict</strong>\n                <p>Cue wants to play video, but \"${this._escapeHtml(currentVideo || 'a video')}\" is playing.</p>\n              </div>\n            </div>\n            <div class=\"cue-conflict-banner__actions\">\n              <button class=\"btn btn-sm btn-warning\" data-action=\"admin.resolveConflictCue\" data-decision=\"override\" data-cue-id=\"${this._escapeHtml(cueId)}\">Override</button>\n              <button class=\"btn btn-sm btn-secondary\" data-action=\"admin.resolveConflictCue\" data-decision=\"cancel\" data-cue-id=\"${this._escapeHtml(cueId)}\">Cancel</button>\n            </div>\n            <div class=\"cue-conflict-banner__timer\" style=\"animation-duration: ${autoCancelMs}ms\"></div>\n          </div>\n        `;\n\n    // Auto-dismiss logic should technically be handled by the component or controller, \n    // but for a simple renderer, we can leave it to the CSS animation or the backend auto-cancel event.\n    // However, if we want to remove the element from DOM after timeout, we need logic.\n    // Backend sends 'cue:conflict:resolved' maybe? \n    // Phase 2 plan kept it simple. We'll assume the banner stays until resolved or replaced.\n\n    // Actually, MonitoringDisplay had: auto-dismisses after autoCancelMs.\n    // I should replicate that if possible, or rely on next update.\n    setTimeout(() => {\n      const banner = container.querySelector(`.cue-conflict-banner[data-cue-id=\"${cueId}\"]`);\n      if (banner) banner.remove();\n    }, autoCancelMs);\n  }\n}\n\nexport default CueRenderer;\n","/**\n * EnvironmentRenderer\n * Handles rendering of environment state (Lighting, Audio, Bluetooth) in the Admin Panel.\n *\n * @module ui/renderers/EnvironmentRenderer\n */\n\nexport class EnvironmentRenderer {\n    constructor() {\n        // Lighting Elements\n        this.lightingSection = document.getElementById('lighting-section');\n        this.lightingNotConnected = document.getElementById('lighting-not-connected');\n        this.sceneGrid = document.getElementById('lighting-scenes');\n\n        // Audio Elements\n        this.audioRoutingContainer = document.getElementById('audio-routing-dropdowns');\n        this.btWarning = document.getElementById('bt-warning');\n\n        // Bluetooth Elements\n        this.btDeviceList = document.getElementById('bt-device-list');\n        this.btSpeakerCount = document.getElementById('bt-speaker-count');\n        this.btScanBtn = document.getElementById('btn-bt-scan');\n        this.btScanStatus = document.getElementById('bt-scan-status');\n\n        // Constants\n        this.STREAM_LABELS = {\n            video: 'Video Audio',\n            spotify: 'Spotify Music',\n            sound: 'Sound Effects'\n        };\n    }\n\n    /**\n     * Render the full environment state\n     * @param {Object} state - Environment state object\n     * @param {Object} state.lighting - { connected, activeScene, scenes }\n     * @param {Object} state.audio - { routes, ducking }\n     * @param {Object} state.bluetooth - { scanning, foundedDevices, connectedDevices }\n     */\n    render(state) {\n        if (!state) return;\n\n        if (state.lighting) this.renderLighting(state.lighting);\n        if (state.audio) this.renderAudio(state.audio);\n        if (state.bluetooth) this.renderBluetooth(state.bluetooth);\n    }\n\n    /**\n     * Render Lighting State\n     * @param {Object} lightingState - { connected, activeScene, scenes }\n     */\n    renderLighting(lightingState) {\n        if (!this.lightingSection) return;\n\n        const { connected, activeScene, scenes } = lightingState;\n\n        // Visibility\n        this.lightingSection.style.display = ''; // Show section\n\n        if (!connected) {\n            if (this.lightingNotConnected) this.lightingNotConnected.style.display = 'block';\n            if (this.sceneGrid) this.sceneGrid.style.display = 'none';\n            return;\n        }\n\n        if (this.lightingNotConnected) this.lightingNotConnected.style.display = 'none';\n        if (this.sceneGrid) {\n            this.sceneGrid.style.display = 'grid';\n\n            // Render Grid\n            this.sceneGrid.innerHTML = scenes.map(scene => {\n                const isActive = activeScene && (scene.id === activeScene.id);\n\n                // Escape logic inline for simplicity or helper\n                const safeId = this._escapeHtml(scene.id);\n                const safeName = this._escapeHtml(scene.name);\n\n                return `\n          <button class=\"scene-tile ${isActive ? 'scene-tile--active' : ''}\"\n                  data-scene-id=\"${safeId}\"\n                  data-action=\"admin.activateScene\">\n            ${safeName}\n          </button>\n        `;\n            }).join('');\n        }\n    }\n\n    /**\n     * Render Audio Routing State\n     * @param {Object} audioState - { routes, ducking }\n     * Note: This renderer usually needs the list of available sinks too.\n     * However, payload usually triggers update. If we want to strictly render from state,\n     * we need `availableSinks` which might be static or passed in state.\n     * \n     * UnifiedDataManager.environmentState.audio.routes only has current routes.\n     * We need available sinks to render the dropdown options.\n     * \n     * Strategy: We'll assume the dropdowns are constructed elsewhere OR \n     * we need to fetch available sinks separately. \n     * \n     * Actually, MonitoringDisplay currently constructs dropdowns from `sync:full` payload which includes `availableSinks`.\n     * UnifiedDataManager should probably store `availableSinks` in `environmentState.audio` too.\n     * \n     * For now, we will update the VALUES of existing dropdowns.\n     * If dropdowns don't exist, we can't render them without sink list.\n     * \n     * Let's check if UnifiedDataManager stores availableSinks.\n     * It does NOT currently. It updates routes.\n     * \n     * We will stick to updating values of existing dropdowns for now,\n     * as re-rendering options requires the sink list.\n     */\n    renderAudio(audioState) {\n        const { routes, availableSinks } = audioState;\n\n        // 1. Generate Dropdowns if sinks available\n        if (availableSinks && availableSinks.length > 0 && this.audioRoutingContainer) {\n            // Check if we need to rebuild (e.g. sinks changed or container empty)\n            // For simplicity, we can rebuild if innerHTML is empty, or just always rebuild if sinks provided\n            // To avoid losing focus/state, maybe check if we have dropdowns\n\n            const currentDropdowns = this.audioRoutingContainer.querySelectorAll('select');\n            if (currentDropdowns.length === 0 || this._sinksChanged(availableSinks)) {\n                this._renderAudioDropdowns(availableSinks);\n                this._lastKnownSinks = availableSinks;\n            }\n        }\n\n        // 2. Update Selection Values\n        if (routes) {\n            Object.entries(routes).forEach(([stream, sink]) => {\n                const dropdown = document.querySelector(`select[data-stream=\"${stream}\"]`);\n                if (dropdown) {\n                    dropdown.value = sink;\n                    // If sink doesn't match any option (e.g. 'hdmi' when only 'auto_null' exists),\n                    // value becomes '' ‚Äî fall back to first available option\n                    if (!dropdown.value && dropdown.options.length > 0) {\n                        dropdown.value = dropdown.options[0].value;\n                    }\n                }\n            });\n        }\n\n        // Hide fallback warning if routing looks good (or we clear it)\n        if (this.btWarning) this.btWarning.style.display = 'none';\n    }\n\n    _sinksChanged(newSinks) {\n        if (!this._lastKnownSinks) return true;\n        if (this._lastKnownSinks.length !== newSinks.length) return true;\n        // Simple name check\n        return !newSinks.every((s, i) => s.name === this._lastKnownSinks[i].name);\n    }\n\n    _renderAudioDropdowns(sinks) {\n        if (!this.audioRoutingContainer) return;\n\n        const streams = [\n            { id: 'video', label: this.STREAM_LABELS.video },\n            { id: 'spotify', label: this.STREAM_LABELS.spotify },\n            { id: 'sound', label: this.STREAM_LABELS.sound }\n        ];\n\n        this.audioRoutingContainer.innerHTML = streams.map(stream => `\n            <div class=\"audio-control-item\">\n                <label>${stream.label}</label>\n                <select class=\"form-select\" data-stream=\"${stream.id}\" data-action=\"admin.setAudioRoute\">\n                    ${sinks.map(sink => `\n                        <option value=\"${sink.name}\">${sink.label || sink.description || sink.name}</option>\n                    `).join('')}\n                </select>\n            </div>\n        `).join('');\n    }\n\n    /**\n     * Render Bluetooth State\n     * @param {Object} btState - { scanning, foundedDevices, connectedDevices, pairedDevices }\n     */\n    renderBluetooth(btState) {\n        const { scanning, foundedDevices = [], connectedDevices = [] } = btState;\n\n        // 1. Scan Button State\n        if (this.btScanBtn) {\n            if (scanning) {\n                this.btScanBtn.textContent = 'Stop Scan';\n                this.btScanBtn.dataset.action = 'admin.stopBtScan';\n            } else {\n                this.btScanBtn.textContent = 'Scan for Speakers';\n                this.btScanBtn.dataset.action = 'admin.startBtScan';\n            }\n        }\n\n        if (this.btScanStatus) {\n            this.btScanStatus.style.display = scanning ? 'inline-block' : 'none';\n        }\n\n        // 2. Device List\n        if (this.btDeviceList) {\n            // Merge all relevant devices for display\n            // We prioritize connected, then discovered (founded)\n            // Note: DataManager might not have full paired list unless we sync it. \n            // Assuming connectedDevices and foundedDevices are the main source for now.\n\n            const allDevices = [];\n\n            // 1. Add connected devices\n            connectedDevices.forEach(d => {\n                allDevices.push({ ...d, status: 'connected' });\n            });\n\n            // 2. Add paired devices (that are not already connected)\n            if (btState.pairedDevices) {\n                btState.pairedDevices.forEach(d => {\n                    const isConnected = allDevices.some(ad => ad.address === d.address);\n                    if (!isConnected) {\n                        allDevices.push({ ...d, status: 'paired' });\n                    }\n                });\n            }\n\n            // 3. Add discovered (founded) devices\n            // Only add if not already in list (as connected or paired)\n            foundedDevices.forEach(d => {\n                const isKnown = allDevices.some(ad => ad.address === d.address);\n                if (!isKnown) {\n                    allDevices.push({ ...d, status: 'discovered' });\n                }\n            });\n\n            if (allDevices.length === 0) {\n                this.btDeviceList.innerHTML = '<p class=\"empty-state\">No devices found</p>';\n            } else {\n                this.btDeviceList.innerHTML = allDevices.map(d => this._renderDeviceItem(d)).join('');\n            }\n\n            // 3. Count\n            if (this.btSpeakerCount) {\n                this.btSpeakerCount.textContent = allDevices.length > 0 ? String(allDevices.length) : '';\n            }\n        }\n    }\n\n    _renderDeviceItem(device) {\n        const safeName = this._escapeHtml(device.name || device.address);\n        const safeAddress = this._escapeHtml(device.address);\n        const isConnected = device.status === 'connected';\n        const isPaired = device.status === 'paired' || isConnected; // Connected implies paired usually\n\n        // Status classes\n        let itemClass = 'bt-device-item';\n        if (isConnected) itemClass += ' bt-device-item--connected';\n        else if (isPaired) itemClass += ' bt-device-item--paired';\n\n        // Action button calculation\n        let actionBtn = '';\n        if (isConnected) {\n            actionBtn = `\n                <span class=\"bt-device-status status-connected\">Connected</span>\n                <button class=\"btn btn-xs btn-outline-danger\"\n                        data-action=\"admin.disconnectBtDevice\"\n                        data-bt-address=\"${safeAddress}\">\n                    Disconnect\n                </button>\n            `;\n        } else if (isPaired) {\n            // Paired but not connected -> Show Connect button\n            actionBtn = `\n                <button class=\"btn btn-xs btn-primary\" \n                        data-action=\"admin.connectBtDevice\" \n                        data-bt-address=\"${safeAddress}\">\n                    Connect\n                </button>\n            `;\n        } else {\n            // Discovered (Unpaired) -> Pair button\n            actionBtn = `\n                <button class=\"btn btn-xs btn-outline\" \n                        data-action=\"admin.pairBtDevice\" \n                        data-bt-address=\"${safeAddress}\">\n                    Pair\n                </button>\n            `;\n        }\n\n        return `\n      <div class=\"${itemClass}\" data-bt-address=\"${safeAddress}\">\n        <div class=\"bt-device-info\">\n            <span class=\"bt-device-name\">${safeName}</span>\n            <span class=\"bt-device-mac\">${safeAddress}</span>\n        </div>\n        <div class=\"bt-device-actions\">\n            ${actionBtn}\n        </div>\n      </div>\n    `;\n    }\n\n    _escapeHtml(str) {\n        if (!str) return '';\n        return String(str)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#039;');\n    }\n}\n","/**\n * SessionRenderer\n * Handles rendering of session status, team lists, and game clock.\n *\n * @module ui/renderers/SessionRenderer\n */\n\nexport class SessionRenderer {\n    constructor() {\n        this.container = document.getElementById('session-status-container');\n        this.lastStatus = null;\n    }\n\n    /**\n     * Render session state\n     * @param {Object} sessionState - { name, status, startTime, endTime, teams }\n     */\n    render(sessionState) {\n        if (!this.container) return;\n\n        // Determine generalized state for template selection\n        // 'no-session' | 'setup' | 'active' | 'paused' | 'ended'\n        let viewState = 'no-session';\n        if (sessionState) {\n            viewState = sessionState.status || 'setup';\n        }\n\n        // Only re-render DOM structure if state type changed\n        if (this.lastStatus !== viewState) {\n            this.container.innerHTML = this._getTemplate(viewState, sessionState);\n            this.lastStatus = viewState;\n        }\n\n        // Update dynamic values (Name, Time, etc.)\n        // We query strictly here to ensure we get the fresh elements\n        const nameEl = document.getElementById('session-name');\n        const statusEl = document.getElementById('session-status-badge');\n\n        if (sessionState) {\n            if (nameEl) nameEl.textContent = sessionState.name || 'Untitled Session';\n\n            if (statusEl) {\n                if (sessionState.status === 'active') {\n                    statusEl.textContent = 'Active';\n                    statusEl.className = 'badge badge-success';\n                } else if (sessionState.status === 'paused') {\n                    statusEl.textContent = 'Paused';\n                    statusEl.className = 'badge badge-warning';\n                } else if (sessionState.status === 'ended') {\n                    statusEl.textContent = 'Ended';\n                    statusEl.className = 'badge badge-danger';\n                } else {\n                    statusEl.textContent = sessionState.status || 'Offline';\n                    statusEl.className = 'badge';\n                }\n            }\n        }\n    }\n\n    /**\n     * Render Game Clock\n     * @param {Object} clockState - { state, elapsed }\n     */\n    renderGameClock(clockState) {\n        const display = document.getElementById('game-clock-display');\n        if (!display) return;\n\n        const { state, elapsed } = clockState;\n        const formattedTime = this._formatClockTime(elapsed);\n\n        display.textContent = formattedTime;\n\n        // Update styling\n        display.classList.remove('clock-running', 'clock-paused', 'clock-stopped');\n        display.classList.add(`clock-${state}`);\n    }\n\n    /**\n     * Render Overtime Warning\n     * @param {Object} overtimeData - { actualDuration, expectedDuration }\n     */\n    renderOvertime(overtimeData) {\n        const container = document.getElementById('session-overtime-container');\n        const text = document.getElementById('session-overtime-text');\n\n        if (!container || !text) return;\n\n        if (overtimeData && overtimeData.overtimeDuration > 0) {\n            container.style.display = 'block';\n            text.textContent = `+${Math.round(overtimeData.overtimeDuration)}m`;\n        } else {\n            container.style.display = 'none';\n        }\n    }\n\n    _formatClockTime(seconds) {\n        if (seconds === undefined || seconds === null) return '--:--';\n        const m = Math.floor(seconds / 60);\n        const s = Math.floor(seconds % 60);\n        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;\n    }\n\n    /**\n     * Get HTML Template based on state\n     */\n    _getTemplate(viewState, session) {\n        const sessionName = session?.name || 'New Session';\n\n        // 1. No Session\n        if (viewState === 'no-session') {\n            return `\n                <div class=\"session-status session-status--empty\">\n                    <div class=\"session-info\">\n                        <h4>No Active Session</h4>\n                        <p>Create a session to start tracking games.</p>\n                    </div>\n                    <div class=\"session-controls\">\n                        <button class=\"btn btn-primary\" data-action=\"app.adminCreateSession\">\n                            Create New Session\n                        </button>\n                    </div>\n                </div>\n            `;\n        }\n\n        // 2. Setup (Created but not started)\n        if (viewState === 'setup') {\n            return `\n                <div class=\"session-status session-status--setup\">\n                    <div class=\"session-header\">\n                        <h4 id=\"session-name\">${sessionName}</h4>\n                        <span id=\"session-status-badge\" class=\"badge\">Setup</span>\n                    </div>\n                    <div class=\"session-body\">\n                         <div id=\"game-clock-container\" class=\"clock-container\">\n                            <span id=\"game-clock-display\" class=\"clock-display\">00:00</span>\n                        </div>\n                    </div>\n                    <div class=\"session-controls\">\n                        <button class=\"btn btn-success\" data-action=\"admin.startGame\">Start Game</button>\n                        <button class=\"btn btn-danger\" data-action=\"app.adminEndSession\">End Session</button>\n                    </div>\n                </div>\n            `;\n        }\n\n        // 3. Active / Running\n        if (viewState === 'active') {\n            return `\n                <div class=\"session-status session-status--active\">\n                    <div class=\"session-header\">\n                        <h4 id=\"session-name\">${sessionName}</h4>\n                        <span id=\"session-status-badge\" class=\"badge badge-success\">Active</span>\n                    </div>\n                    <div class=\"session-body\">\n                        <div id=\"game-clock-container\" class=\"clock-container\">\n                            <span id=\"game-clock-display\" class=\"clock-display\">--:--</span>\n                        </div>\n                        <div id=\"session-overtime-container\" style=\"display:none; color: #ffc107; font-weight: bold; margin-top: 5px;\">\n                            Overtime: <span id=\"session-overtime-text\"></span>\n                        </div>\n                    </div>\n                    <div class=\"session-controls\">\n                        <button class=\"btn btn-warning\" data-action=\"app.adminPauseSession\">Pause</button>\n                        <button class=\"btn btn-danger\" data-action=\"app.adminEndSession\">End Session</button>\n                    </div>\n                </div>\n            `;\n        }\n\n        // 4. Paused\n        if (viewState === 'paused') {\n            return `\n                <div class=\"session-status session-status--paused\">\n                    <div class=\"session-header\">\n                        <h4 id=\"session-name\">${sessionName}</h4>\n                        <span id=\"session-status-badge\" class=\"badge badge-warning\">Paused</span>\n                    </div>\n                    <div class=\"session-body\">\n                         <div id=\"game-clock-container\" class=\"clock-container\">\n                            <span id=\"game-clock-display\" class=\"clock-display\">--:--</span>\n                        </div>\n                    </div>\n                    <div class=\"session-controls\">\n                        <button class=\"btn btn-success\" data-action=\"app.adminResumeSession\">Resume</button>\n                        <button class=\"btn btn-danger\" data-action=\"app.adminEndSession\">End Session</button>\n                    </div>\n                </div>\n            `;\n        }\n\n        // 5. Ended\n        if (viewState === 'ended') {\n            return `\n                <div class=\"session-status session-status--ended\">\n                     <div class=\"session-header\">\n                        <h4 id=\"session-name\">${sessionName}</h4>\n                        <span id=\"session-status-badge\" class=\"badge badge-danger\">Ended</span>\n                    </div>\n                     <div class=\"session-body\">\n                        <p>Session completed.</p>\n                     </div>\n                    <div class=\"session-controls\">\n                        <button class=\"btn btn-primary\" data-action=\"app.adminResetAndCreateNew\">\n                            Reset & New Session\n                        </button>\n                    </div>\n                </div>\n            `;\n        }\n\n        return `<div>Unknown State: ${viewState}</div>`;\n    }\n}\n","/**\n * VideoRenderer\n * Handles rendering of video playback state in the Admin Panel.\n *\n * @module ui/renderers/VideoRenderer\n */\n\nexport class VideoRenderer {\n    constructor() {\n        this.container = document.getElementById('video-control-panel');\n        this.nowPlayingEl = document.getElementById('now-showing-value');\n        this.nowPlayingIcon = document.getElementById('now-showing-icon');\n        this.statusBadge = document.getElementById('video-status-badge');\n        this.progressContainer = document.getElementById('video-progress-container');\n        this.progressBar = document.getElementById('video-progress-fill');\n        this.queueContainer = document.getElementById('video-queue-list');\n    }\n\n    /**\n     * Render the current video state\n     * @param {Object} state - Video state object\n     * @param {string|null} state.nowPlaying - Filename or null\n     * @param {boolean} state.isPlaying - True if playing\n     * @param {number} state.progress - 0.0 to 1.0\n     * @param {number} state.duration - Duration in seconds\n     */\n    render(state) {\n        if (!this.nowPlayingEl) return; // Guard against missing DOM\n\n        const { nowPlaying, isPlaying, progress } = state;\n\n        // 1. Update Now Playing Text\n        if (nowPlaying) {\n            this.nowPlayingEl.textContent = nowPlaying;\n            if (this.nowPlayingIcon) this.nowPlayingIcon.textContent = isPlaying ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';\n        } else {\n            this.nowPlayingEl.textContent = 'Idle Loop';\n            if (this.nowPlayingIcon) this.nowPlayingIcon.textContent = 'üîÑ';\n        }\n\n        // 2. Update Status Badge\n        if (this.statusBadge) {\n            if (isPlaying) {\n                this.statusBadge.textContent = 'Playing';\n                this.statusBadge.className = 'badge badge-success';\n            } else {\n                this.statusBadge.textContent = 'Idle';\n                this.statusBadge.className = 'badge';\n            }\n        }\n\n        // 3. Update Progress Bar\n        if (this.progressContainer && this.progressBar) {\n            if (isPlaying) {\n                this.progressContainer.style.display = 'block';\n                const percent = Math.min(100, Math.max(0, progress * 100));\n                this.progressBar.style.width = `${percent}%`;\n            } else {\n                this.progressContainer.style.display = 'none';\n                this.progressBar.style.width = '0%';\n            }\n        }\n    }\n\n    /**\n     * Render the video queue\n     * @param {Array} queueItems - Array of { tokenId, duration, ... }\n     */\n    renderQueue(queueItems) {\n        if (!this.queueContainer) return;\n\n        if (!queueItems || queueItems.length === 0) {\n            this.queueContainer.innerHTML = '<div class=\"empty-state\">Queue empty</div>';\n            this._updateQueueCount(0);\n            return;\n        }\n\n        this.queueContainer.innerHTML = queueItems.map(item => `\n            <div class=\"queue-item\">\n                <span class=\"queue-item__token\">${item.tokenId}</span>\n                <span class=\"queue-item__duration\">${Math.round(item.duration || 0)}s</span>\n            </div>\n        `).join('');\n\n        this._updateQueueCount(queueItems.length);\n    }\n\n    _updateQueueCount(count) {\n        const countEl = document.getElementById('queue-count');\n        const pendingCountEl = document.getElementById('pending-queue-count');\n        if (countEl) countEl.textContent = count;\n        if (pendingCountEl) pendingCountEl.textContent = count;\n    }\n}\n","import Debug from '../utils/debug.js';\nimport { CueRenderer } from '../ui/renderers/CueRenderer.js';\nimport { EnvironmentRenderer } from '../ui/renderers/EnvironmentRenderer.js';\nimport { SessionRenderer } from '../ui/renderers/SessionRenderer.js';\nimport { VideoRenderer } from '../ui/renderers/VideoRenderer.js';\n\nexport class MonitoringDisplay {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (EventTarget)\n   * @param {Object} dataManager - DataManager instance for cross-view data sync\n   * @param {Object} teamRegistry - TeamRegistry instance for team dropdown sync (optional)\n   */\n  constructor(client, dataManager, teamRegistry = null) {\n    this.client = client;\n    this.dataManager = dataManager;\n    this.teamRegistry = teamRegistry;\n    this.devices = [];\n    this._currentIdleMode = 'IDLE_LOOP';\n\n    // Renderers\n    this.cueRenderer = new CueRenderer();\n    this.envRenderer = new EnvironmentRenderer();\n    this.sessionRenderer = new SessionRenderer();\n    this.videoRenderer = new VideoRenderer();\n\n    // Bind handler for cleanup\n    this._messageHandler = this._handleMessage.bind(this);\n    this.client.addEventListener('message:received', this._messageHandler);\n\n    // Wire Up DataManager Events\n    this._wireDataManagerEvents();\n\n    // Request initial state\n    this._requestInitialState();\n  }\n\n  /**\n   * Wire DataManager events to Renderers\n   * @private\n   */\n  _wireDataManagerEvents() {\n    // Cue State\n    this.dataManager.addEventListener('cue-state:updated', (e) => this.cueRenderer.render(e.detail));\n    this.dataManager.addEventListener('cue:conflict', (e) => this.cueRenderer.renderConflict(e.detail));\n\n    // Environment State\n    this.dataManager.addEventListener('lighting-state:updated', (e) => this.envRenderer.renderLighting(e.detail.lighting));\n    this.dataManager.addEventListener('audio-state:updated', (e) => this.envRenderer.renderAudio(e.detail.audio));\n    this.dataManager.addEventListener('bluetooth-state:updated', (e) => this.envRenderer.renderBluetooth(e.detail.bluetooth));\n\n    // Session State\n    this.dataManager.addEventListener('session-state:updated', (e) => {\n      this.sessionRenderer.render(e.detail.session);\n      // Team Registry sync still needed for dropdowns elsewhere\n      if (this.teamRegistry) {\n        this.teamRegistry.populateFromSession(e.detail.session);\n      }\n    });\n\n    // Game Clock (if managed via DM, otherwise direct event)\n    // Currently gameclock is direct event. We should port it to DM later?\n    // For now, handle via _handleMessage -> DM -> Event or Direct.\n    // Let's stick to Direct for clock since it's high freq?\n    // Actually, consistency says convert to DM event.\n    // But DM doesn't have gameClockState yet in my impl. \n    // So I will keep direct clock handling in _handleMessage but delegate to SessionRenderer.\n  }\n\n  /**\n   * Request initial state from backend\n   * @private\n   */\n  _requestInitialState() {\n    if (this.client?.socket?.connected) {\n      this.client.socket.emit('sync:request');\n      console.log('[MonitoringDisplay] Requested initial state via sync:request');\n    }\n  }\n\n  _sendMessage(type, payload) {\n    if (this.client?.socket?.connected) {\n      this.client.socket.emit(type, payload);\n    }\n  }\n\n  /**\n   * Handle incoming WebSocket messages\n   * @private\n   */\n  _handleMessage(event) {\n    const { type, payload } = event.detail;\n\n    Debug.log(`[MonitoringDisplay] _handleMessage: ${type}`);\n\n    switch (type) {\n      // --- Session & System ---\n      case 'session:update':\n      case 'session:overtime':\n        // DM handles state update, which triggers renderer. \n        // Overtime is distinct.\n        if (type === 'session:overtime') {\n          this.sessionRenderer.renderOvertime(payload);\n        }\n        break;\n\n      case 'sync:full':\n        this.updateAllDisplays(payload);\n        break;\n\n      case 'gameclock:status':\n        this.sessionRenderer.renderGameClock(payload);\n        break;\n\n      case 'device:connected':\n      case 'device:disconnected':\n        this._updateDeviceList(payload, type);\n        break;\n\n      // --- Renderers handled via DataManager Events ---\n      // lighting:*, audio:*, bluetooth:*, cue:* -> Handled by NetworkedSession -> DM -> Event -> Renderer\n\n      // --- Toast / Ephemeral Notifications ---\n      case 'cue:fired':\n        this.showToast(`Cue fired: ${payload.cueId}`, 'info', 3000);\n        break;\n\n      case 'cue:error':\n        this.showToast(`Cue error: ${payload.cueId} ‚Äî ${payload.error || payload.action}`, 'error', 5000);\n        break;\n\n      case 'cue:conflict':\n        this.showToast(\n          `Cue conflict: ${payload.cueId} ‚Äî ${payload.reason || 'Video conflict'}`,\n          'warning',\n          10000\n        );\n        break;\n\n      case 'sound:status':\n        // Informational only ‚Äî no-op for now\n        break;\n\n      // --- Legacy / Unrefactored ---\n      case 'transaction:new':\n      case 'transaction:deleted':\n        this._updateTransactionLog(payload, type);\n        break;\n\n      case 'display:mode':\n        this._handleDisplayMode(payload);\n        break;\n\n      case 'video:status':\n        this._handleVideoStatus(payload);\n        break;\n\n      case 'audio:routing:fallback':\n        this._handleAudioFallback(payload);\n        break;\n\n      case 'video:queue:update':\n        this.updateQueueDisplay(payload);\n        break;\n\n      case 'spotify:status': // Still legacy render\n        this._renderNowPlaying(payload);\n        break;\n    }\n  }\n\n  // ============================================\n  // LEGACY / AD-HOC HANDLERS (To be refactored in Phase 4)\n  // ============================================\n\n  _updateDeviceList(payload, type) {\n    // Simple local list management for now\n    // Phase 4: Move Connected Devices to DM\n    if (type === 'device:connected') {\n      const idx = this.devices.findIndex(d => d.deviceId === payload.deviceId);\n      if (idx === -1) this.devices.push(payload);\n    } else {\n      this.devices = this.devices.filter(d => d.deviceId !== payload.deviceId);\n    }\n\n    this._renderDeviceList();\n  }\n\n  _updateTransactionLog(payload, type) {\n    const transaction = payload.transaction || (type === 'transaction:deleted' ? payload : null);\n    if (!transaction) return;\n\n    const log = document.getElementById('admin-transaction-log');\n    if (!log) return;\n\n    if (type === 'transaction:deleted') {\n      const el = log.querySelector(`[data-transaction-id=\"${payload.transactionId}\"]`);\n      if (el) el.remove();\n      return;\n    }\n\n    // Add new\n    const txTime = transaction.timestamp ? new Date(transaction.timestamp).toLocaleTimeString() : '-';\n    const html = `\n        <div class=\"transaction-item\" data-transaction-id=\"${transaction.id}\">\n            <span class=\"tx-time\">${txTime}</span>\n            <span class=\"tx-team\">${transaction.teamId}</span>\n            <span class=\"tx-token\">${transaction.tokenId}</span>\n            <span class=\"tx-type\">${transaction.memoryType || 'UNKNOWN'}</span>\n        </div>`;\n    log.insertAdjacentHTML('afterbegin', html);\n\n    // Limit to 10\n    while (log.children.length > 10) log.lastElementChild.remove();\n  }\n\n  _handleDisplayMode(payload) {\n    this._currentIdleMode = payload.mode;\n\n    const nowShowingVal = document.getElementById('now-showing-value');\n    const nowShowingIcon = document.getElementById('now-showing-icon');\n    const btnIdle = document.getElementById('btn-idle-loop');\n    const btnScore = document.getElementById('btn-scoreboard');\n\n    if (payload.mode === 'SCOREBOARD') {\n      if (nowShowingVal) nowShowingVal.textContent = 'Scoreboard';\n      if (nowShowingIcon) nowShowingIcon.textContent = 'üèÜ';\n    } else {\n      if (nowShowingVal) nowShowingVal.textContent = 'Idle Loop';\n      if (nowShowingIcon) nowShowingIcon.textContent = 'üîÑ';\n    }\n\n    if (btnIdle) btnIdle.classList.toggle('active', payload.mode === 'IDLE_LOOP');\n    if (btnScore) btnScore.classList.toggle('active', payload.mode === 'SCOREBOARD');\n  }\n\n  _handleVideoStatus(payload) {\n    const nowShowingVal = document.getElementById('now-showing-value');\n    const nowShowingIcon = document.getElementById('now-showing-icon');\n    const returnsContainer = document.getElementById('returns-to-container');\n    const returnsMode = document.getElementById('returns-to-mode');\n    const pendingCount = document.getElementById('pending-queue-count');\n\n    if (payload.status === 'playing' && payload.tokenId) {\n      if (nowShowingVal) nowShowingVal.textContent = `${payload.tokenId}.mp4`;\n      if (nowShowingIcon) nowShowingIcon.textContent = '‚ñ∂Ô∏è';\n      if (returnsContainer) returnsContainer.style.display = 'block';\n      if (returnsMode) {\n        returnsMode.textContent = this._currentIdleMode === 'SCOREBOARD' ? 'Scoreboard' : 'Idle Loop';\n      }\n    } else {\n      // Restore idle mode display\n      const mode = this._currentIdleMode || 'IDLE_LOOP';\n      if (nowShowingVal) nowShowingVal.textContent = mode === 'SCOREBOARD' ? 'Scoreboard' : 'Idle Loop';\n      if (nowShowingIcon) nowShowingIcon.textContent = mode === 'SCOREBOARD' ? 'üèÜ' : 'üîÑ';\n      if (returnsContainer) returnsContainer.style.display = 'none';\n    }\n\n    if (pendingCount && payload.queueLength !== undefined) {\n      pendingCount.textContent = String(payload.queueLength);\n    }\n  }\n\n  _handleAudioFallback(payload) {\n    if (!payload) return;\n    const btWarning = document.getElementById('bt-warning');\n    if (btWarning) {\n      btWarning.style.display = 'block';\n      btWarning.textContent = payload.reason || 'Audio route fallback';\n    }\n    // Update dropdown to show fallback sink\n    if (payload.stream && payload.sink) {\n      const dropdown = document.querySelector(`select[data-stream=\"${payload.stream}\"]`);\n      if (dropdown) dropdown.value = payload.sink;\n    }\n  }\n\n  updateQueueDisplay(payload) {\n    if (this.videoRenderer) {\n      this.videoRenderer.renderQueue(payload.items || []);\n    }\n  }\n\n  _renderNowPlaying(spotifyState) {\n    // Legacy Spotify Render\n    const section = document.getElementById('now-playing-section');\n    if (!section) return;\n\n    if (!spotifyState || !spotifyState.connected) {\n      section.innerHTML = '<div class=\"now-playing--disconnected\">Spotify Disconnected</div>';\n      return;\n    }\n\n    const isPlaying = spotifyState.state === 'playing';\n    const playPauseBtn = isPlaying\n      ? '<button class=\"btn btn-sm btn-icon\" data-action=\"admin.spotifyPause\" title=\"Pause\">&#10074;&#10074;</button>'\n      : '<button class=\"btn btn-sm btn-icon\" data-action=\"admin.spotifyPlay\" title=\"Play\">&#9654;</button>';\n\n    section.innerHTML = `\n        <div class=\"now-playing--connected\">\n            <div class=\"now-playing__track\">\n                <strong>${spotifyState.track?.title || ''}</strong>\n                <span>${spotifyState.track?.artist || ''}</span>\n            </div>\n            <div class=\"now-playing__controls\">\n                <button class=\"btn btn-sm btn-icon\" data-action=\"admin.spotifyPrevious\" title=\"Previous\">&#9664;&#9664;</button>\n                ${playPauseBtn}\n                <button class=\"btn btn-sm btn-icon\" data-action=\"admin.spotifyNext\" title=\"Next\">&#9654;&#9654;</button>\n            </div>\n        </div>`;\n  }\n\n  // Load available videos helper (kept)\n  loadAvailableVideos() {\n    // ... implementation matches previous ...\n  }\n  // ============================================\n  // AGGREGATE UPDATE METHODS\n  // ============================================\n\n  /**\n   * Initialize all displays from sync:full event\n   * NOTE: DataManager state updates (resetForNewSession, setScannedTokensFromServer)\n   * are handled by NetworkedSession global listener\n   * \n   * This method now delegates PURELY to Renderers for UI updates.\n   */\n  updateAllDisplays(syncData) {\n    if (!syncData) return;\n\n    Debug.log('[MonitoringDisplay] updateAllDisplays (Sync Full)', syncData);\n\n    // 1. Session State\n    // Always render session state, even if null (to show \"Create Session\" button)\n    this.sessionRenderer.render(syncData.session || null);\n\n    // 2. Team Registry (Logic)\n    if (syncData.session && this.teamRegistry) {\n      this.teamRegistry.populateFromSession(syncData.session);\n    }\n\n    // 3. Environment State ‚Äî handled by NetworkedSession ‚Üí DataManager ‚Üí event ‚Üí renderer\n    // NetworkedSession.sync:full handler already calls:\n    //   dataManager.updateAudioState(), updateLightingState(), updateBluetoothState()\n    // which trigger events ‚Üí MonitoringDisplay._wireDataManagerEvents() ‚Üí renderers\n    // No direct rendering needed here.\n\n    // 4. Cue Engine (Phase 1 & 2)\n    if (syncData.cueEngine && syncData.cueEngine.loaded) {\n      this.cueRenderer.render({\n        cues: new Map((syncData.cueEngine.cues || []).map(c => [c.id, c])),\n        activeCues: new Map((syncData.cueEngine.activeCues || []).map(c => [c.cueId, c])),\n        disabledCues: new Set(syncData.cueEngine.disabledCues || [])\n      });\n    }\n\n    // 5. Game Clock\n    if (syncData.gameClock) {\n      this.sessionRenderer.renderGameClock({\n        state: syncData.gameClock.status,\n        elapsed: syncData.gameClock.elapsed\n      });\n    }\n\n    // 6. Spotify\n    if (syncData.spotify) {\n      this._renderNowPlaying(syncData.spotify);\n    }\n\n    // 7. System Status\n    this.updateSystemDisplay();\n    if (syncData.systemStatus?.vlc) {\n      const vlcElem = document.getElementById('vlc-status');\n      if (vlcElem) {\n        vlcElem.className = `status-dot status-dot--${syncData.systemStatus.vlc}`;\n      }\n    }\n\n    // 8. Legacy / Phase 4 TODOs\n    if (syncData.recentTransactions) {\n      // Clear and rebuild log\n      const log = document.getElementById('admin-transaction-log');\n      if (log) log.innerHTML = '';\n      syncData.recentTransactions.slice(-10).reverse().forEach(tx => this._updateTransactionLog({ transaction: tx }, 'transaction:new'));\n    }\n    if (syncData.devices) {\n      this._setDeviceList(syncData.devices);\n    }\n  }\n\n  /**\n   * Set the full list of connected devices\n   * @param {Array} devices\n   * @private\n   */\n  _setDeviceList(devices) {\n    if (!devices) return;\n    this.devices = [...devices];\n\n    // DRY: reuse the rendering logic from _updateDeviceList\n    // Ideally we should extract the rendering to a separate method, \n    // but for this fix we'll just duplicate the render block or call a render method.\n    this._renderDeviceList();\n  }\n\n  _renderDeviceList() {\n    const countEl = document.getElementById('device-count');\n    const listEl = document.getElementById('device-list');\n\n    if (countEl) countEl.textContent = String(this.devices.length);\n    if (listEl) {\n      if (this.devices.length === 0) listEl.innerHTML = '<p class=\"text-muted text-sm\">No devices</p>';\n      else listEl.innerHTML = this.devices.map(d => `\n            <div class=\"device-item\"><span>${d.deviceId}</span><span class=\"device-type\">${d.type}</span></div>\n         `).join('');\n    }\n  }\n\n\n  /**\n   * Manually refresh all displays from cached data\n   */\n  refreshAllDisplays() {\n    Debug.log('[MonitoringDisplay] refreshAllDisplays called');\n    this.updateSystemDisplay();\n    this.loadAvailableVideos();\n    this._requestInitialState();\n  }\n\n  /**\n   * Resume monitoring (socket reconnected)\n   */\n  resume() {\n    console.log('[MonitoringDisplay] Resuming monitoring...');\n    this._requestInitialState();\n  }\n\n  // ============================================\n  // UTILITY METHODS\n  // ============================================\n\n  updateSystemDisplay() {\n    if (!this.client) return;\n    const orchestratorElem = document.getElementById('orchestrator-status');\n    if (orchestratorElem) {\n      const status = this.client.isConnected ? 'connected' : 'disconnected';\n      orchestratorElem.className = `status-dot status-dot--${status}`;\n      orchestratorElem.title = status;\n    }\n  }\n\n  escapeHtml(text) {\n    if (!text) return '';\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n\n  formatClockTime(secondsSeconds) {\n    // Delegate to SessionRenderer static-like logic or keep redundancy for now?\n    // Keeping redundancy for legacy calls within this file, but generally prefer renderer\n    if (secondsSeconds === null || secondsSeconds === undefined || secondsSeconds < 0) return '00:00:00';\n    const totalSeconds = Math.floor(secondsSeconds);\n    const h = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');\n    const m = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');\n    const s = String(totalSeconds % 60).padStart(2, '0');\n    return `${h}:${m}:${s}`;\n  }\n\n  showToast(message, type = 'info', duration = 3000) {\n    // Keep toast logic\n    const colors = {\n      error: 'var(--color-accent-danger, #dc3545)',\n      success: 'var(--color-accent-success, #28a745)',\n      warning: 'var(--color-accent-warning, #ffc107)',\n      info: 'var(--color-accent-info, #007bff)'\n    };\n    const toast = document.createElement('div');\n    toast.className = `toast toast-${type}`;\n    toast.textContent = message;\n    toast.style.cssText = `\n        position: fixed; top: 20px; right: 20px; padding: 12px 20px;\n        background: ${colors[type] || colors.info}; color: white;\n        border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 10000;\n      `;\n    document.body.appendChild(toast);\n    setTimeout(() => toast.remove(), duration);\n  }\n\n  destroy() {\n    if (this.client && this._messageHandler) {\n      this.client.removeEventListener('message:received', this._messageHandler);\n    }\n  }\n} // End Class MonitoringDisplay\n","/**\n * BluetoothController - Bluetooth Device Control\n * Manages Bluetooth scanning, pairing, and connection commands via WebSocket\n *\n * User Stories:\n * - GM scans for nearby Bluetooth speakers\n * - GM pairs/unpairs Bluetooth audio devices\n * - GM connects/disconnects Bluetooth devices for audio output\n *\n * @module admin/BluetoothController\n */\n\nimport { sendCommand } from './utils/CommandSender.js';\n\nexport class BluetoothController {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (EventTarget)\n   */\n  constructor(connection) {\n    this.connection = connection;\n  }\n\n  /**\n   * Start scanning for nearby Bluetooth devices\n   * @param {number} [timeout] - Optional scan timeout in milliseconds\n   * @returns {Promise<Object>} Scan response with discovered devices\n   */\n  async startScan(timeout) {\n    return sendCommand(this.connection, 'bluetooth:scan:start', timeout ? { timeout } : {});\n  }\n\n  /**\n   * Stop an in-progress Bluetooth scan\n   * @returns {Promise<Object>} Stop response\n   */\n  async stopScan() {\n    return sendCommand(this.connection, 'bluetooth:scan:stop', {});\n  }\n\n  /**\n   * Pair with a Bluetooth device\n   * @param {string} address - Bluetooth MAC address (e.g., \"AA:BB:CC:DD:EE:FF\")\n   * @returns {Promise<Object>} Pair response\n   */\n  async pairDevice(address) {\n    // Backend pairing can take up to 22s (10s connect + 12s scan buffer)\n    // We use 45s to be safe\n    return sendCommand(this.connection, 'bluetooth:pair', { address }, 45000);\n  }\n\n  /**\n   * Unpair a previously paired Bluetooth device\n   * @param {string} address - Bluetooth MAC address\n   * @returns {Promise<Object>} Unpair response\n   */\n  async unpairDevice(address) {\n    return sendCommand(this.connection, 'bluetooth:unpair', { address }, 15000);\n  }\n\n  /**\n   * Connect to a paired Bluetooth device\n   * @param {string} address - Bluetooth MAC address\n   * @returns {Promise<Object>} Connect response\n   */\n  async connectDevice(address) {\n    // Backend connect uses 10s timeout by default\n    // We use 30s to be safe\n    return sendCommand(this.connection, 'bluetooth:connect', { address }, 30000);\n  }\n\n  /**\n   * Disconnect from a connected Bluetooth device\n   * @param {string} address - Bluetooth MAC address\n   * @returns {Promise<Object>} Disconnect response\n   */\n  async disconnectDevice(address) {\n    return sendCommand(this.connection, 'bluetooth:disconnect', { address }, 15000);\n  }\n\n  /**\n   * Cleanup (no persistent listeners)\n   */\n  destroy() {\n    // BluetoothController uses one-time listeners per command via CommandSender\n    // No persistent listeners to cleanup\n  }\n}\n\nexport default BluetoothController;\n","/**\n * AudioController - Audio Routing Control\n * Manages per-stream audio output routing commands via WebSocket\n *\n * User Stories:\n * - GM routes video audio output to a specific PipeWire sink\n * - GM routes Spotify music to a specific PipeWire sink\n * - GM routes sound effects to a specific PipeWire sink\n *\n * Phase 3: Per-stream routing (video, spotify, sound)\n *\n * @module admin/AudioController\n */\n\nimport { sendCommand } from './utils/CommandSender.js';\n\nexport class AudioController {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (EventTarget)\n   */\n  constructor(connection) {\n    this.connection = connection;\n  }\n\n  /**\n   * Set audio output for a stream\n   * @param {string} sink - PipeWire sink name (e.g., 'bluez_output.AA_BB_CC_DD_EE_FF.1', 'hdmi', 'combine-bt')\n   * @param {string} [stream='video'] - Stream identifier ('video', 'spotify', 'sound')\n   * @returns {Promise<Object>} Route set response\n   */\n  async setVideoOutput(sink, stream = 'video') {\n    return sendCommand(this.connection, 'audio:route:set', { stream, sink });\n  }\n\n  /**\n   * Cleanup (no persistent listeners)\n   */\n  destroy() {\n    // AudioController uses one-time listeners per command via CommandSender\n    // No persistent listeners to cleanup\n  }\n}\n\nexport default AudioController;\n","/**\n * LightingController - Home Assistant Lighting/Scene Control\n * Manages scene activation and discovery via WebSocket commands to backend\n *\n * User Stories:\n * - GM activates a Home Assistant scene (e.g., dramatic red, blackout)\n * - GM refreshes the list of available scenes from Home Assistant\n *\n * @module admin/LightingController\n */\n\nimport { sendCommand } from './utils/CommandSender.js';\n\nexport class LightingController {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (EventTarget)\n   */\n  constructor(connection) {\n    this.connection = connection;\n  }\n\n  /**\n   * Activate a Home Assistant scene\n   * @param {string} sceneId - Scene entity ID (e.g., 'scene.dramatic_red')\n   * @returns {Promise<Object>} Activation response\n   */\n  async activateScene(sceneId) {\n    return sendCommand(this.connection, 'lighting:scene:activate', { sceneId });\n  }\n\n  /**\n   * Refresh available scenes from Home Assistant\n   * @returns {Promise<Object>} Refresh response with updated scenes list\n   */\n  async refreshScenes() {\n    return sendCommand(this.connection, 'lighting:scenes:refresh', {});\n  }\n\n  /**\n   * Cleanup (no persistent listeners)\n   */\n  destroy() {\n    // LightingController uses one-time listeners per command via CommandSender\n    // No persistent listeners to cleanup\n  }\n}\n\nexport default LightingController;\n","/**\n * CueController - Cue Engine Control\n * Manages cue firing and enable/disable commands via WebSocket\n *\n * User Stories:\n * - GM fires a Quick Fire cue (pre-scripted sound/light sequence)\n * - GM enables/disables standing cues (event-driven triggers)\n *\n * @module admin/CueController\n */\n\nimport { sendCommand } from './utils/CommandSender.js';\n\nexport class CueController {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (EventTarget)\n   */\n  constructor(connection) {\n    this.connection = connection;\n  }\n\n  /**\n   * Fire a cue (trigger its action sequence)\n   * @param {string} cueId - Cue identifier (e.g., 'tension-hit')\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async fireCue(cueId, timeout = 5000) {\n    return sendCommand(this.connection, 'cue:fire', { cueId }, timeout);\n  }\n\n  /**\n   * Enable a standing cue (allow it to respond to triggers)\n   * @param {string} cueId - Cue identifier\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async enableCue(cueId, timeout = 5000) {\n    return sendCommand(this.connection, 'cue:enable', { cueId }, timeout);\n  }\n\n  /**\n   * Disable a standing cue (prevent it from responding to triggers)\n   * @param {string} cueId - Cue identifier\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async disableCue(cueId, timeout = 5000) {\n    return sendCommand(this.connection, 'cue:disable', { cueId }, timeout);\n  }\n\n  /**\n   * Pause a running compound cue (Phase 2)\n   * @param {string} cueId - Cue identifier\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async pauseCue(cueId, timeout = 5000) {\n    return sendCommand(this.connection, 'cue:pause', { cueId }, timeout);\n  }\n\n  /**\n   * Stop a running compound cue (Phase 2)\n   * @param {string} cueId - Cue identifier\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async stopCue(cueId, timeout = 5000) {\n    return sendCommand(this.connection, 'cue:stop', { cueId }, timeout);\n  }\n\n  /**\n   * Resume a paused compound cue (Phase 2)\n   * @param {string} cueId - Cue identifier\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async resumeCue(cueId, timeout = 5000) {\n    return sendCommand(this.connection, 'cue:resume', { cueId }, timeout);\n  }\n\n  /**\n   * Resolve a video conflict for a pending compound cue (Phase 2)\n   * @param {string} cueId - Conflicted cue identifier\n   * @param {string} decision - 'override' (stop video, start cue) or 'cancel' (discard cue)\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async resolveConflict(cueId, decision, timeout = 5000) {\n    return sendCommand(this.connection, 'cue:conflict:resolve', { cueId, decision }, timeout);\n  }\n\n  /**\n   * Cleanup (no persistent listeners)\n   */\n  destroy() {\n    // CueController uses one-time listeners per command via CommandSender\n    // No persistent listeners to cleanup\n  }\n}\n\nexport default CueController;\n","/**\n * SoundController - Sound Playback Control\n * Manages sound playback commands via WebSocket\n *\n * User Stories:\n * - GM plays a sound effect on a specific target (e.g., 'sound:spot1')\n * - GM stops a playing sound effect\n * - GM stops all playing sounds\n *\n * @module admin/SoundController\n */\n\nimport { sendCommand } from './utils/CommandSender.js';\n\nexport class SoundController {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (EventTarget)\n   */\n  constructor(connection) {\n    this.connection = connection;\n  }\n\n  /**\n   * Play a sound effect\n   * @param {string} file - Sound file path (relative to backend's sounds directory)\n   * @param {string} [target] - Optional target identifier (e.g., 'sound:spot1')\n   * @param {number} [volume] - Optional volume level (0-100)\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async playSound(file, target = null, volume = null, timeout = 5000) {\n    const payload = { file };\n    if (target !== null) payload.target = target;\n    if (volume !== null) payload.volume = volume;\n\n    return sendCommand(this.connection, 'sound:play', payload, timeout);\n  }\n\n  /**\n   * Stop a specific playing sound or all sounds\n   * @param {string} [file] - Optional file path to stop specific sound (omit to stop all)\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async stopSound(file = null, timeout = 5000) {\n    const payload = file !== null ? { file } : {};\n    return sendCommand(this.connection, 'sound:stop', payload, timeout);\n  }\n\n  /**\n   * Cleanup (no persistent listeners)\n   */\n  destroy() {\n    // SoundController uses one-time listeners per command via CommandSender\n    // No persistent listeners to cleanup\n  }\n}\n\nexport default SoundController;\n","/**\n * SpotifyController - Spotify Playback Control\n * Manages Spotify commands via WebSocket\n *\n * User Stories:\n * - GM plays/pauses/stops Spotify playback during the game\n * - GM switches between Act 1/2/3 playlists\n * - GM adjusts Spotify volume independently from other audio\n * - GM verifies cache status of offline playlists\n *\n * @module admin/SpotifyController\n */\n\nimport { sendCommand } from './utils/CommandSender.js';\n\nexport class SpotifyController {\n  /**\n   * @param {Object} connection - OrchestratorClient instance (EventTarget)\n   */\n  constructor(connection) {\n    this.connection = connection;\n  }\n\n  /**\n   * Play Spotify\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async play(timeout = 5000) {\n    return sendCommand(this.connection, 'spotify:play', {}, timeout);\n  }\n\n  /**\n   * Pause Spotify\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async pause(timeout = 5000) {\n    return sendCommand(this.connection, 'spotify:pause', {}, timeout);\n  }\n\n  /**\n   * Stop Spotify\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async stop(timeout = 5000) {\n    return sendCommand(this.connection, 'spotify:stop', {}, timeout);\n  }\n\n  /**\n   * Next track\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async next(timeout = 5000) {\n    return sendCommand(this.connection, 'spotify:next', {}, timeout);\n  }\n\n  /**\n   * Previous track\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async previous(timeout = 5000) {\n    return sendCommand(this.connection, 'spotify:previous', {}, timeout);\n  }\n\n  /**\n   * Set active playlist\n   * @param {string} uri - Spotify playlist URI (e.g., 'spotify:playlist:act2')\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async setPlaylist(uri, timeout = 5000) {\n    return sendCommand(this.connection, 'spotify:playlist', { uri }, timeout);\n  }\n\n  /**\n   * Set Spotify volume\n   * @param {number} volume - Volume level (0-100)\n   * @param {number} [timeout=5000] - Command timeout in milliseconds\n   * @returns {Promise<Object>} Command acknowledgment\n   */\n  async setVolume(volume, timeout = 5000) {\n    return sendCommand(this.connection, 'spotify:volume', { volume }, timeout);\n  }\n\n  /**\n   * Verify cache status of offline playlists\n   * @param {number} [timeout=10000] - Command timeout in milliseconds (longer for cache checks)\n   * @returns {Promise<Object>} Command acknowledgment with cache status\n   */\n  async verifyCacheStatus(timeout = 10000) {\n    return sendCommand(this.connection, 'spotify:cache:verify', {}, timeout);\n  }\n\n  /**\n   * Cleanup (no persistent listeners)\n   */\n  destroy() {\n    // SpotifyController uses one-time listeners per command via CommandSender\n    // No persistent listeners to cleanup\n  }\n}\n\nexport default SpotifyController;\n","/**\n * AdminController - Admin Module Lifecycle Manager\n * ES6 Module - Browser Only\n *\n * Responsibilities:\n * - Creates all admin modules once\n * - Guards against re-initialization\n * - Coordinates pause/resume on connection state changes\n * - Clean module destruction\n *\n * Does NOT handle:\n * - Connection state (ConnectionManager)\n * - WebSocket messages (OrchestratorClient)\n * - Token management (ConnectionManager)\n */\n\nimport { SessionManager } from '../admin/SessionManager.js';\nimport { VideoController } from '../admin/VideoController.js';\nimport { DisplayController } from '../admin/DisplayController.js';\nimport { SystemMonitor } from '../admin/SystemMonitor.js';\nimport { AdminOperations } from '../admin/AdminOperations.js';\nimport { MonitoringDisplay } from '../admin/MonitoringDisplay.js';\nimport { BluetoothController } from '../admin/BluetoothController.js';\nimport { AudioController } from '../admin/AudioController.js';\nimport { LightingController } from '../admin/LightingController.js';\nimport { CueController } from '../admin/CueController.js';\nimport { SoundController } from '../admin/SoundController.js';\nimport { SpotifyController } from '../admin/SpotifyController.js';\n\nexport class AdminController extends EventTarget {\n  constructor(client, dataManager, teamRegistry = null) {\n    super();\n    this.client = client; // OrchestratorClient reference for admin modules to use\n    this.dataManager = dataManager; // DataManager reference for MonitoringDisplay\n    this.teamRegistry = teamRegistry; // TeamRegistry for team dropdown sync\n    this.modules = null;\n    this.initialized = false;\n  }\n\n  /**\n   * Initialize all admin modules\n   * Guards against re-initialization\n   * @emits initialized - Admin modules ready\n   */\n  initialize() {\n    // Guard against re-initialization\n    if (this.initialized) {\n      console.warn('AdminController: Already initialized');\n      return;\n    }\n\n    // Create all admin modules with dependency injection\n    this.modules = {\n      sessionManager: new SessionManager(this.client),\n      videoController: new VideoController(this.client),\n      displayController: new DisplayController(this.client),\n      systemMonitor: new SystemMonitor(this.client),\n      adminOperations: new AdminOperations(this.client),\n      monitoringDisplay: new MonitoringDisplay(this.client, this.dataManager, this.teamRegistry),\n      bluetoothController: new BluetoothController(this.client),\n      audioController: new AudioController(this.client),\n      lightingController: new LightingController(this.client),\n      cueController: new CueController(this.client),\n      soundController: new SoundController(this.client),\n      spotifyController: new SpotifyController(this.client)\n    };\n\n    this.initialized = true;\n    this.dispatchEvent(new CustomEvent('initialized'));\n  }\n\n  /**\n   * Get specific admin module\n   * @param {string} name - Module name (sessionManager, videoController, systemMonitor, etc.)\n   * @returns {Object} Module instance\n   * @throws {Error} If not initialized\n   */\n  getModule(name) {\n    if (!this.initialized) {\n      throw new Error('Admin modules not initialized');\n    }\n\n    if (!this.modules[name]) {\n      throw new Error(`Unknown module: ${name}`);\n    }\n\n    return this.modules[name];\n  }\n\n  /**\n   * Pause admin operations (called on disconnect)\n   */\n  pause() {\n    if (!this.modules) return;\n\n    // Pause modules that support pausing\n    if (this.modules.sessionManager?.pause) {\n      this.modules.sessionManager.pause();\n    }\n    if (this.modules.videoController?.pause) {\n      this.modules.videoController.pause();\n    }\n  }\n\n  /**\n   * Resume admin operations (called on reconnect)\n   */\n  resume() {\n    if (!this.modules) return;\n\n    // Resume modules that support resuming\n    if (this.modules.sessionManager?.resume) {\n      this.modules.sessionManager.resume();\n    }\n    if (this.modules.videoController?.resume) {\n      this.modules.videoController.resume();\n    }\n    if (this.modules.monitoringDisplay?.resume) {\n      this.modules.monitoringDisplay.resume();\n    }\n  }\n\n  /**\n   * Destroy all admin modules\n   */\n  destroy() {\n    // Graceful cleanup - no error if not initialized\n    if (!this.modules) return;\n\n    // Destroy all modules\n    Object.values(this.modules).forEach(module => {\n      if (module?.destroy) {\n        module.destroy();\n      }\n    });\n\n    this.modules = null;\n    this.initialized = false;\n  }\n}\n\n// Named and default exports\nexport default AdminController;\n","/**\n * NetworkedSession - Service Factory and Lifecycle Orchestrator\n * ES6 Module - Browser Only\n *\n * Responsibilities:\n * - Creates all networked services in correct order\n * - Wires event-driven coordination between services\n * - Manages complete session lifecycle (initialize, destroy)\n * - Single source of truth for service references\n *\n * Does NOT handle:\n * - WebSocket details (OrchestratorClient)\n * - Token validation (ConnectionManager)\n * - Retry logic (ConnectionManager)\n * - Admin UI operations (AdminController)\n */\n\nimport OrchestratorClient from './orchestratorClient.js';\nimport ConnectionManager from './connectionManager.js';\nimport NetworkedQueueManager from './networkedQueueManager.js';\nimport AdminController from '../app/adminController.js';\n\nexport class NetworkedSession extends EventTarget {\n  constructor(config, dataManager, teamRegistry = null) {\n    super();\n    this.config = config; // { url, deviceId, stationName, token }\n    this.dataManager = dataManager; // DataManager reference for AdminController\n    this.teamRegistry = teamRegistry; // TeamRegistry for team dropdown sync\n    this.services = null;\n    this.state = 'disconnected'; // disconnected, connecting, connected, error\n  }\n\n  /**\n   * Initialize session - creates services, wires events, initiates connection\n   * @returns {Promise<void>}\n   * @throws {Error} If initialization fails\n   * @emits session:ready - All services initialized and connected\n   * @emits session:error - Initialization failed\n   */\n  async initialize() {\n    if (this.services) {\n      throw new Error('Session already initialized');\n    }\n\n    try {\n      this._createServices();\n      this._wireEventHandlers();\n      await this._initiateConnection();\n\n      this.state = 'connected';\n      this.dispatchEvent(new CustomEvent('session:ready', {\n        detail: { services: this.services },\n      }));\n    } catch (error) {\n      this.state = 'error';\n\n      // CRITICAL: Cleanup on initialization failure\n      // Prevents event listener leaks and zombie services\n      await this.destroy();\n\n      this.dispatchEvent(new CustomEvent('session:error', {\n        detail: { error },\n      }));\n      throw error;\n    }\n  }\n\n  /**\n   * Get a service by name\n   * @param {string} name - Service name (connectionManager, client, queueManager, adminController)\n   * @returns {Object} Service instance\n   * @throws {Error} If session not initialized\n   */\n  getService(name) {\n    if (!this.services) {\n      throw new Error('Session not initialized');\n    }\n\n    if (!this.services[name]) {\n      throw new Error(`Unknown service: ${name}`);\n    }\n\n    return this.services[name];\n  }\n\n  /**\n   * Destroy session - cleanup all services in reverse order\n   * @returns {Promise<void>}\n   */\n  async destroy() {\n    // Graceful cleanup - no error if not initialized\n    if (!this.services) return;\n\n    // Destroy in reverse order (LIFO)\n    if (this.services.adminController) {\n      this.services.adminController.destroy();\n    }\n\n    if (this.services.queueManager) {\n      this.services.queueManager.destroy();\n    }\n\n    if (this.services.connectionManager) {\n      // Remove event listeners first\n      if (this._connectedHandler) {\n        this.services.connectionManager.removeEventListener('connected', this._connectedHandler);\n      }\n      if (this._disconnectedHandler) {\n        this.services.connectionManager.removeEventListener('disconnected', this._disconnectedHandler);\n      }\n      if (this._authRequiredHandler) {\n        this.services.connectionManager.removeEventListener('auth:required', this._authRequiredHandler);\n      }\n\n      await this.services.connectionManager.disconnect();\n    }\n\n    if (this.services.client) {\n      // Remove message handler first\n      if (this._messageHandler) {\n        this.services.client.removeEventListener('message:received', this._messageHandler);\n      }\n      this.services.client.destroy();\n    }\n\n    this.services = null;\n    this.state = 'disconnected';\n  }\n\n  /**\n   * Create all services in correct order\n   * @private\n   */\n  _createServices() {\n    // Create services in dependency order\n    this.services = {};\n\n    // 1. OrchestratorClient (no dependencies)\n    this.services.client = new OrchestratorClient({\n      url: this.config.url,\n      deviceId: this.config.deviceId,\n    });\n\n    // 2. ConnectionManager (depends on client)\n    this.services.connectionManager = new ConnectionManager({\n      url: this.config.url,\n      deviceId: this.config.deviceId,\n      token: this.config.token,\n      client: this.services.client,\n    });\n\n    // 3. NetworkedQueueManager (depends on client)\n    this.services.queueManager = new NetworkedQueueManager({\n      client: this.services.client,\n      deviceId: this.config.deviceId,\n      debug: console\n    });\n\n    // 4. AdminController (depends on client, dataManager, and teamRegistry)\n    this.services.adminController = new AdminController(this.services.client, this.dataManager, this.teamRegistry);\n  }\n\n  /**\n   * Wire event handlers between services\n   * @private\n   */\n  _wireEventHandlers() {\n    // Store handler references for cleanup\n    this._connectedHandler = () => {\n      // On connection: initialize admin and sync queue\n      if (this.services.adminController) {\n        this.services.adminController.initialize();\n      }\n      if (this.services.queueManager) {\n        this.services.queueManager.syncQueue();\n      }\n    };\n\n    this._disconnectedHandler = () => {\n      // On disconnection: pause admin operations\n      if (this.services.adminController) {\n        this.services.adminController.pause();\n      }\n    };\n\n    this._authRequiredHandler = () => {\n      // Forward auth:required event to session listeners\n      this.dispatchEvent(new CustomEvent('auth:required'));\n    };\n\n    // Global WebSocket ‚Üí DataManager event handler\n    // Updates state for ALL WebSocket events, regardless of active screen/view\n    this._messageHandler = (event) => {\n      const { type, payload } = event.detail;\n\n      switch (type) {\n        case 'score:updated':\n          this.dataManager.updateTeamScoreFromBackend(payload);\n          break;\n\n        case 'sync:full':\n          // Session boundary detection (DRY: same logic as session:update)\n          this._handleSessionBoundary(payload.session?.id);\n\n          // Restore scanned tokens from server state (handles reconnection)\n          if (payload.deviceScannedTokens) {\n            this.dataManager.setScannedTokensFromServer(payload.deviceScannedTokens);\n          }\n\n          // Sync scores and transactions\n          if (payload.scores) {\n            payload.scores.forEach(s => this.dataManager.updateTeamScoreFromBackend(s));\n          }\n          if (payload.recentTransactions) {\n            payload.recentTransactions.forEach(tx => this.dataManager.addTransaction(tx));\n          }\n\n          // Sync player scans from server (Game Activity feature)\n          if (payload.playerScans) {\n            this.dataManager.setPlayerScansFromServer(payload.playerScans);\n          }\n\n          // Update Session State (Phase 3)\n          // Only update if session field is explicitly present in payload.\n          // A missing session field (e.g. from a partial sync:full after score reset)\n          // should NOT null out an active session ‚Äî that's a different semantic than\n          // an explicit session: null (server restart with no active session).\n          if (payload.session) {\n            this.dataManager.updateSessionState(payload.session);\n          } else if ('session' in payload && payload.session === null) {\n            this.dataManager.updateSessionState(null);\n          }\n\n          // Update Environment State (Phase 3)\n          if (payload.environment) {\n            if (payload.environment.audio) this.dataManager.updateAudioState(payload.environment.audio);\n            if (payload.environment.lighting) this.dataManager.updateLightingState(payload.environment.lighting);\n            if (payload.environment.bluetooth) this.dataManager.updateBluetoothState(payload.environment.bluetooth);\n          }\n          break;\n\n        case 'session:update':\n          // Session lifecycle: detect boundary changes\n          if (payload.status === 'ended') {\n            this.dataManager.resetForNewSession(null);\n          } else {\n            this._handleSessionBoundary(payload.id);\n          }\n          // Update session state for UI (SessionRenderer)\n          this.dataManager.updateSessionState(payload);\n          break;\n\n        case 'transaction:new':\n          if (payload.transaction) {\n            // Use addTransactionFromBroadcast to store without re-submitting to backend\n            this.dataManager.addTransactionFromBroadcast(payload.transaction);\n          }\n          break;\n\n        case 'transaction:deleted':\n          if (payload.transactionId) {\n            this.dataManager.removeTransaction(payload.transactionId);\n          }\n          break;\n\n        case 'scores:reset':\n          this.dataManager.clearBackendScores();\n          break;\n\n        case 'player:scan':\n          // Player scanner activity - forward to DataManager for Game Activity tracking\n          this.dataManager.handlePlayerScan(payload);\n          break;\n\n        case 'group:completed':\n          this.dispatchEvent(new CustomEvent('group:completed', {\n            detail: payload\n          }));\n          break;\n\n        // Phase 1: Video State Routing\n        case 'video:status':\n        case 'video:progress':\n          this.dataManager.updateVideoState(payload);\n          break;\n\n        // Phase 2: Cue State Routing\n        case 'cue:fired':\n          this.dataManager.updateCueStatus({ cueId: payload.cueId, state: 'running' });\n          break;\n        case 'cue:completed':\n          this.dataManager.updateCueStatus({ cueId: payload.cueId, state: 'completed' });\n          break;\n        case 'cue:error':\n          this.dataManager.updateCueStatus({ cueId: payload.cueId, state: 'error' });\n          break;\n        case 'cue:status':\n          // payload includes { cueId, state, progress, duration }\n          this.dataManager.updateCueStatus(payload);\n          break;\n        case 'cue:conflict':\n          this.dataManager.handleCueConflict(payload);\n          break;\n\n        // Phase 3: Environment State Routing\n        case 'lighting:scene':\n        case 'lighting:status':\n          this.dataManager.updateLightingState(payload);\n          break;\n\n        case 'audio:routing':\n          // payload includes { stream, sink }\n          this.dataManager.updateAudioState(payload);\n          break;\n        case 'audio:routing:fallback':\n          // BT speaker dropped ‚Äî audio fell back to HDMI\n          this.dataManager.updateAudioState(payload);\n          break;\n        case 'audio:ducking:status':\n          // payload includes { stream, ducked, volume }\n          this.dataManager.updateAudioDucking(payload);\n          break;\n\n        case 'audio:sinks':\n          // Sink list changed (BT speaker connect/disconnect) ‚Äî refresh dropdown\n          if (payload.availableSinks) {\n            this.dataManager.updateAudioState({ availableSinks: payload.availableSinks });\n          }\n          break;\n\n        case 'bluetooth:scan':\n          // payload: { scanning: boolean }\n          this.dataManager.updateBluetoothScan(payload);\n          break;\n        case 'bluetooth:device':\n          // payload: { type: 'connected'|'disconnected'|'discovered', device }\n          this.dataManager.updateBluetoothDevice(payload);\n          break;\n\n        case 'sound:status':\n          // Sound effect playback status (started/completed/stopped)\n          this.dispatchEvent(new CustomEvent('sound:status', {\n            detail: payload\n          }));\n          break;\n      }\n    };\n\n    // Wire events\n    this.services.connectionManager.addEventListener('connected', this._connectedHandler);\n    this.services.connectionManager.addEventListener('disconnected', this._disconnectedHandler);\n    this.services.connectionManager.addEventListener('auth:required', this._authRequiredHandler);\n    this.services.client.addEventListener('message:received', this._messageHandler);\n  }\n\n  /**\n   * Handle session boundary detection (DRY helper)\n   * Resets DataManager only when session ID actually changes\n   * @param {string|null} newSessionId - New session ID from server\n   * @private\n   */\n  _handleSessionBoundary(newSessionId) {\n    const currentSessionId = this.dataManager.currentSessionId;\n\n    // Only reset when session ID actually changes (new session started)\n    if (newSessionId && newSessionId !== currentSessionId) {\n      this.dataManager.resetForNewSession(newSessionId);\n    }\n  }\n\n  /**\n   * Initiate connection via ConnectionManager\n   * @private\n   */\n  async _initiateConnection() {\n    await this.services.connectionManager.connect();\n  }\n}\n\nexport default NetworkedSession;\n","/**\n * App - Main Application Controller\n * ES6 Module\n *\n * Main application coordinator that handles:\n * - NFC processing pipeline\n * - Mode-specific initialization (networked vs standalone)\n * - Admin panel integration\n * - Event wiring between all modules\n * - Team management and transaction processing\n */\n\nimport Debug from '../utils/debug.js';\nimport { isTokenValid } from '../utils/jwtUtils.js';\nimport UIManager from '../ui/uiManager.js';\nimport Settings from '../ui/settings.js';\nimport TokenManager from '../core/tokenManager.js';\nimport NFCHandler from '../utils/nfcHandler.js';\nimport CONFIG from '../utils/config.js';\nimport InitializationSteps from './initializationSteps.js';\nimport { SessionModeManager } from './sessionModeManager.js'; // Import class, not singleton\nimport NetworkedSession from '../network/networkedSession.js';\n\n/**\n * Main Application Class\n * Coordinates all modules and handles user interaction\n *\n * Architecture: Dependency Injection + Event-Driven\n * - Dependencies injected via constructor for testability\n * - Session services received via session:ready event.detail\n * - No window.XXX global reaching (per Architecture Refactoring 2025-11)\n */\nclass App {\n  constructor(dependencies = {}) {\n    // Core dependencies (injected for testing, defaults for production)\n    this.debug = dependencies.debug || Debug;\n    this.uiManager = dependencies.uiManager || UIManager;\n    this.settings = dependencies.settings || Settings;\n    this.tokenManager = dependencies.tokenManager || TokenManager;\n    this.dataManager = dependencies.dataManager; // Required: inject via main.js\n    this.teamRegistry = dependencies.teamRegistry || null;\n    this.nfcHandler = dependencies.nfcHandler || NFCHandler;\n    this.config = dependencies.config || CONFIG;\n    this.initializationSteps = dependencies.initializationSteps || InitializationSteps;\n\n    // Session dependencies (injected after mode selection)\n    this.sessionModeManager = dependencies.sessionModeManager || null;\n    this.networkedSession = dependencies.networkedSession || null;\n\n    // Global reference for HTML onclick handlers (temporary until Phase 6)\n    this.showConnectionWizard = dependencies.showConnectionWizard || (typeof window !== 'undefined' ? window.showConnectionWizard : null);\n\n    // Instance state\n    this.currentTeamId = '';\n    this.nfcSupported = false;\n    this.currentInterventionTeamId = null; // For GM intervention features\n    this.viewController = this._createViewController();\n  }\n\n  /**\n   * Initialize application\n   * Runs 11-phase initialization sequence\n   */\n  async init() {\n    this.debug.log('App initializing...');\n\n    // Initialize UI (Phase 1D) - MUST be before showLoadingScreen\n    this.initializationSteps.initializeUIManager(this.uiManager);\n\n    // Show loading screen after UIManager initialized (Phase 0)\n    await this.initializationSteps.showLoadingScreen(this.uiManager);\n\n    // CRITICAL: Initialize SessionModeManager BEFORE viewController (Phase 1E)\n    // Store reference as instance property (no window global assignment)\n    this.sessionModeManager = this.initializationSteps.createSessionModeManager(SessionModeManager);\n\n    // Inject sessionModeManager and app into UIManager\n    // This allows UIManager to access session mode for rendering decisions\n    this.uiManager.sessionModeManager = this.sessionModeManager;\n    this.uiManager.app = this;\n\n    // Initialize view controller (Phase 1F)\n    this.initializationSteps.initializeViewController(this.viewController);\n\n    // Load settings (Phase 1G)\n    this.initializationSteps.loadSettings(this.settings);\n\n    // Load transaction history (Phase 1H)\n    this.initializationSteps.loadDataManager(this.dataManager, this.uiManager);\n\n    // Check NFC support (Phase 1I)\n    this.nfcSupported = await this.initializationSteps.detectNFCSupport(this.nfcHandler);\n\n    // Load token database (Phase 1A)\n    await this.initializationSteps.loadTokenDatabase(this.tokenManager, this.uiManager);\n\n    // Apply URL parameter mode override (Phase 1B)\n    this.initializationSteps.applyURLModeOverride(window.location.search, this.settings);\n\n    // Register service worker for PWA functionality (Phase 1J)\n    await this.initializationSteps.registerServiceWorker(navigator, this.uiManager);\n\n    // Connection restoration logic with full state validation (Phase 1C + Phase 4.1)\n    // Use validateAndDetermineInitialScreen for networked mode validation:\n    // - Validates JWT token expiration\n    // - Validates orchestrator reachability\n    // - Validates session exists\n    // If any validation fails, clears stale state and shows mode selection\n    const screenDecision = await this.initializationSteps.validateAndDetermineInitialScreen(this.sessionModeManager);\n\n    // Log validation result if present\n    if (screenDecision.validationResult) {\n      if (screenDecision.validationResult.valid) {\n        this.debug.log('[App] State validation passed - proceeding with auto-connect');\n      } else {\n        this.debug.log(`[App] State validation failed: ${screenDecision.validationResult.reason}`);\n      }\n    }\n\n    await this.initializationSteps.applyInitialScreenDecision(\n      screenDecision,\n      this.sessionModeManager,\n      this.uiManager,\n      this.showConnectionWizard,\n      this._initializeNetworkedMode.bind(this)\n    );\n  }\n\n  /**\n   * Wire event listeners for NetworkedSession lifecycle\n   * Event-driven architecture: Services provided via event.detail\n   * @private\n   */\n  _wireNetworkedSessionEvents() {\n    if (!this.networkedSession) {\n      this.debug.log('Cannot wire networked session events: session is null');\n      return;\n    }\n\n    this.networkedSession.addEventListener('session:ready', () => {\n      this.debug.log('NetworkedSession ready - initializing admin modules');\n      if (this.viewController) {\n        this.viewController.initAdminModules();\n      }\n    });\n\n    // Listen for auth:required from NetworkedSession\n    this.networkedSession.addEventListener('auth:required', () => {\n      this.debug.log('Authentication required - showing connection wizard');\n      if (this.showConnectionWizard) {\n        this.showConnectionWizard();\n      }\n    });\n\n    this.networkedSession.addEventListener('group:completed', (event) => {\n      const { teamId, bonus } = event.detail || {};\n      const formattedBonus = bonus ? ` +$${bonus.toLocaleString()}` : '';\n      this.uiManager.showToast(`Group completed by ${teamId || 'team'}${formattedBonus}`);\n    });\n  }\n\n  /**\n   * Create view controller\n   * Manages scanner/admin/debug view switching in networked mode\n   * @private\n   */\n  _createViewController() {\n    const app = this;\n\n    return {\n      currentView: 'scanner',\n      views: ['scanner', 'admin', 'debug'],\n      adminInstances: null,\n\n      init() {\n        // Show view selector tabs in BOTH networked and standalone modes\n        // Phase 3: Admin panel is now available in standalone mode\n        const viewSelector = document.getElementById('viewSelector');\n        if (viewSelector) {\n          viewSelector.style.display = 'flex';\n        }\n\n        // Admin modules (WebSocket-based) only initialized in networked mode\n        // Standalone admin operations use dataManager directly\n      },\n\n      switchView(viewName) {\n        if (!this.views.includes(viewName)) {\n          console.error('Invalid view:', viewName);\n          app.uiManager.showError(`Invalid view: ${viewName}`);\n          return;\n        }\n\n        // Hide all view contents\n        document.querySelectorAll('.view-content').forEach(view => {\n          view.style.display = 'none';\n        });\n\n        // Show selected view\n        const selectedView = document.getElementById(`${viewName}-view`);\n        if (selectedView) {\n          selectedView.style.display = 'block';\n        }\n\n        // Update tab highlighting\n        document.querySelectorAll('.view-tab').forEach(tab => {\n          tab.classList.remove('active');\n        });\n        const activeTab = document.querySelector(`[data-view=\"${viewName}\"]`);\n        if (activeTab) {\n          activeTab.classList.add('active');\n        }\n\n        this.currentView = viewName;\n\n        // Trigger view-specific initialization\n        if (viewName === 'admin') {\n          if (!this.adminInstances) {\n            this.initAdminModules();\n          }\n          app.updateAdminPanel();\n        }\n      },\n\n      initAdminModules() {\n        // Only initialize in networked mode with valid connection\n        if (!app.sessionModeManager?.isNetworked()) {\n          console.log('Admin modules only available in networked mode');\n          return;\n        }\n\n        if (!app.networkedSession) {\n          console.error('NetworkedSession not initialized');\n          app.uiManager.showError('Network session not available. Check connection.');\n          return;\n        }\n\n        // Get admin modules from NetworkedSession's AdminController\n        const adminController = app.networkedSession.getService('adminController');\n\n        // Initialize admin modules if not already initialized\n        // This is safe to call multiple times (AdminController has guard)\n        if (!adminController.initialized) {\n          console.log('Initializing admin modules...');\n          adminController.initialize();\n        }\n\n        // Reference admin modules (created by AdminController)\n        this.adminInstances = {\n          sessionManager: adminController.getModule('sessionManager'),\n          videoController: adminController.getModule('videoController'),\n          displayController: adminController.getModule('displayController'),\n          systemMonitor: adminController.getModule('systemMonitor'),\n          adminOps: adminController.getModule('adminOperations'),\n          monitoring: adminController.getModule('monitoringDisplay')\n        };\n\n        // Note: MonitoringDisplay automatically registers event listeners\n        // for all monitoring display updates (session, video, system, scores, transactions)\n        // No need to manually register event listeners here\n\n        console.log('Admin modules referenced from AdminController');\n      }\n    };\n  }\n\n  // ========== Settings Management ==========\n\n  toggleMode() {\n    this.settings.mode = this.settings.mode === 'detective' ? 'blackmarket' : 'detective';\n\n    // Mode is stored in Settings and localStorage only\n    // No need to sync to services (they read from Settings)\n\n    this.uiManager.updateModeDisplay(this.settings.mode);\n\n    const scanScreen = document.getElementById('scanScreen');\n    if (scanScreen && scanScreen.classList.contains('active')) {\n      this.uiManager.updateSessionStats();\n    }\n\n    // Visual feedback\n    const indicator = document.getElementById('modeIndicator');\n    if (indicator) {\n      indicator.style.transform = `scale(${this.config.MODE_TOGGLE_SCALE})`;\n      setTimeout(() => {\n        indicator.style.transform = 'scale(1)';\n      }, this.config.ANIMATION_DURATION);\n    }\n  }\n\n  // ========== Team Entry ==========\n\n  /**\n   * Initialize team entry UI\n   * UNIFIED: No mode branching - TeamRegistry handles mode differences\n   */\n  initTeamEntryUI() {\n    const teamInput = document.getElementById('teamNameInput');\n    const teamList = document.getElementById('teamList');\n    const listLabel = document.getElementById('teamListLabel');\n\n    // Label adapts to mode (TeamRegistry encapsulates this)\n    if (listLabel && this.teamRegistry) {\n      listLabel.textContent = this.teamRegistry.getTeamListLabel();\n    }\n\n    // Render team list with click handler\n    if (this.teamRegistry && teamList) {\n      this._renderTeamList(teamList);\n    }\n\n    // Focus input\n    if (teamInput) {\n      teamInput.value = '';\n      teamInput.focus();\n    }\n\n    // Wire teams:updated listener (once)\n    if (this.teamRegistry && !this._teamsListenerAdded) {\n      this._teamsListenerAdded = true;\n      this.teamRegistry.addEventListener('teams:updated', () => {\n        const list = document.getElementById('teamList');\n        if (list) this._renderTeamList(list);\n      });\n    }\n  }\n\n  /**\n   * Render clickable team list from TeamRegistry\n   * @param {HTMLElement} container - Team list container element\n   * @private\n   */\n  _renderTeamList(container) {\n    container.innerHTML = '';\n    const teams = this.teamRegistry.getTeamsForDisplay();\n\n    teams.forEach(teamName => {\n      const item = document.createElement('div');\n      item.className = 'team-list-item';\n      item.textContent = teamName;\n      item.setAttribute('role', 'option');\n      item.addEventListener('click', () => {\n        document.getElementById('teamNameInput').value = teamName;\n        this.confirmTeamId(); // Auto-proceed when clicking existing team\n      });\n      container.appendChild(item);\n    });\n  }\n\n  /**\n   * Confirm team selection and proceed to scan screen\n   * UNIFIED: Reads from single input, TeamRegistry handles mode-specific logic\n   */\n  async confirmTeamId() {\n    const teamInput = document.getElementById('teamNameInput');\n    const teamName = teamInput?.value?.trim();\n\n    if (!teamName) {\n      this.uiManager.showError('Please enter a team name');\n      return;\n    }\n\n    // TeamRegistry handles mode-specific behavior (localStorage vs backend)\n    const result = await this.teamRegistry.selectTeam(teamName);\n    if (!result.success) {\n      this.uiManager.showError(result.error || 'Failed to select team');\n      return;\n    }\n\n    this.currentTeamId = teamName;\n\n    const currentTeamEl = document.getElementById('currentTeam');\n    if (currentTeamEl) currentTeamEl.textContent = teamName;\n\n    this.uiManager.updateSessionStats();\n    this.uiManager.showScreen('scan');\n\n    // Auto-start NFC scanning after team confirmation\n    await this._startNFCScanning();\n  }\n\n  // ========== Game Mode Selection ==========\n\n  /**\n   * Select game mode (networked or standalone)\n   * Per Architecture Refactoring 2025-11: App creates NetworkedSession\n   *\n   * @param {string} mode - 'networked' or 'standalone'\n   */\n  async selectGameMode(mode) {\n    if (!this.sessionModeManager) {\n      console.error('SessionModeManager not initialized');\n      this.uiManager.showError('System error: SessionModeManager not initialized. Please reload the page.');\n      return;\n    }\n\n    try {\n      // For networked mode: Check auth token first before locking mode\n      if (mode === 'networked') {\n        const token = localStorage.getItem('aln_auth_token');\n\n        if (!token || !this._isTokenValid(token)) {\n          // No valid token - show connection wizard WITHOUT locking mode yet\n          // The wizard's handleConnectionSubmit will lock mode after successful auth\n          this.debug.log('Networked mode selected - showing connection wizard (mode not locked yet)');\n          if (this.showConnectionWizard) {\n            this.showConnectionWizard();\n          } else {\n            this.uiManager.showError('Connection wizard not available');\n          }\n          return;\n        }\n\n        // Valid token exists - lock mode and initialize\n        this.sessionModeManager.setMode(mode);\n        this.debug.log(`Game mode locked: ${mode}`);\n        await this._initializeNetworkedMode();\n      } else if (mode === 'standalone') {\n        // Standalone mode: lock immediately and proceed\n        this.sessionModeManager.setMode(mode);\n        this.debug.log(`Game mode locked: ${mode}`);\n\n        // Phase 3: Add body class for CSS-based feature hiding\n        document.body.classList.add('standalone-mode');\n        document.body.classList.remove('networked-mode');\n\n        // Clear phantom data from previous sessions\n        localStorage.removeItem('standaloneSession');\n\n        // Initialize UnifiedDataManager for standalone mode\n        // This creates LocalStorage strategy and loads from localStorage if available\n        this.dataManager.sessionModeManager = this.sessionModeManager;\n        await this.dataManager.initializeStandaloneMode();\n\n        this.debug.log('UnifiedDataManager initialized for standalone mode');\n\n        // Phase 3: Initialize view controller (shows admin tabs in standalone mode too)\n        this.viewController.init();\n\n        // Phase 3: Initialize admin session display in standalone mode\n        const sessionContainer = document.getElementById('session-status-container');\n        if (sessionContainer) {\n          this.uiManager.renderSessionStatus(sessionContainer);\n        }\n\n        // Wire TeamRegistry for unified API (standalone)\n        if (this.teamRegistry) {\n          this.teamRegistry.sessionModeManager = this.sessionModeManager;\n        }\n\n        // Initialize team entry UI\n        this.initTeamEntryUI();\n\n        this.uiManager.showScreen('teamEntry');\n      }\n    } catch (error) {\n      console.error('Failed to set game mode:', error);\n      this.uiManager.showError(`Failed to set game mode: ${error.message}`);\n\n      // Re-throw so caller (ConnectionWizard) can display error in modal\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize networked mode by creating NetworkedSession\n   * @private\n   */\n  async _initializeNetworkedMode() {\n    // Phase 3: Add body class for CSS-based feature display\n    document.body.classList.add('networked-mode');\n    document.body.classList.remove('standalone-mode');\n\n    // Get configuration from localStorage (set by connection wizard)\n    const orchestratorUrl = localStorage.getItem('aln_orchestrator_url') || 'https://localhost:3000';\n    const deviceId = this.settings?.deviceId || 'GM_STATION_UNKNOWN';\n    const token = localStorage.getItem('aln_auth_token');\n\n    // Check if we have a valid token\n    if (token && this._isTokenValid(token)) {\n      this.debug.log('Valid token found - creating NetworkedSession...');\n\n      // Show reconnecting toast\n      this.uiManager.showToast('Reconnecting to orchestrator...', 'info', 3000);\n\n      // Create NetworkedSession (Service Orchestrator)\n      this.networkedSession = new NetworkedSession({\n        url: orchestratorUrl,\n        deviceId: deviceId,\n        stationName: this.settings?.stationName || 'GM Station',\n        token: token\n      }, this.dataManager, this.teamRegistry);\n\n      // Attempt connection\n      try {\n        // Wire event listeners BEFORE initializing (so we catch session:ready)\n        this._wireNetworkedSessionEvents();\n\n        // CRITICAL: Initialize UnifiedDataManager BEFORE WebSocket connects\n        // NetworkedSession._messageHandler calls dataManager methods on sync:full\n        // If _networkedStrategy doesn't exist, score updates are silently dropped\n        this.dataManager.sessionModeManager = this.sessionModeManager;\n        await this.dataManager.initializeNetworkedMode(null); // Socket added after connect\n        this.debug.log('UnifiedDataManager initialized for networked mode (socket pending)');\n\n        await this.networkedSession.initialize();\n        this.debug.log('NetworkedSession initialized - session:ready will fire');\n\n        // Update NetworkedStorage with the actual socket reference\n        const client = this.networkedSession.getService('client');\n        if (client?.socket && this.dataManager._networkedStrategy) {\n          this.dataManager._networkedStrategy.socket = client.socket;\n          this.debug.log('NetworkedStorage socket reference updated');\n        }\n\n        // Wire TeamRegistry for unified API (networked)\n        if (this.teamRegistry) {\n          this.teamRegistry.sessionModeManager = this.sessionModeManager;\n          if (client) {\n            this.teamRegistry.orchestratorClient = client;\n          }\n        }\n\n        // Close connection wizard modal (if open) and show team entry screen\n        // Per Architecture Refactoring 2025-11: App manages UI transitions after NetworkedSession ready\n        const connectionModal = document.getElementById('connectionModal');\n        if (connectionModal && connectionModal.style.display !== 'none') {\n          connectionModal.style.display = 'none';\n          this.debug.log('Connection wizard closed after successful initialization');\n        }\n\n        // Show viewSelector (admin panel tabs) in networked mode\n        const viewSelector = document.getElementById('viewSelector');\n        if (viewSelector) {\n          viewSelector.style.display = 'flex';\n        }\n\n        // Transition to team entry screen\n        this.uiManager.showScreen('teamEntry');\n        this.debug.log('UI transitioned to team entry screen');\n\n      } catch (error) {\n        console.error('NetworkedSession initialization failed:', error);\n        // Clean up failed session\n        if (this.networkedSession) {\n          await this.networkedSession.destroy();\n          this.networkedSession = null;\n        }\n        throw error;\n      }\n    } else {\n      // No valid token - show connection wizard\n      this.debug.log('No valid token - showing connection wizard');\n      if (this.showConnectionWizard) {\n        this.showConnectionWizard();\n      } else {\n        this.uiManager.showError('Connection wizard not available');\n      }\n    }\n  }\n\n  /**\n   * Check if JWT token is valid (not expired, with 1-minute buffer)\n   * @private\n   */\n  _isTokenValid(token) {\n    return isTokenValid(token);\n  }\n\n  // ========== Helper Methods ==========\n\n  /**\n   * Helper to switch to a specific view\n   */\n  switchView(viewName) {\n    this.viewController.switchView(viewName);\n  }\n\n  // ========== Scanning ==========\n\n  /**\n   * @deprecated Use _startNFCScanning() instead. Kept for console debugging.\n   */\n  async startScan() {\n    console.warn('startScan() is deprecated - NFC now auto-starts on team confirmation');\n    await this._startNFCScanning();\n  }\n\n  /**\n   * Start NFC scanning without button state management\n   * Called automatically on team confirmation\n   * @private\n   */\n  async _startNFCScanning() {\n    if (!this.nfcSupported) {\n      this.debug.log('NFC not supported - scan simulation available via Manual Entry');\n      return;\n    }\n\n    const status = document.getElementById('scanStatus');\n\n    try {\n      if (status) {\n        status.textContent = 'Scanning... Tap a token';\n      }\n\n      await this.nfcHandler.startScan(\n        (result) => this.processNFCRead(result),\n        (err) => {\n          this.debug.log(`NFC read error: ${err?.message || err}`, true);\n          if (status) {\n            status.textContent = 'Read error. Tap token again.';\n          }\n        }\n      );\n\n      this.debug.log('NFC scanning started automatically');\n    } catch (error) {\n      this.debug.log(`NFC start error: ${error.message}`, true);\n      if (status) {\n        status.textContent = 'NFC unavailable. Use Manual Entry.';\n      }\n    }\n  }\n\n  simulateScan() {\n    const status = document.getElementById('scanStatus');\n    if (status) {\n      status.textContent = 'Demo Mode: Simulating scan...';\n    }\n\n    setTimeout(() => {\n      const result = this.nfcHandler.simulateScan();\n      this.processNFCRead(result);\n    }, this.config.SCAN_SIMULATION_DELAY);\n  }\n\n  async processNFCRead(result) {\n    // Handle NFC read errors (no serial fallback - errors returned from NFCHandler)\n    if (result.source === 'error') {\n      this.debug.log(`NFC read failed: ${result.error}`, true);\n      this.uiManager.showError('Could not read token - please re-tap');\n      return;\n    }\n\n    this.debug.log(`Processing token: \"${result.id}\" (from ${result.source})`);\n    this.debug.log(`Token ID length: ${result.id.length} characters`);\n\n    // VALIDATION: Ensure team is selected before processing\n    if (!this.currentTeamId || this.currentTeamId.trim() === '') {\n      this.debug.log('ERROR: No team selected - cannot process token', true);\n      this.uiManager.showError('Please select a team before scanning tokens');\n      return;\n    }\n\n    // Trim any whitespace\n    const cleanId = result.id.trim();\n    this.debug.log(`Cleaned ID: \"${cleanId}\" (length: ${cleanId.length})`);\n\n    // Look up token first to get normalized ID (findToken handles case variations)\n    const tokenData = this.tokenManager.findToken(cleanId);\n\n    // Use matched ID for duplicate check (handles case variations)\n    const tokenId = tokenData ? tokenData.matchedId : cleanId;\n\n    // Check for duplicate using normalized ID\n    // UnifiedDataManager handles this for both modes\n    if (this.dataManager.isTokenScanned(tokenId)) {\n      this.debug.log(`Duplicate token detected: ${tokenId}`, true);\n      this.showDuplicateError(tokenId);\n      return;\n    }\n\n    if (!tokenData) {\n      await this.recordTransaction(null, cleanId, true);\n    } else {\n      await this.recordTransaction(tokenData.token, tokenData.matchedId, false);\n    }\n  }\n\n  showDuplicateError(tokenId) {\n    const statusEl = document.getElementById('resultStatus');\n    if (statusEl) {\n      statusEl.className = 'status-message error';\n      statusEl.innerHTML = `\n        <h2>Token Already Scanned</h2>\n        <p style=\"font-size: 14px;\">This token has been used</p>\n        <p style=\"font-size: 12px; color: #666;\">ID: ${tokenId}</p>\n      `;\n    }\n\n    const rfidEl = document.getElementById('resultRfid');\n    if (rfidEl) {\n      rfidEl.textContent = tokenId;\n    }\n\n    const typeEl = document.getElementById('resultType');\n    if (typeEl) {\n      typeEl.textContent = 'DUPLICATE';\n      typeEl.style.color = '#FF5722';\n    }\n\n    const groupEl = document.getElementById('resultGroup');\n    if (groupEl) {\n      groupEl.textContent = 'Previously scanned';\n    }\n\n    const valueEl = document.getElementById('resultValue');\n    if (valueEl) {\n      valueEl.textContent = 'No points awarded';\n    }\n\n    this.uiManager.showScreen('result');\n  }\n\n  async recordTransaction(token, tokenId, isUnknown) {\n    const transaction = {\n      timestamp: new Date().toISOString(),\n      deviceId: this.settings.deviceId,\n      mode: this.settings.mode,\n      teamId: this.currentTeamId,\n      rfid: tokenId,\n      tokenId: tokenId,  // Add tokenId for consistency with backend\n      memoryType: isUnknown ? 'UNKNOWN' : (token?.SF_MemoryType || 'UNKNOWN'),\n      group: isUnknown ? `Unknown: ${tokenId}` : (token?.SF_Group || ''),\n      tokenGroup: isUnknown ? '' : (token?.SF_Group || ''),  // For group completion detection\n      valueRating: isUnknown ? 0 : (token?.SF_ValueRating || 0),\n      isUnknown: isUnknown\n    };\n\n    // Calculate points for blackmarket mode\n    if (this.settings.mode === 'blackmarket' && !isUnknown) {\n      transaction.points = this.dataManager.calculateTokenValue(transaction);\n    } else {\n      transaction.points = 0;\n    }\n\n    // Submit transaction based on session mode\n    if (this.sessionModeManager && this.sessionModeManager.isNetworked()) {\n      // Networked mode - DON'T add to DataManager yet (will be added when backend confirms)\n      this.dataManager.markTokenAsScanned(tokenId);  // Still mark as scanned to prevent duplicates\n\n      // Get queue manager from NetworkedSession\n      if (!this.networkedSession) {\n        throw new Error('Cannot scan: NetworkedSession not initialized. Please reconnect.');\n      }\n\n      const queueManager = this.networkedSession.getService('queueManager');\n\n      // Use queue manager for reliable delivery\n      const txId = queueManager.queueTransaction({\n        tokenId: tokenId,\n        teamId: this.currentTeamId,\n        deviceId: this.settings.deviceId,\n        deviceType: 'gm',  // BUG #1 FIX: Required by backend validators\n        mode: this.settings.mode,  // AsyncAPI contract field (was 'mode')\n        summary: token?.summary || null,  // Include summary for persistence (backend AsyncAPI contract)\n        timestamp: transaction.timestamp  // Use same timestamp\n      });\n      this.debug.log(`Transaction queued for orchestrator: ${txId}`);\n    } else {\n      // Standalone mode - use UnifiedDataManager (LocalStorage strategy)\n      if (this.sessionModeManager && this.sessionModeManager.isStandalone()) {\n        // Add transaction via UnifiedDataManager (delegates to LocalStorage strategy)\n        // LocalStorage handles scoring, group bonuses, and persists to localStorage\n        await this.dataManager.addTransaction(transaction);\n        this.dataManager.markTokenAsScanned(tokenId);\n        this.debug.log('Transaction stored via UnifiedDataManager (standalone mode)');\n      } else {\n        // No session mode selected yet - should not happen, but handle gracefully\n        this.debug.log('Warning: No session mode selected - cannot process transaction', true);\n        this.uiManager.showError('Please select a game mode first');\n        return;\n      }\n    }\n\n    if (this.settings.mode === 'blackmarket' && !isUnknown) {\n      this.debug.log(`Token scored: $${transaction.points.toLocaleString()}`);\n    }\n\n    this.uiManager.updateSessionStats();\n    this.uiManager.showTokenResult(token, tokenId, isUnknown);\n  }\n\n  manualEntry() {\n    const rfid = prompt('Enter RFID manually:');\n    if (rfid && rfid.trim()) {\n      this.processNFCRead({\n        id: rfid.trim(),\n        source: 'manual',\n        raw: rfid.trim()\n      });\n    }\n  }\n\n  cancelScan() {\n    this.nfcHandler.stopScan();\n    this.currentTeamId = '';\n    this.uiManager.updateTeamDisplay('');\n    this.uiManager.showScreen('teamEntry');\n  }\n\n  continueScan() {\n    this.uiManager.updateSessionStats();\n    this.uiManager.showScreen('scan');\n  }\n\n  finishTeam() {\n    this.currentTeamId = '';\n    // Note: Do NOT clear DataManager session here - scannedTokens must persist\n    // across team switches for cross-team duplicate detection\n    this.uiManager.updateTeamDisplay('');\n    this.uiManager.showScreen('teamEntry');\n  }\n\n  // ========== History ==========\n\n  showHistory() {\n    this.uiManager.updateHistoryStats();\n    // Use unified Game Activity renderer (same as admin panel)\n    const historyContainer = document.getElementById('historyContainer');\n    if (historyContainer) {\n      this.uiManager.renderGameActivity(historyContainer, { showSummary: true, showFilters: true });\n    }\n    this.uiManager.showScreen('history');\n  }\n\n  closeHistory() {\n    // Default to teamEntry if no valid previous screen\n    const targetScreen = this.uiManager.previousScreen || 'teamEntry';\n    this.uiManager.showScreen(targetScreen);\n  }\n\n  // ========== Scoreboard ==========\n\n  showScoreboard() {\n    if (this.settings.mode !== 'blackmarket') {\n      this.debug.log('Scoreboard only available in Black Market mode');\n      return;\n    }\n    this.uiManager.renderScoreboard();\n    this.uiManager.showScreen('scoreboard');\n  }\n\n  closeScoreboard() {\n    // Default to teamEntry if no valid previous screen\n    const targetScreen = this.uiManager.previousScreen || 'teamEntry';\n    this.uiManager.showScreen(targetScreen);\n  }\n\n  // ========== Team Details ==========\n\n  showTeamDetails(teamId) {\n    // CRITICAL: teamDetailsScreen is inside scanner-view, so switch to scanner view first\n    // if currently in admin view (common when clicking team from admin panel score board)\n    if (this.viewController && this.viewController.currentView === 'admin') {\n      this.viewController.switchView('scanner');\n    }\n\n    // CRITICAL: Track current team for intervention actions (deletion, score adjustment)\n    this.currentInterventionTeamId = teamId;\n\n    const transactions = this.dataManager.getTeamTransactions(teamId);\n    this.uiManager.renderTeamDetails(teamId, transactions);\n    this.uiManager.showScreen('teamDetails');\n  }\n\n  closeTeamDetails() {\n    this.uiManager.showScreen('scoreboard');\n  }\n\n  // ========== Admin Actions ==========\n  // These methods wrap calls to AdminModule functionality\n\n  async adminCreateSession() {\n    const name = prompt('Enter session name:');\n    if (!name) return;\n\n    const isStandalone = this.sessionModeManager?.isStandalone();\n\n    // Standalone mode: Use UnifiedDataManager (LocalStorage strategy)\n    if (isStandalone) {\n      try {\n        await this.dataManager.createSession(name.trim(), []);\n        this.debug.log(`Session created (standalone): ${name}`);\n        this.uiManager.showToast('Session created', 'success');\n\n        // Refresh session display\n        this._refreshAdminSessionDisplay();\n      } catch (error) {\n        console.error('Failed to create session (standalone):', error);\n        this.uiManager.showError(`Failed to create session: ${error.message}`);\n      }\n      return;\n    }\n\n    // Networked mode: Use SessionManager (existing code)\n    if (!this.viewController.adminInstances?.sessionManager) {\n      alert('Admin functions not available. Please ensure you are connected.');\n      return;\n    }\n\n    try {\n      await this.viewController.adminInstances.sessionManager.createSession(name);\n      this.debug.log(`Session created: ${name}`);\n    } catch (error) {\n      console.error('Failed to create session:', error);\n      this.uiManager.showError('Failed to create session. Check connection.');\n    }\n  }\n\n  async adminPauseSession() {\n    const isStandalone = this.sessionModeManager?.isStandalone();\n\n    // Standalone mode: Use UnifiedDataManager\n    if (isStandalone) {\n      try {\n        const result = await this.dataManager.pauseSession();\n        if (result.success) {\n          this.debug.log('Session paused (standalone)');\n          this.uiManager.showToast('Session paused', 'info');\n          this._refreshAdminSessionDisplay();\n        } else {\n          this.uiManager.showError(result.error || 'Failed to pause session');\n        }\n      } catch (error) {\n        console.error('Failed to pause session (standalone):', error);\n        this.uiManager.showError(`Failed to pause session: ${error.message}`);\n      }\n      return;\n    }\n\n    // Networked mode (existing code)\n    if (!this.viewController.adminInstances?.sessionManager) {\n      alert('Admin functions not available.');\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.sessionManager.pauseSession();\n      this.debug.log('Session paused');\n    } catch (error) {\n      console.error('Failed to pause session:', error);\n      this.uiManager.showError('Failed to pause session.');\n    }\n  }\n\n  async adminResumeSession() {\n    const isStandalone = this.sessionModeManager?.isStandalone();\n\n    // Standalone mode: Use UnifiedDataManager\n    if (isStandalone) {\n      try {\n        const result = await this.dataManager.resumeSession();\n        if (result.success) {\n          this.debug.log('Session resumed (standalone)');\n          this.uiManager.showToast('Session resumed', 'success');\n          this._refreshAdminSessionDisplay();\n        } else {\n          this.uiManager.showError(result.error || 'Failed to resume session');\n        }\n      } catch (error) {\n        console.error('Failed to resume session (standalone):', error);\n        this.uiManager.showError(`Failed to resume session: ${error.message}`);\n      }\n      return;\n    }\n\n    // Networked mode (existing code)\n    if (!this.viewController.adminInstances?.sessionManager) {\n      alert('Admin functions not available.');\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.sessionManager.resumeSession();\n      this.debug.log('Session resumed');\n    } catch (error) {\n      console.error('Failed to resume session:', error);\n      this.uiManager.showError('Failed to resume session.');\n    }\n  }\n\n  async adminEndSession() {\n    if (!confirm('Are you sure you want to end the session?')) return;\n\n    const isStandalone = this.sessionModeManager?.isStandalone();\n\n    // Standalone mode: Use UnifiedDataManager\n    if (isStandalone) {\n      try {\n        await this.dataManager.endSession();\n        this.debug.log('Session ended (standalone)');\n        this.uiManager.showToast('Session ended', 'info');\n        this._refreshAdminSessionDisplay();\n      } catch (error) {\n        console.error('Failed to end session (standalone):', error);\n        this.uiManager.showError(`Failed to end session: ${error.message}`);\n      }\n      return;\n    }\n\n    // Networked mode (existing code)\n    if (!this.viewController.adminInstances?.sessionManager) {\n      alert('Admin functions not available.');\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.sessionManager.endSession();\n      this.debug.log('Session ended');\n    } catch (error) {\n      console.error('Failed to end session:', error);\n      this.uiManager.showError('Failed to end session.');\n    }\n  }\n\n  async adminResetAndCreateNew() {\n    // Step 0: Confirm with user\n    const confirmReset = confirm(\n      'Reset system and start new session?\\n\\n' +\n      'This will:\\n' +\n      '‚Ä¢ Archive the current completed session\\n' +\n      '‚Ä¢ Clear all current data\\n' +\n      '‚Ä¢ Prepare system for a new game\\n\\n' +\n      'Continue?'\n    );\n\n    if (!confirmReset) return;\n\n    // Step 1: Get new session name\n    const name = prompt('Enter new session name:');\n    if (!name || name.trim() === '') {\n      alert('Session name is required');\n      return;\n    }\n\n    // Step 2: Verify admin instances available\n    if (!this.viewController.adminInstances?.sessionManager) {\n      alert('Admin functions not available. Please ensure you are connected to the orchestrator.');\n      return;\n    }\n\n    try {\n      // Step 3: Send system:reset command\n      this.debug.log('Sending system:reset command...');\n\n      await new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('System reset timeout (5s)'));\n        }, 5000);\n\n        const socket = this.viewController.adminInstances.sessionManager.connection.socket;\n\n        socket.once('gm:command:ack', (response) => {\n          clearTimeout(timeout);\n\n          if (response.data && response.data.success) {\n            this.debug.log('System reset successful');\n            resolve();\n          } else {\n            const errorMsg = response.data?.message || 'Reset failed';\n            reject(new Error(errorMsg));\n          }\n        });\n\n        socket.emit('gm:command', {\n          event: 'gm:command',\n          data: {\n            action: 'system:reset',\n            payload: {}\n          },\n          timestamp: new Date().toISOString()\n        });\n      });\n\n      this.debug.log('System reset complete, creating new session...');\n\n      // Step 4: Create new session\n      await this.viewController.adminInstances.sessionManager.createSession(name.trim());\n\n      this.debug.log(`New session created: ${name}`);\n\n      // Step 5: Show success feedback\n      if (this.uiManager.showToast) {\n        this.uiManager.showToast(`Session \"${name}\" started successfully`, 'success', 5000);\n      } else {\n        alert(`Session \"${name}\" created successfully!`);\n      }\n\n    } catch (error) {\n      console.error('Failed to reset and create session:', error);\n\n      const errorMsg = `Failed to reset and create session: ${error.message}`;\n\n      if (this.uiManager.showError) {\n        this.uiManager.showError(errorMsg);\n      } else {\n        alert(errorMsg);\n      }\n    }\n  }\n\n  async adminViewSessionDetails() {\n    const session = this.viewController.adminInstances?.sessionManager?.currentSession;\n\n    if (!session) {\n      alert('No session data available');\n      return;\n    }\n\n    // Format session details\n    const startTime = session.startTime ? new Date(session.startTime).toLocaleString() : 'Unknown';\n    const endTime = session.endTime ? new Date(session.endTime).toLocaleString() : 'Ongoing';\n    const duration = session.getDuration ? this.formatSessionDuration(session.getDuration()) : 'Unknown';\n\n    const details = `\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nSESSION DETAILS\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nName: ${session.name || 'Unnamed Session'}\nID: ${session.id}\nStatus: ${session.status.toUpperCase()}\n\nTIMING\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nStarted: ${startTime}\n${session.endTime ? 'Ended: ' + endTime : 'Status: In Progress'}\nDuration: ${duration}\n\nSTATISTICS\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nTotal Scans: ${session.metadata?.totalScans || 0}\nUnique Tokens: ${session.metadata?.uniqueTokensScanned?.length || 0}\nTeams: ${session.scores?.length || 0}\nGM Stations: ${session.connectedDevices?.filter(d => d.type === 'gm').length || 0}\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n    `.trim();\n\n    alert(details);\n  }\n\n  /**\n   * Helper: Format duration for session details\n   */\n  formatSessionDuration(ms) {\n    if (ms == null || ms < 0) return 'Unknown';\n\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n\n    const parts = [];\n    if (days > 0) parts.push(`${days}d`);\n    if (hours % 24 > 0) parts.push(`${hours % 24}h`);\n    if (minutes % 60 > 0 && parts.length < 2) parts.push(`${minutes % 60}m`);\n    if (seconds % 60 > 0 && parts.length < 2) parts.push(`${seconds % 60}s`);\n\n    return parts.length > 0 ? parts.join(' ') : '0s';\n  }\n\n  async _adminVideoAction(action) {\n    if (!this.viewController.adminInstances?.videoController) {\n      alert('Video controls not available.');\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.videoController[action]();\n    } catch (error) {\n      const label = action.replace('Video', ' video');\n      console.error(`Failed to ${label}:`, error);\n      this.uiManager.showError(`Failed to ${label}.`);\n    }\n  }\n\n  async adminPlayVideo() { return this._adminVideoAction('playVideo'); }\n  async adminPauseVideo() { return this._adminVideoAction('pauseVideo'); }\n  async adminStopVideo() { return this._adminVideoAction('stopVideo'); }\n  async adminSkipVideo() { return this._adminVideoAction('skipVideo'); }\n\n  // ============================================\n  async adminAddVideoToQueue() {\n    if (!this.viewController.adminInstances?.videoController) {\n      alert('Video controls not available.');\n      return;\n    }\n    const input = document.getElementById('manual-video-input');\n    const filename = input?.value;\n    if (!filename) {\n      alert('Enter a video filename (e.g., jaw001.mp4)');\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.videoController.addToQueue(filename);\n      this.uiManager.showToast(`Added ${filename} to queue`, 'success');\n      if (input) {\n        input.value = '';\n      }\n    } catch (error) {\n      console.error('Failed to add video to queue:', error);\n      this.uiManager.showError(`Failed to add video: ${error.message}`);\n    }\n  }\n\n  async adminClearQueue() {\n    if (!this.viewController.adminInstances?.videoController) {\n      alert('Video controls not available.');\n      return;\n    }\n    if (!confirm('Clear entire video queue?')) {\n      return;\n    }\n    try {\n      await this.viewController.adminInstances.videoController.clearQueue();\n      this.uiManager.showToast('Queue cleared', 'success');\n    } catch (error) {\n      console.error('Failed to clear queue:', error);\n      this.uiManager.showError(`Failed to clear queue: ${error.message}`);\n    }\n  }\n\n  // ========== Admin Panel Display Updates ==========\n\n  updateAdminPanel() {\n    // In networked mode, delegate to MonitoringDisplay for session/device/video status\n    if (this.viewController?.adminInstances?.monitoring) {\n      this.viewController.adminInstances.monitoring.refreshAllDisplays();\n    }\n\n    // Render Game Activity (unified display for both modes)\n    // This replaces the old transaction log with the new token lifecycle view\n    const gameActivityContainer = document.getElementById('admin-game-activity');\n    if (gameActivityContainer) {\n      this.uiManager.renderGameActivity(gameActivityContainer, { showSummary: true, showFilters: true });\n    }\n\n    // Render admin scoreboard from current data.\n    // ScreenUpdateManager container handlers only fire on events ‚Äî if the admin\n    // panel wasn't visible when score events fired, the scoreboard is empty.\n    // Always render current scores when switching to admin view.\n    const scoreBoard = document.getElementById('admin-score-board');\n    if (scoreBoard && this.viewController?.adminInstances?.monitoring) {\n      this.uiManager.renderScoreboard(scoreBoard);\n    } else if (scoreBoard) {\n      // Fallback scoreboard for standalone mode (no WebSocket connection)\n      const teams = {};\n      this.dataManager.getTransactions().forEach(tx => {\n        if (!teams[tx.teamId]) {\n          teams[tx.teamId] = {\n            score: 0,\n            count: 0\n          };\n        }\n        teams[tx.teamId].count++;\n        // Use each transaction's mode, not the current setting\n        if (tx.mode === 'blackmarket') {\n          const score = this.dataManager.calculateTokenValue(tx);\n          teams[tx.teamId].score += score;\n        }\n      });\n\n      // Display scores\n      let html = '<table class=\"score-table\"><tr><th>Team</th><th>Tokens</th><th>Score</th></tr>';\n      Object.keys(teams).forEach(teamId => {\n        html += `<tr>\n          <td style=\"cursor: pointer; color: #007bff; text-decoration: underline;\"\n              data-action=\"app.showTeamDetails\" data-arg=\"${teamId}\">\n            ${teamId}\n          </td>\n          <td>${teams[teamId].count}</td>\n          <td>${teams[teamId].score.toLocaleString()}</td>\n        </tr>`;\n      });\n      html += '</table>';\n      scoreBoard.innerHTML = html;\n    }\n  }\n\n  async adminResetScores() {\n    if (!confirm('Reset all team scores to zero? Transactions will be preserved.')) return;\n\n    const isStandalone = this.sessionModeManager?.isStandalone();\n\n    // Standalone mode: Use UnifiedDataManager\n    if (isStandalone) {\n      try {\n        const result = await this.dataManager.resetScores();\n        if (result.success) {\n          this.debug.log('Scores reset (standalone)');\n          this.uiManager.showToast('All scores reset to zero', 'success');\n        } else {\n          this.uiManager.showError(result.error || 'Failed to reset scores');\n        }\n      } catch (error) {\n        console.error('Failed to reset scores (standalone):', error);\n        this.uiManager.showError(`Failed to reset scores: ${error.message}`);\n      }\n      return;\n    }\n\n    // Networked mode: Use AdminOps\n    if (!this.viewController.adminInstances?.adminOps) {\n      alert('Admin functions not available.');\n      return;\n    }\n\n    try {\n      await this.viewController.adminInstances.adminOps.resetScores();\n      this.debug.log('Scores reset');\n      this.uiManager.showToast('All scores reset', 'success');\n    } catch (error) {\n      console.error('Failed to reset scores:', error);\n      this.uiManager.showError('Failed to reset scores.');\n    }\n  }\n\n  /**\n   * Navigate to full scoreboard view from admin panel\n   */\n  viewFullScoreboard() {\n    this.switchView('scanner');\n    this.showScoreboard();\n  }\n\n  /**\n   * Navigate to full transaction history from admin panel\n   */\n  viewFullHistory() {\n    this.switchView('scanner');\n    this.showHistory();\n  }\n\n  /**\n   * Refresh admin session display (standalone mode)\n   * @private\n   */\n  _refreshAdminSessionDisplay() {\n    const container = document.getElementById('session-status-container');\n    if (container && this.uiManager) {\n      this.uiManager.renderSessionStatus(container);\n    }\n  }\n\n  // ========== GM Intervention (Both Modes) ==========\n\n  async adjustTeamScore() {\n    const teamId = this.currentInterventionTeamId;\n    if (!teamId) {\n      alert('No team selected. Please open team details first.');\n      return;\n    }\n\n    const deltaInput = document.getElementById('scoreAdjustmentInput');\n    const reasonInput = document.getElementById('scoreAdjustmentReason');\n\n    const delta = parseInt(deltaInput?.value || '0');\n    if (isNaN(delta) || delta === 0) {\n      alert('Please enter a valid positive or negative number.');\n      return;\n    }\n\n    const reason = reasonInput?.value.trim() || 'Manual GM adjustment';\n\n    const isStandalone = this.sessionModeManager?.isStandalone();\n\n    // Standalone mode: Use UnifiedDataManager (LocalStorage strategy)\n    if (isStandalone) {\n      try {\n        await this.dataManager.adjustTeamScore(teamId, delta, reason);\n        this.debug.log(`Score adjusted (standalone): Team ${teamId} ${delta > 0 ? '+' : ''}${delta} (${reason})`);\n\n        // Clear inputs\n        if (deltaInput) deltaInput.value = '';\n        if (reasonInput) reasonInput.value = '';\n\n        // Refresh team details immediately with updated local data\n        const transactions = this.dataManager.getTeamTransactions(teamId);\n        this.uiManager.renderTeamDetails(teamId, transactions);\n\n        this.uiManager.showToast(`Score adjusted: ${delta > 0 ? '+' : ''}${delta} points`, 'success');\n      } catch (error) {\n        console.error('Failed to adjust score (standalone):', error);\n        this.uiManager.showError(`Failed to adjust score: ${error.message}`);\n      }\n      return;\n    }\n\n    // Networked mode: Use AdminOps (backend authoritative)\n    if (!this.viewController?.adminInstances?.adminOps) {\n      alert('Admin functions not available. Ensure you are in networked mode.');\n      return;\n    }\n\n    try {\n      await this.viewController.adminInstances.adminOps.adjustScore(teamId, delta, reason);\n      this.debug.log(`Score adjusted (networked): Team ${teamId} ${delta > 0 ? '+' : ''}${delta} (${reason})`);\n\n      // Clear inputs\n      if (deltaInput) deltaInput.value = '';\n      if (reasonInput) reasonInput.value = '';\n\n      // Team details screen will auto-refresh via updateTeamScoreFromBackend()\n      // when score:updated event is received (centralized in dataManager.js)\n\n      this.uiManager.showToast(`Score adjusted: ${delta > 0 ? '+' : ''}${delta} points`, 'success');\n    } catch (error) {\n      console.error('Failed to adjust score (networked):', error);\n      this.uiManager.showError(`Failed to adjust score: ${error.message}`);\n    }\n  }\n\n  async deleteTeamTransaction(transactionId) {\n    if (!confirm('Delete this transaction? This cannot be undone.')) return;\n\n    const isStandalone = this.sessionModeManager?.isStandalone();\n\n    // Standalone mode: Use UnifiedDataManager (LocalStorage strategy)\n    if (isStandalone) {\n      try {\n        const result = await this.dataManager.removeTransaction(transactionId);\n        if (result.success) {\n          this.debug.log(`Transaction deleted (standalone): ${transactionId}`);\n\n          // Refresh team details immediately with updated local data\n          const teamId = this.currentInterventionTeamId;\n          if (teamId) {\n            const transactions = this.dataManager.getTeamTransactions(teamId);\n            this.uiManager.renderTeamDetails(teamId, transactions);\n          }\n\n          this.uiManager.showToast('Transaction deleted', 'success');\n        } else {\n          this.uiManager.showError('Transaction not found');\n        }\n      } catch (error) {\n        console.error('Failed to delete transaction (standalone):', error);\n        this.uiManager.showError(`Failed to delete transaction: ${error.message}`);\n      }\n      return;\n    }\n\n    // Networked mode: Use AdminOps (backend authoritative)\n    if (!this.viewController?.adminInstances?.adminOps) {\n      alert('Admin functions not available. Ensure you are in networked mode.');\n      return;\n    }\n\n    try {\n      await this.viewController.adminInstances.adminOps.deleteTransaction(transactionId);\n      this.debug.log(`Transaction deleted (networked): ${transactionId}`);\n\n      this.uiManager.showToast('Transaction deleted', 'success');\n    } catch (error) {\n      console.error('Failed to delete transaction (networked):', error);\n      this.uiManager.showError(`Failed to delete transaction: ${error.message}`);\n    }\n  }\n\n  // ========== Admin Display Control (Phase 4.2) ==========\n\n  async _adminDisplayAction(action, label) {\n    if (!this.sessionModeManager?.isNetworked()) {\n      this.debug.log('Display control only available in networked mode');\n      return;\n    }\n\n    const displayController = this.viewController?.adminInstances?.displayController;\n    if (!displayController) {\n      this.debug.log('DisplayController not available - admin modules not initialized');\n      this.uiManager.showError('Admin functions not available. Please ensure connection is established.');\n      return;\n    }\n\n    try {\n      const result = await displayController[action]();\n      this.debug.log(`Display mode set to ${label}: ${JSON.stringify(result)}`);\n    } catch (error) {\n      console.error('Failed to set display mode:', error);\n      this.uiManager.showError(`Failed to set display mode: ${error.message}`);\n    }\n  }\n\n  async adminSetIdleLoop() { return this._adminDisplayAction('setIdleLoop', 'Idle Loop'); }\n  async adminSetScoreboard() { return this._adminDisplayAction('setScoreboard', 'Scoreboard'); }\n}\n\n// Create singleton instance\nconst appInstance = new App();\n\n// Export both class and instance\nexport default appInstance;\nexport { App, appInstance };\n","/**\n * Connection Wizard Module\n * Handles networked mode connection setup and server discovery\n *\n * This module replaces the inline script functions from index.html\n * with proper ES6 module architecture and dependency injection.\n */\n\n/**\n * ConnectionWizard class - Manages connection wizard UI and workflow\n * Receives app instance via dependency injection (no window globals)\n */\nexport class ConnectionWizard {\n  constructor(app) {\n    this.app = app;\n\n    // Bind methods for event listeners\n    this.scanForServers = this.scanForServers.bind(this);\n    this.handleConnectionSubmit = this.handleConnectionSubmit.bind(this);\n    this.cancelNetworkedMode = this.cancelNetworkedMode.bind(this);\n    this.showConnectionWizard = this.showConnectionWizard.bind(this);\n  }\n\n  /**\n   * Initialize connection wizard by binding form submit event\n   * Call this after DOM is ready\n   */\n  init() {\n    const connectionForm = document.getElementById('connectionForm');\n    if (connectionForm) {\n      connectionForm.addEventListener('submit', this.handleConnectionSubmit);\n    }\n\n    // Setup debounced server URL handler for manual entry\n    this._setupServerUrlHandler();\n  }\n\n  /**\n   * Scan for game servers via HTTP brute-force\n   * Web browsers cannot do UDP, so we scan common IPs/ports using /health endpoint\n   * Based on player scanner discovery pattern from aln-memory-scanner/config.html\n   */\n  async scanForServers() {\n    const statusDiv = document.getElementById('discoveryStatus');\n    const serversDiv = document.getElementById('discoveredServers');\n    const btn = document.getElementById('scanServersBtn');\n\n    btn.disabled = true;\n    btn.textContent = 'üîç Scanning...';\n    statusDiv.textContent = 'Looking for orchestrators on the network...';\n    statusDiv.style.color = '#2196F3';\n    serversDiv.innerHTML = '';\n\n    try {\n      // Detect current subnet dynamically\n      const currentHost = window.location.hostname;\n      let subnet = '192.168.1'; // Default fallback\n\n      // Try to detect subnet from current host\n      if (currentHost && currentHost !== 'localhost' && currentHost !== '127.0.0.1') {\n        const parts = currentHost.split('.');\n        if (parts.length >= 3) {\n          subnet = parts.slice(0, 3).join('.');\n        }\n      }\n\n      const commonPorts = [3000, 8080];\n      // Use same protocol as current page to avoid mixed content blocking\n      const protocol = window.location.protocol.replace(':', ''); // 'https' or 'http'\n      const promises = [];\n\n      // Scan detected subnet (254 IPs √ó 2 ports = 508 requests max)\n      // Browser connection pooling naturally rate-limits concurrent requests\n      for (let i = 1; i <= 254; i++) {\n        for (const port of commonPorts) {\n          const url = `${protocol}://${subnet}.${i}:${port}`;\n          promises.push(\n            fetch(`${url}/health`, {\n              method: 'GET',\n              mode: 'cors',\n              signal: AbortSignal.timeout(500)\n            })\n            .then(response => response.ok ? url : null)\n            .catch(() => null)\n          );\n        }\n      }\n\n      // Also try localhost\n      promises.push(\n        fetch(`${protocol}://localhost:3000/health`, {\n          signal: AbortSignal.timeout(1000)\n        })\n        .then(response => response.ok ? `${protocol}://localhost:3000` : null)\n        .catch(() => null)\n      );\n\n      // Try current origin if served from orchestrator\n      if (window.location.pathname.startsWith('/gm-scanner/')) {\n        promises.push(Promise.resolve(window.location.origin));\n      }\n\n      const results = await Promise.all(promises);\n      const foundServers = [...new Set(results.filter(url => url !== null))];\n\n      if (foundServers.length > 0) {\n        statusDiv.textContent = `‚úÖ Found ${foundServers.length} orchestrator(s)`;\n        statusDiv.style.color = '#4CAF50';\n\n        // Use existing displayDiscoveredServers pattern\n        this.displayDiscoveredServers(foundServers.map(url => ({ url })));\n      } else {\n        statusDiv.textContent = '‚ö†Ô∏è No orchestrators found. Please enter URL manually below.';\n        statusDiv.style.color = '#ff9800';\n      }\n    } catch (error) {\n      statusDiv.textContent = '‚ùå Discovery failed. Please enter URL manually below.';\n      statusDiv.style.color = '#f44336';\n      console.error('Server discovery error:', error);\n    } finally {\n      btn.disabled = false;\n      btn.textContent = 'üîç Scan for Game Servers';\n    }\n  }\n\n  /**\n   * Display discovered servers in the UI\n   * @private\n   */\n  displayDiscoveredServers(servers) {\n    const statusDiv = document.getElementById('discoveryStatus');\n    const serversDiv = document.getElementById('discoveredServers');\n\n    statusDiv.textContent = `‚úÖ Found ${servers.length} game server(s)`;\n    serversDiv.innerHTML = '';\n\n    servers.forEach(server => {\n      const serverEl = document.createElement('div');\n      serverEl.className = 'server-item';\n      serverEl.innerHTML = `\n        <span>üéÆ Game Server at ${server.ip || server.url}</span>\n        <button data-action=\"connectionWizard.selectServer\" data-arg=\"${server.url}\">Select</button>\n      `;\n      serversDiv.appendChild(serverEl);\n    });\n  }\n\n  /**\n   * Setup debounced handler for server URL manual entry\n   * Queries /api/state to auto-assign station name when URL is entered\n   * @private\n   */\n  _setupServerUrlHandler() {\n    const serverUrlInput = document.getElementById('serverUrl');\n    if (!serverUrlInput) return;\n\n    let debounceTimer;\n    const DEBOUNCE_MS = 500;\n\n    serverUrlInput.addEventListener('input', () => {\n      clearTimeout(debounceTimer);\n      debounceTimer = setTimeout(() => {\n        const url = serverUrlInput.value.trim();\n        if (url) {\n          // Normalize URL (add protocol if missing)\n          let normalizedUrl = url;\n          if (!normalizedUrl.match(/^https?:\\/\\//i)) {\n            normalizedUrl = `http://${normalizedUrl}`;\n          }\n          this.assignStationName(normalizedUrl);\n        }\n      }, DEBOUNCE_MS);\n    });\n  }\n\n  /**\n   * Query orchestrator for existing devices and assign next available station name\n   * @param {string} serverUrl - The orchestrator URL\n   * @private\n   */\n  async assignStationName(serverUrl) {\n    const stationNameDisplay = document.getElementById('stationNameDisplay');\n    if (!stationNameDisplay) return; // Graceful fallback if HTML not updated yet\n\n    try {\n      // Query /api/state (no auth required)\n      const response = await fetch(`${serverUrl}/api/state`, {\n        method: 'GET',\n        mode: 'cors',\n        signal: AbortSignal.timeout(3000)\n      });\n\n      if (!response.ok) {\n        throw new Error('Server unreachable');\n      }\n\n      const state = await response.json();\n      const devices = state.devices || [];\n\n      // Extract existing GM device IDs\n      const existingIds = devices\n        .filter(d => d.type === 'gm')\n        .map(d => d.deviceId);\n\n      // Find next available station ID\n      const nextStationId = this._findNextStationId(existingIds);\n\n      // Update display\n      stationNameDisplay.textContent = nextStationId;\n      stationNameDisplay.dataset.deviceId = nextStationId;\n\n      console.log(`[ConnectionWizard] Auto-assigned station name: ${nextStationId}`);\n    } catch (error) {\n      // Fallback to localStorage counter on error\n      console.warn(`[ConnectionWizard] Failed to query /api/state, using localStorage fallback:`, error.message);\n\n      const stationNum = localStorage.getItem('lastStationNum') || '1';\n      const fallbackId = `GM_Station_${stationNum}`;\n\n      if (stationNameDisplay) {\n        stationNameDisplay.textContent = fallbackId;\n        stationNameDisplay.dataset.deviceId = fallbackId;\n      }\n    }\n  }\n\n  /**\n   * Find next available station ID using gap-filling algorithm\n   * @param {string[]} existingIds - Array of existing device IDs (e.g., [\"GM_Station_1\", \"GM_Station_3\"])\n   * @returns {string} Next available station ID (e.g., \"GM_Station_2\")\n   * @private\n   */\n  _findNextStationId(existingIds) {\n    // Extract numbers from GM_Station_N pattern\n    const stationNumbers = existingIds\n      .filter(id => id && id.startsWith('GM_Station_'))\n      .map(id => {\n        const match = id.match(/GM_Station_(\\d+)$/);\n        return match ? parseInt(match[1], 10) : null;\n      })\n      .filter(num => num !== null)\n      .sort((a, b) => a - b);\n\n    // Find first missing number starting from 1\n    let nextNum = 1;\n    for (const num of stationNumbers) {\n      if (num === nextNum) {\n        nextNum++;\n      } else if (num > nextNum) {\n        break; // Found a gap\n      }\n    }\n\n    return `GM_Station_${nextNum}`;\n  }\n\n  /**\n   * Select discovered server and pre-fill connection form\n   */\n  selectServer(url) {\n    document.getElementById('serverUrl').value = url;\n    document.getElementById('discoveryStatus').textContent = '‚úÖ Server selected';\n\n    // Auto-assign station name by querying /api/state\n    this.assignStationName(url);\n  }\n\n  /**\n   * Unified connection form handler\n   */\n  async handleConnectionSubmit(event) {\n    event.preventDefault();\n\n    const serverUrl = document.getElementById('serverUrl').value;\n    const password = document.getElementById('gmPassword').value;\n    const statusDiv = document.getElementById('connectionStatusMsg');\n\n    // Read device ID from display element's dataset (not input field)\n    const stationNameDisplay = document.getElementById('stationNameDisplay');\n    const deviceId = stationNameDisplay ? stationNameDisplay.dataset.deviceId : null;\n\n    // Validate inputs\n    if (!serverUrl || !deviceId || !password) {\n      statusDiv.textContent = '‚ö†Ô∏è Please fill in all fields';\n      statusDiv.style.color = '#ff9800';\n      return;\n    }\n\n    statusDiv.textContent = '‚è≥ Connecting...';\n    statusDiv.style.color = '#2196F3';\n\n    try {\n      // Normalize URL - add http:// if no protocol specified\n      let normalizedUrl = serverUrl.trim();\n      if (!normalizedUrl.match(/^https?:\\/\\//i)) {\n        normalizedUrl = `http://${normalizedUrl}`;\n        statusDiv.textContent = `üîß Using ${normalizedUrl}`;\n      }\n\n      // 1. Test server reachability (use orchestrator health endpoint)\n      const healthCheck = await fetch(`${normalizedUrl}/health`, {\n        method: 'GET',\n        mode: 'cors',\n        signal: AbortSignal.timeout(3000)\n      });\n\n      if (!healthCheck.ok) {\n        throw new Error('Server not responding');\n      }\n\n      // 2. Authenticate\n      const authResponse = await fetch(`${normalizedUrl}/api/admin/auth`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ password })\n      });\n\n      if (!authResponse.ok) {\n        statusDiv.textContent = '‚ùå Invalid password';\n        statusDiv.style.color = '#f44336';\n        return;\n      }\n\n      const { token } = await authResponse.json();\n\n      // 3. Save configuration to localStorage\n      localStorage.setItem('aln_orchestrator_url', normalizedUrl);\n      localStorage.setItem('aln_auth_token', token);\n      localStorage.setItem('aln_station_name', deviceId);\n\n      // Set device ID in Settings (deviceId is already in correct format: GM_Station_N)\n      const settings = this.app.settings;\n      settings.deviceId = deviceId;\n      settings.stationName = deviceId;\n      settings.save();\n\n      // Update localStorage counter for next session\n      const match = deviceId.match(/GM_Station_(\\d+)$/);\n      if (match) {\n        const nextNum = parseInt(match[1], 10) + 1;\n        localStorage.setItem('lastStationNum', nextNum.toString());\n      }\n\n      // 4. Trigger networked mode initialization via App (event-driven pattern)\n      // Per Architecture Refactoring 2025-11: App creates NetworkedSession, not wizard\n      statusDiv.textContent = '‚úÖ Authenticated! Connecting...';\n      statusDiv.style.color = '#4CAF50';\n\n      // Delegate to App.selectGameMode() for proper event-driven initialization:\n      // - App will lock mode via SessionModeManager\n      // - App will create NetworkedSession with services\n      // - NetworkedSession will emit session:ready event\n      // - App's session:ready listener will initialize admin modules\n      // - App will close modal and show team entry screen\n      await this.app.selectGameMode('networked');\n\n      // Success handled by App's session:ready event listener\n      // (Modal close and UI transition happen in App._initializeNetworkedMode)\n\n    } catch (error) {\n      statusDiv.textContent = `‚ùå Connection failed: ${error.message}`;\n      statusDiv.style.color = '#f44336';\n    }\n  }\n\n  /**\n   * Cancel networked mode and return to game mode selection\n   */\n  cancelNetworkedMode() {\n    // Close the connection modal\n    document.getElementById('connectionModal').style.display = 'none';\n\n    // Clear the session mode manager's lock so user can choose again\n    const sessionModeManager = this.app.sessionModeManager;\n    if (sessionModeManager) {\n      sessionModeManager.clearMode();\n    }\n\n    // Return to game mode selection screen\n    this.app.uiManager.showScreen('gameModeScreen');\n  }\n\n  /**\n   * Show connection wizard modal\n   */\n  showConnectionWizard() {\n    const modal = document.getElementById('connectionModal');\n    modal.style.display = 'flex';\n\n    // Auto-scan on open for better UX (but don't block)\n    setTimeout(() => this.scanForServers(), 100);\n  }\n\n}\n\n/**\n * Queue Status Indicator Manager\n * Manages the offline queue UI indicator with event-driven updates\n */\nexport class QueueStatusManager {\n  constructor(app) {\n    this.app = app;\n    this.updateQueueIndicator = this.updateQueueIndicator.bind(this);\n  }\n\n  /**\n   * Initialize queue status indicator with event listeners\n   */\n  init() {\n    this.updateQueueIndicator(); // Initial update\n\n    // Register event listener for queue changes (no polling)\n    const queueManager = this.app.networkedSession?.services?.queueManager;\n    if (queueManager) {\n      queueManager.addEventListener('queue:changed', (event) => {\n        console.log('Queue changed:', event.detail);\n        this.updateQueueIndicator();\n      });\n    }\n  }\n\n  /**\n   * Update the queue status indicator with current queue count\n   * P2.2.3: Event-driven updates (no polling)\n   */\n  updateQueueIndicator() {\n    const indicator = document.getElementById('queueStatusIndicator');\n    const countSpan = document.getElementById('queueCount');\n\n    if (!indicator || !countSpan) return;\n\n    // Get queue count from NetworkedQueueManager\n    const queueManager = this.app.networkedSession?.services?.queueManager;\n    const queueStatus = queueManager?.getStatus();\n    const queueCount = queueStatus ? queueStatus.queuedCount : 0;\n\n    countSpan.textContent = queueCount;\n    indicator.classList.toggle('visible', queueCount > 0);\n  }\n}\n\n/**\n * Cleanup handler for page unload\n * Ensures graceful disconnect when page is closing\n */\nexport function setupCleanupHandlers(app) {\n  window.addEventListener('beforeunload', () => {\n    if (app.networkedSession?.services?.client) {\n      console.log('Page unloading - disconnecting socket');\n      app.networkedSession.services.client.disconnect();\n    }\n  });\n}\n","/**\n * DOM Event Bindings\n * Replaces HTML onclick handlers with proper event listeners\n *\n * This module implements event delegation to handle button clicks without\n * exposing global window.App, window.DataManager, etc.\n */\n\nexport function bindDOMEvents(app, dataManager, settings, debug, uiManager, connectionWizard, queueStatusManager) {\n\n  /**\n   * Handle admin.* actions ‚Äî routes to AdminController modules\n   * AdminController is accessed lazily via networkedSession (created after connection)\n   */\n  function handleAdminAction(method, actionElement) {\n    const adminController = app.networkedSession?.getService('adminController');\n    if (!adminController?.initialized) {\n      debug.log('Admin action ignored: admin not initialized', true);\n      return;\n    }\n\n    switch (method) {\n      case 'startGame':\n        adminController.getModule('sessionManager').startGame();\n        break;\n      case 'fireCue': {\n        const cueId = actionElement.dataset.cueId;\n        if (cueId) {\n          adminController.getModule('cueController').fireCue(cueId);\n        }\n        break;\n      }\n      case 'enableCue': {\n        const cueId = actionElement.dataset.cueId;\n        if (cueId) {\n          adminController.getModule('cueController').enableCue(cueId);\n        }\n        break;\n      }\n      case 'disableCue': {\n        const cueId = actionElement.dataset.cueId;\n        if (cueId) {\n          adminController.getModule('cueController').disableCue(cueId);\n        }\n        break;\n      }\n      case 'pauseCue': {\n        const cueId = actionElement.dataset.cueId;\n        if (cueId) {\n          adminController.getModule('cueController').pauseCue(cueId);\n        }\n        break;\n      }\n      case 'stopCue': {\n        const cueId = actionElement.dataset.cueId;\n        if (cueId) {\n          adminController.getModule('cueController').stopCue(cueId);\n        }\n        break;\n      }\n      case 'resumeCue': {\n        const cueId = actionElement.dataset.cueId;\n        if (cueId) {\n          adminController.getModule('cueController').resumeCue(cueId);\n        }\n        break;\n      }\n      case 'resolveConflictCue': {\n        const cueId = actionElement.dataset.cueId;\n        const decision = actionElement.dataset.decision;\n        if (cueId && decision) {\n          adminController.getModule('cueController').resolveConflict(cueId, decision);\n        }\n        break;\n      }\n      case 'spotifyPlay':\n        adminController.getModule('spotifyController').play();\n        break;\n      case 'spotifyPause':\n        adminController.getModule('spotifyController').pause();\n        break;\n      case 'spotifyNext':\n        adminController.getModule('spotifyController').next();\n        break;\n      case 'spotifyPrevious':\n        adminController.getModule('spotifyController').previous();\n        break;\n      case 'startBtScan':\n        adminController.getModule('bluetoothController').startScan();\n        break;\n      case 'stopBtScan':\n        adminController.getModule('bluetoothController').stopScan();\n        break;\n      case 'pairBtDevice': {\n        const address = actionElement.dataset.btAddress;\n        if (address) adminController.getModule('bluetoothController').pairDevice(address);\n        break;\n      }\n      case 'connectBtDevice': {\n        const address = actionElement.dataset.btAddress;\n        if (address) adminController.getModule('bluetoothController').connectDevice(address);\n        break;\n      }\n      case 'disconnectBtDevice': {\n        const address = actionElement.dataset.btAddress;\n        if (address) adminController.getModule('bluetoothController').disconnectDevice(address);\n        break;\n      }\n      case 'setAudioRoute': {\n        const stream = actionElement.dataset.stream || 'video';\n        const sink = actionElement.value;\n        adminController.getModule('audioController').setVideoOutput(sink, stream);\n        break;\n      }\n      case 'lightingRetry':\n        adminController.getModule('lightingController').refreshScenes();\n        break;\n      case 'activateScene': {\n        const sceneId = actionElement.dataset.sceneId;\n        if (sceneId) {\n          adminController.getModule('lightingController').activateScene(sceneId);\n        }\n        break;\n      }\n      default:\n        debug.log(`Unknown admin action: ${method}`, true);\n    }\n  }\n\n  // Event delegation for data-action attributes\n  document.addEventListener('click', (event) => {\n    const actionElement = event.target.closest('[data-action]');\n    if (!actionElement) return;\n\n    // Prevent default action for links (e.g., <a href=\"#\" data-action=\"...\">)\n    if (actionElement.tagName === 'A') {\n      event.preventDefault();\n    }\n\n    const action = actionElement.dataset.action;\n    const arg = actionElement.dataset.arg;\n\n    // Split action into target and method\n    const [target, method] = action.split('.');\n\n    try {\n      switch (target) {\n        case 'app':\n          if (typeof app[method] === 'function') {\n            app[method](arg);\n          } else {\n            debug.log(`Action method not found: app.${method}`, true);\n          }\n          break;\n\n        case 'dataManager':\n          if (typeof dataManager[method] === 'function') {\n            dataManager[method](arg);\n          } else {\n            debug.log(`Action method not found: dataManager.${method}`, true);\n          }\n          break;\n\n        case 'settings':\n          if (typeof settings[method] === 'function') {\n            settings[method](arg);\n          } else {\n            debug.log(`Action method not found: settings.${method}`, true);\n          }\n          break;\n\n        case 'debug':\n          if (typeof debug[method] === 'function') {\n            debug[method](arg);\n          } else {\n            debug.log(`Action method not found: debug.${method}`, true);\n          }\n          break;\n\n        case 'uiManager':\n          if (typeof uiManager[method] === 'function') {\n            uiManager[method](arg);\n          } else {\n            debug.log(`Action method not found: uiManager.${method}`, true);\n          }\n          break;\n\n        case 'connectionWizard':\n          if (typeof connectionWizard[method] === 'function') {\n            connectionWizard[method](arg);\n          } else {\n            debug.log(`Action method not found: connectionWizard.${method}`, true);\n          }\n          break;\n\n        case 'queueStatusManager':\n          if (typeof queueStatusManager[method] === 'function') {\n            queueStatusManager[method](arg);\n          } else {\n            debug.log(`Action method not found: queueStatusManager.${method}`, true);\n          }\n          break;\n\n        case 'admin':\n          handleAdminAction(method, actionElement);\n          break;\n\n        default:\n          debug.log(`Unknown action target: ${target}`, true);\n      }\n    } catch (error) {\n      debug.log(`Action handler error: ${action} - ${error.message}`, true);\n      console.error(`Action handler error: ${action}`, error);\n    }\n  });\n\n  // Handle change events for radio/checkbox inputs with data-action\n  // (clicking label text triggers change on the input, but click event\n  // targets the label/span ‚Äî closest('[data-action]') won't find the input)\n  document.addEventListener('change', (event) => {\n    const actionElement = event.target.closest('[data-action]');\n    if (!actionElement) return;\n\n    const action = actionElement.dataset.action;\n    const [target, method] = action.split('.');\n\n    try {\n      if (target === 'admin') {\n        handleAdminAction(method, actionElement);\n      }\n    } catch (error) {\n      debug.log(`Action handler error: ${action} - ${error.message}`, true);\n      console.error(`Action handler error: ${action}`, error);\n    }\n  });\n}\n","/**\n * ScreenUpdateManager - Centralized Event-to-Screen Update Routing\n *\n * Phase 3: Event Architecture Standardization\n *\n * Problem Solved:\n * - Eliminates repetitive screen visibility checks scattered in main.js\n * - Removes window.__app hack by providing proper app context injection\n * - Creates consistent, declarative pattern for screen updates\n * - Makes it easy to add new screens or events\n *\n * Architecture:\n * - Global handlers: Run on EVERY event regardless of active screen\n * - Screen handlers: Run ONLY when that screen is active\n * - App context: Injected reference to App instance (replaces window.__app)\n *\n * Usage:\n *   const manager = new ScreenUpdateManager({ uiManager, dataManager, debug });\n *   manager.setAppContext(app);\n *\n *   manager.registerGlobalHandler('transaction:added', () => {\n *     uiManager.updateHistoryBadge();\n *   });\n *\n *   manager.registerScreen('history', {\n *     'transaction:added': () => uiManager.renderGameActivity(container)\n *   });\n *\n *   // Wire to DataManager\n *   DataManager.addEventListener('transaction:added', (e) =>\n *     manager.onDataUpdate('transaction:added', e.detail)\n *   );\n */\n\nexport class ScreenUpdateManager {\n  /**\n   * Create ScreenUpdateManager instance\n   * @param {Object} options - Dependency injection\n   * @param {Object} options.uiManager - UIManager instance for rendering\n   * @param {Object} options.dataManager - DataManager instance for data queries\n   * @param {Object} options.debug - Debug instance for logging\n   */\n  constructor({ uiManager, dataManager, debug } = {}) {\n    this.uiManager = uiManager;\n    this.dataManager = dataManager;\n    this.debug = debug;\n\n    // App context - set via setAppContext() after App is created\n    this.appContext = null;\n\n    // Global handlers: eventType -> [handler, handler, ...]\n    this.globalHandlers = {};\n\n    // Screen handlers: screenId -> { eventType: handler, ... }\n    this.screenHandlers = new Map();\n\n    // Container handlers: containerId -> { eventType: handler, ... }\n    // Always run if container element exists in DOM (regardless of active screen)\n    this.containerHandlers = {};\n\n    // Track connected data sources for cleanup (hot-reload, unmount)\n    // Map<dataSource, Map<eventType, boundHandler>>\n    this.connectedSources = new Map();\n  }\n\n  /**\n   * Set the App context for handlers that need app state\n   * Replaces the window.__app hack\n   * @param {Object} app - App instance\n   */\n  setAppContext(app) {\n    this.appContext = app;\n    this.debug?.log('[ScreenUpdateManager] App context set');\n  }\n\n  /**\n   * Register a global handler that runs on every event\n   * regardless of which screen is active\n   *\n   * NOTE: Global handlers run in registration order. If handlers have\n   * dependencies on each other, register them in the correct sequence.\n   *\n   * @param {string} eventType - Event name (e.g., 'transaction:added')\n   * @param {Function} handler - Handler function(eventData)\n   *   - eventData may be undefined; use defensive destructuring if needed\n   */\n  registerGlobalHandler(eventType, handler) {\n    if (!this.globalHandlers[eventType]) {\n      this.globalHandlers[eventType] = [];\n    }\n    this.globalHandlers[eventType].push(handler);\n    this.debug?.log(`[ScreenUpdateManager] Registered global handler for ${eventType}`);\n  }\n\n  /**\n   * Register screen-specific handlers\n   * @param {string} screenId - Screen identifier (without 'Screen' suffix, e.g., 'history')\n   * @param {Object} handlers - Map of eventType -> handler function\n   *   Handler signature: (eventData, appContext) => void\n   *   - eventData may be undefined; use defensive destructuring: `const { prop } = eventData || {}`\n   *   - appContext is the App instance (set via setAppContext)\n   * @throws {TypeError} If handlers is not a plain object\n   */\n  registerScreen(screenId, handlers) {\n    // Type safety: validate handlers is an object\n    if (!handlers || typeof handlers !== 'object' || Array.isArray(handlers)) {\n      throw new TypeError(\n        `[ScreenUpdateManager] registerScreen('${screenId}'): handlers must be an object, got ${typeof handlers}`\n      );\n    }\n    this.screenHandlers.set(screenId, handlers);\n    const eventTypes = Object.keys(handlers).join(', ');\n    this.debug?.log(`[ScreenUpdateManager] Registered screen '${screenId}' for events: ${eventTypes}`);\n  }\n\n  /**\n   * Register container-specific handlers\n   * Container handlers run for ANY container that exists in DOM, regardless of active screen.\n   * Use for UI elements that should update globally (scoreboards, transaction logs, etc.)\n   *\n   * @param {string} containerId - DOM element ID (e.g., 'scoreboardContainer', 'admin-score-board')\n   * @param {Object} handlers - Map of eventType -> handler function\n   *   Handler signature: (eventData, containerElement) => void\n   */\n  registerContainer(containerId, handlers) {\n    this.containerHandlers[containerId] = handlers;\n    const eventTypes = Object.keys(handlers).join(', ');\n    this.debug?.log(`[ScreenUpdateManager] Registered container '${containerId}' for events: ${eventTypes}`);\n  }\n\n  /**\n   * Get the currently active screen ID\n   * @returns {string|null} Screen ID without 'Screen' suffix, or null\n   */\n  getActiveScreenId() {\n    const activeScreen = document.querySelector('.screen.active');\n    if (!activeScreen) return null;\n\n    const screenId = activeScreen.id;\n\n    // Validate expected pattern: screen IDs should end with 'Screen' suffix\n    if (!screenId.endsWith('Screen')) {\n      console.warn(\n        `[ScreenUpdateManager] Unexpected screen ID pattern: '${screenId}' ` +\n        `(expected 'xxxScreen' format). Screen handlers may not work correctly.`\n      );\n      return screenId; // Return as-is for best-effort handling\n    }\n\n    // Convert 'historyScreen' -> 'history'\n    return screenId.replace('Screen', '');\n  }\n\n  /**\n   * Handle a data update event\n   * 1. Run all global handlers for this event type\n   * 2. Run container handlers for any container that exists in DOM\n   * 3. If active screen has a handler for this event, run it\n   *\n   * @param {string} eventType - Event name (e.g., 'transaction:added')\n   * @param {*} eventData - Event payload (from CustomEvent.detail)\n   */\n  onDataUpdate(eventType, eventData) {\n    this.debug?.log(`[ScreenUpdateManager] ${eventType} event received`);\n\n    // Step 1: Run global handlers (always, in registration order)\n    const globals = this.globalHandlers[eventType] || [];\n    for (const handler of globals) {\n      try {\n        handler(eventData);\n      } catch (error) {\n        console.error(`[ScreenUpdateManager] Global handler error for ${eventType}:`, error);\n      }\n    }\n\n    // Step 2: Run container handlers (for any container that exists in DOM)\n    for (const [containerId, handlers] of Object.entries(this.containerHandlers)) {\n      const container = document.getElementById(containerId);\n      if (container && handlers[eventType]) {\n        try {\n          handlers[eventType](eventData, container);\n        } catch (error) {\n          console.error(`[ScreenUpdateManager] Container handler error for ${containerId}/${eventType}:`, error);\n        }\n      }\n    }\n\n    // Step 3: Run screen-specific handler (if active)\n    const activeScreenId = this.getActiveScreenId();\n    if (!activeScreenId) {\n      this.debug?.log('[ScreenUpdateManager] No active screen, skipping screen handler');\n      return;\n    }\n\n    const screenHandlers = this.screenHandlers.get(activeScreenId);\n    const screenHandler = screenHandlers?.[eventType];\n\n    if (screenHandler) {\n      this.debug?.log(`[ScreenUpdateManager] Running ${eventType} handler for screen '${activeScreenId}'`);\n      try {\n        // Pass both eventData and appContext to handler\n        screenHandler(eventData, this.appContext);\n      } catch (error) {\n        console.error(`[ScreenUpdateManager] Screen handler error for ${activeScreenId}/${eventType}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Connect this manager to a DataManager (or StandaloneDataManager)\n   * Convenience method to wire all events at once\n   * @param {EventTarget} dataSource - DataManager or StandaloneDataManager\n   * @param {string[]} eventTypes - Array of event types to listen for\n   */\n  connectToDataSource(dataSource, eventTypes) {\n    // Initialize listener map for this source if not present\n    if (!this.connectedSources.has(dataSource)) {\n      this.connectedSources.set(dataSource, new Map());\n    }\n    const sourceListeners = this.connectedSources.get(dataSource);\n\n    for (const eventType of eventTypes) {\n      // Create and store bound handler for cleanup\n      const boundHandler = (event) => {\n        this.onDataUpdate(eventType, event.detail);\n      };\n      sourceListeners.set(eventType, boundHandler);\n      dataSource.addEventListener(eventType, boundHandler);\n    }\n    this.debug?.log(`[ScreenUpdateManager] Connected to data source for events: ${eventTypes.join(', ')}`);\n  }\n\n  /**\n   * Disconnect from a data source - removes all event listeners\n   * Use for cleanup in hot-reloading scenarios or component unmount\n   * @param {EventTarget} dataSource - DataManager or StandaloneDataManager to disconnect\n   */\n  disconnectFromDataSource(dataSource) {\n    const sourceListeners = this.connectedSources.get(dataSource);\n    if (!sourceListeners) {\n      this.debug?.log('[ScreenUpdateManager] No listeners found for data source, skipping disconnect');\n      return;\n    }\n\n    for (const [eventType, handler] of sourceListeners) {\n      dataSource.removeEventListener(eventType, handler);\n    }\n\n    this.connectedSources.delete(dataSource);\n    this.debug?.log(`[ScreenUpdateManager] Disconnected from data source (${sourceListeners.size} listeners removed)`);\n  }\n\n  /**\n   * Disconnect from all data sources - full cleanup\n   * Use when tearing down the entire ScreenUpdateManager\n   */\n  disconnectAll() {\n    for (const dataSource of this.connectedSources.keys()) {\n      this.disconnectFromDataSource(dataSource);\n    }\n    this.debug?.log('[ScreenUpdateManager] Disconnected from all data sources');\n  }\n}\n\nexport default ScreenUpdateManager;\n","/**\n * ALNScanner - Main Entry Point\n * ES6 Module Architecture\n *\n * This file orchestrates the application initialization in the new\n * ES6 module architecture with Vite build system.\n *\n * Architecture:\n * - Import all modules (singleton instances)\n * - Create App with dependency injection\n * - Initialize application\n * - Expose minimal window globals for HTML onclick handlers (temporary until Phase 9)\n *\n * Phase 3 Changes:\n * - Introduced ScreenUpdateManager for centralized event-to-screen routing\n * - Removed window.__app hack (app context passed via ScreenUpdateManager)\n * - Declarative screen update registration\n */\n\n// Import core dependencies\n// Note: Debug, Settings, TokenManager, NFCHandler, CONFIG are singletons (pre-created instances)\n// Note: UnifiedDataManager, UIManager are classes (instances created below with DI)\nimport Debug from './utils/debug.js';\nimport { UIManager as UIManagerClass } from './ui/uiManager.js';\nimport Settings from './ui/settings.js';\nimport TokenManager from './core/tokenManager.js';\nimport { UnifiedDataManager as UnifiedDataManagerClass } from './core/unifiedDataManager.js';\nimport { TeamRegistry as TeamRegistryClass } from './core/teamRegistry.js';\nimport NFCHandler from './utils/nfcHandler.js';\nimport CONFIG from './utils/config.js';\nimport InitializationSteps from './app/initializationSteps.js';\n\n// Import App class\nimport { App } from './app/app.js';\n\n// Import connection wizard and DOM event bindings\nimport { ConnectionWizard, QueueStatusManager, setupCleanupHandlers } from './ui/connectionWizard.js';\nimport { bindDOMEvents } from './utils/domEventBindings.js';\n\n// Import ScreenUpdateManager for centralized event routing (Phase 3)\nimport ScreenUpdateManager from './ui/ScreenUpdateManager.js';\nimport { VideoRenderer } from './ui/renderers/VideoRenderer.js';\n\n/**\n * Create service instances with proper dependency injection\n *\n * Architecture: Event-Driven Coordination (no direct cross-dependencies)\n * - UnifiedDataManager emits events (transaction:added, data:cleared, etc.)\n * - ScreenUpdateManager routes events to appropriate UI updates\n * - Event wiring happens in main.js (centralized)\n *\n * Phase 2: UnifiedDataManager replaces both DataManager and StandaloneDataManager\n * - Single manager with strategy pattern (LocalStorage/NetworkedStorage)\n * - Mode-specific initialization done by App during selectGameMode()\n */\n\n// Create UnifiedDataManager (strategy selected during App initialization)\nconst DataManager = new UnifiedDataManagerClass({\n  tokenManager: TokenManager,\n  sessionModeManager: null, // Set by App during mode selection\n  debug: Debug\n});\n\n// Create TeamRegistry for unified team management (networked + standalone)\nconst TeamRegistry = new TeamRegistryClass();\n\n// Create UIManager with unified DataManager\nconst UIManager = new UIManagerClass({\n  settings: Settings,\n  dataManager: DataManager\n  // sessionModeManager, app set later by App\n});\n\n/**\n * Create ScreenUpdateManager for centralized event-to-screen routing\n * Replaces scattered event handlers with declarative registration\n */\nconst screenUpdateManager = new ScreenUpdateManager({\n  uiManager: UIManager,\n  dataManager: DataManager,\n  debug: Debug\n});\n\n// ============================================================================\n// GLOBAL HANDLERS - Always run regardless of active screen\n// ============================================================================\n\n// Transaction added: Update badge and stats globally\nscreenUpdateManager.registerGlobalHandler('transaction:added', () => {\n  UIManager.updateHistoryBadge();\n  UIManager.updateSessionStats();\n});\n\n// Transaction deleted: Update badge and stats globally\nscreenUpdateManager.registerGlobalHandler('transaction:deleted', () => {\n  UIManager.updateHistoryBadge();\n  UIManager.updateSessionStats();\n});\n\n// Data cleared: Update badge\nscreenUpdateManager.registerGlobalHandler('data:cleared', () => {\n  UIManager.updateHistoryBadge();\n});\n\n// Game state updated: Update badge and stats\nscreenUpdateManager.registerGlobalHandler('game-state:updated', () => {\n  UIManager.updateHistoryBadge();\n  UIManager.updateSessionStats();\n});\n\n\n// ============================================================================\n// SCREEN-SPECIFIC HANDLERS - Only run when that screen is active\n// ============================================================================\n// NOTE: Screen handlers receive (eventData, app). Use defensive destructuring\n// when accessing eventData properties: `const { prop } = eventData || {}`\n\n// History screen: Re-render game activity when data changes\nconst refreshHistoryScreen = (includeStats = true) => {\n  if (includeStats) UIManager.updateHistoryStats();\n  const historyContainer = document.getElementById('historyContainer');\n  if (historyContainer) {\n    UIManager.renderGameActivity(historyContainer, { showSummary: true, showFilters: true });\n  }\n};\n\nscreenUpdateManager.registerScreen('history', {\n  'transaction:added': () => refreshHistoryScreen(),\n  'transaction:deleted': () => refreshHistoryScreen(),\n  'player-scan:added': () => refreshHistoryScreen(false)\n});\n\n// Team details screen: Re-render team data when transactions change\nscreenUpdateManager.registerScreen('teamDetails', {\n  'transaction:added': (_eventData, app) => {\n    // _eventData unused - we fetch fresh data for current team\n    const currentTeamId = app?.currentInterventionTeamId;\n    if (currentTeamId) {\n      Debug.log(`[main.js] Team details active - re-rendering for team ${currentTeamId}`);\n      const transactions = DataManager.getTeamTransactions(currentTeamId);\n      UIManager.renderTeamDetails(currentTeamId, transactions);\n    }\n  },\n  'transaction:deleted': (_eventData, app) => {\n    // _eventData unused - we fetch fresh data for current team\n    const currentTeamId = app?.currentInterventionTeamId;\n    if (currentTeamId) {\n      Debug.log(`[main.js] Team details active - re-rendering after deletion for team ${currentTeamId}`);\n      const transactions = DataManager.getTeamTransactions(currentTeamId);\n      UIManager.renderTeamDetails(currentTeamId, transactions);\n    }\n  },\n  'team-score:updated': (eventData, app) => {\n    // Defensive destructuring for eventData\n    const { teamId, transactions } = eventData || {};\n    const currentTeamId = app?.currentInterventionTeamId;\n    if (currentTeamId && currentTeamId === teamId) {\n      Debug.log(`[main.js] Team details active - score update for team ${teamId}`);\n      UIManager.renderTeamDetails(teamId, transactions);\n    }\n  }\n});\n\n// ============================================================================\n// CONTAINER HANDLERS (run for ANY container present in DOM, regardless of screen)\n// ============================================================================\n\n// Scoreboard containers - both use UIManager.renderScoreboard() for consistent rendering\n// scoreboardContainer: Full scoreboard screen (scanner-view)\n// admin-score-board: Admin panel inline scoreboard (admin-view)\nconst scoreboardContainerHandlers = {\n  'team-score:updated': (_eventData, container) => UIManager.renderScoreboard(container),\n  'scores:cleared': (_eventData, container) => { container.innerHTML = ''; },\n  'data:cleared': (_eventData, container) => { container.innerHTML = ''; }\n};\n\nscreenUpdateManager.registerContainer('scoreboardContainer', scoreboardContainerHandlers);\nscreenUpdateManager.registerContainer('admin-score-board', scoreboardContainerHandlers);\n\n// Game Activity container (admin panel) - unified token lifecycle display\nscreenUpdateManager.registerContainer('admin-game-activity', {\n  'transaction:added': (eventData, container) => {\n    Debug.log('[main.js] Updating admin-game-activity (transaction added)');\n    UIManager.renderGameActivity(container, { showSummary: true, showFilters: true });\n  },\n  'transaction:deleted': (eventData, container) => {\n    Debug.log('[main.js] Updating admin-game-activity (transaction deleted)');\n    UIManager.renderGameActivity(container, { showSummary: true, showFilters: true });\n  },\n  'player-scan:added': (eventData, container) => {\n    Debug.log('[main.js] Updating admin-game-activity (player scan)');\n    UIManager.renderGameActivity(container, { showSummary: true, showFilters: true });\n  },\n  'data:cleared': (eventData, container) => {\n    Debug.log('[main.js] Session reset - clearing admin-game-activity');\n    container.innerHTML = '';\n  }\n});\n\n// Session Status container (admin panel) - Phase 3: Session lifecycle display\nscreenUpdateManager.registerContainer('session-status-container', {\n  'session:updated': (eventData, container) => {\n    Debug.log('[main.js] Updating session-status-container (session updated)');\n    UIManager.renderSessionStatus(container);\n  },\n  'data:cleared': (eventData, container) => {\n    Debug.log('[main.js] Session reset - re-rendering session-status-container');\n    UIManager.renderSessionStatus(container);\n  }\n});\n\n// Video Control Panel (admin panel) - Phase 1: Video State\n// Instantiates VideoRenderer on demand or keeps a reference if needed.\n// Since VideoRenderer captures DOM elements in constructor, we should instantiate it once if DOM is ready,\n// OR instantiate it inside the handler if we want to be safe about DOM presence.\n// Given main.js architecture, we can instantiate it once.\nconst videoRenderer = new VideoRenderer();\nscreenUpdateManager.registerContainer('video-control-panel', {\n  'video-state:updated': (eventData, container) => {\n    // eventData is the video state { nowPlaying, isPlaying, ... }\n    videoRenderer.render(eventData);\n  }\n});\n\n// ============================================================================\n// CONNECT TO DATA SOURCES\n// ============================================================================\n\n// Connect ScreenUpdateManager to UnifiedDataManager events\n// Phase 2: Single connection - UnifiedDataManager emits all events\nscreenUpdateManager.connectToDataSource(DataManager, [\n  'transaction:added',\n  'transaction:deleted',\n  'scores:cleared',\n  'data:cleared',\n  'game-state:updated',\n  'team-score:updated',\n  'player-scan:added',  // Game Activity: token lifecycle tracking\n  'session:updated',     // Phase 3: Session lifecycle events for admin panel\n  'video-state:updated'  // Phase 1: Video state\n]);\n\n/**\n * Create App instance with dependency injection\n * Now using created instances (not pre-created singletons)\n */\nconst app = new App({\n  debug: Debug,\n  uiManager: UIManager,\n  settings: Settings,\n  tokenManager: TokenManager,\n  dataManager: DataManager,\n  teamRegistry: TeamRegistry,\n  nfcHandler: NFCHandler,\n  config: CONFIG,\n  initializationSteps: InitializationSteps\n  // Note: sessionModeManager and networkedSession are set internally by App\n  // during mode selection (see App.selectGameMode)\n});\n\n// Wire app reference for getSessionStats (same pattern as UIManager at app.js:79)\nDataManager.app = app;\n\n// Set app context for screen handlers that need it (replaces window.__app hack)\nscreenUpdateManager.setAppContext(app);\n\n// TeamRegistry dependencies (sessionModeManager, orchestratorClient) are wired\n// by App.selectGameMode() after mode selection - not here in main.js\n// This follows the same pattern as UnifiedDataManager strategy initialization\n\n/**\n * Create connection wizard and queue status manager\n * These handle networked mode connection UI and offline queue indicator\n */\nconst connectionWizard = new ConnectionWizard(app);\nconst queueStatusManager = new QueueStatusManager(app);\n\n/**\n * Inject showConnectionWizard method into app\n * Required by App._initializeNetworkedMode() when no valid auth token exists\n */\napp.showConnectionWizard = connectionWizard.showConnectionWizard.bind(connectionWizard);\n\n/**\n * Bind DOM event handlers using event delegation\n * Replaces window globals and onclick handlers with data-action attributes\n */\nbindDOMEvents(app, DataManager, Settings, Debug, UIManager, connectionWizard, queueStatusManager);\n\n/**\n * Setup cleanup handlers for page unload\n * Ensures graceful disconnect when closing page\n */\nsetupCleanupHandlers(app);\n\n/**\n * Initialize application\n * Runs 11-phase initialization sequence from InitializationSteps\n */\nasync function initializeApp() {\n  Debug.log('=== ALNScanner ES6 Module Architecture ===');\n  Debug.log('Main entry point loaded');\n  Debug.log('Initializing application...');\n\n  try {\n    await app.init();\n    Debug.log('Application initialization complete');\n\n    // Initialize connection wizard (bind form events)\n    connectionWizard.init();\n    Debug.log('Connection wizard initialized');\n\n    // Initialize queue status manager (event-driven updates)\n    queueStatusManager.init();\n    Debug.log('Queue status manager initialized');\n  } catch (error) {\n    Debug.log(`Initialization error: ${error.message}`, true);\n    console.error('App initialization failed:', error);\n\n    // Show error to user\n    if (UIManager) {\n      UIManager.showError(`Failed to initialize: ${error.message}`);\n    }\n  }\n}\n\n/**\n * Start application when DOM is ready\n * Handles both cases: DOM already loaded, or still loading\n */\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', initializeApp);\n} else {\n  // DOM already loaded (module scripts are deferred by default)\n  initializeApp();\n}\n\n/**\n * Export app for console debugging\n * Developers can access via: import('./src/main.js').then(m => m.default)\n */\nexport default app;\n"],"names":["CONFIG","DebugLogger","message","isError","formatted","app","content","Debug","UIManager$1","settings","dataManager","sessionModeManager","container","duration","errorDiv","type","toast","screenName","current","screen","resultScreen","dismissHandler","event","mode","indicator","modeText","toggle","scoreboardButton","teamId","display","dataSource","stats","tokenCount","valueElement","labelElement","badge","count","totalScans","uniqueTeams","totalValue","avgValue","targetContainer","teamScores","scoreSource","team","index","rank","rankClass","medal","session","startTime","ms","seconds","minutes","hours","transactions","enhancedData","scoreData","isNetworked","titleEl","summaryEl","html","group","hasActiveSession","token","backendScore","displayBaseScore","displayBonusScore","displayTotalScore","baseScoreEl","bonusScoreEl","totalScoreEl","adjustmentsSection","adjustments","totalAdjustment","sum","adj","adjHtml","date","interventionControls","hasBonus","isUnknown","showDelete","tokenValue","isDuplicate","cardClass","calculationText","baseValue","multiplier","groupInfo","finalValue","deleteButton","displayValue","data","notification","tokenId","statusEl","rfidEl","typeEl","groupEl","valueEl","summaryContainer","tokenScore","text","div","timestamp","options","showSummary","showFilters","tokens","getLatestTimestamp","a","b","tokenData","events","status","discoveredByPlayers","potentialValue","memoryType","rating","scanEvents","e","hasMultipleScans","claimEvent","statusContent","idx","totalEvents","time","searchInput","filterSelect","cards","searchTerm","filterValue","card","matchesSearch","matchesFilter","Settings","oldDeviceId","oldMode","deviceIdDisplay","TokenManagerClass","helpers","response","error","groups","issues","rfid","normalizedName","issue","groupString","match","name","completableGroups","g","singleTokenGroups","id","normalizedInput","dbKey","normalizedDbKey","TokenManager","IStorageStrategy","transaction","transactionId","delta","reason","teams","SCORING_CONFIG","sharedConfig","k","v","parseGroupInfo","groupName","trimmed","normalizeGroupName","calculateTokenValue","buildGameActivity","playerScans","tokenManager","transactionFilter","pointsFallback","tokenMap","scan","tx","activity","lookedUpToken","points","t","LocalStorage","debug","saved","parsed","sessionDate","today","groupTxs","groupTokens","scannedIds","groupBaseScore","bonus","removedTx","adjustment","NetworkedStorage","socket","score","teamIds","scans","sessionId","UnifiedDataManager","actualSocket","strategy","listeners","eventName","handler","calcTokenValue","parseGroup","sharedNormalizeGroupName","groupInventory","completedGroups","completedGroupNames","groupBonusData","completedGroupTokens","incompleteGroupTokens","ungroupedTokens","unknownTokens","normalizedGroupName","groupData","completedGroupsArray","incompleteGroupsArray","baseScore","bonusScore","groupBreakdown","tokenBaseValue","bonusAmount","currentTeamId","teamTransactions","totalScore","s","total","blackMarketScore","ts","known","payload","playerScan","newState","resetTeamIds","cues","cue","cueId","state","enabled","lighting","changed","device","btState","d","teamInfo","normalizedId","existingTeam","removed","sessionData","standaloneSessionData","teamData","selectElement","placeholder","selectedTeamId","placeholderOption","option","teamName","normalized","result","recent","limited","NFCHandlerClass","onRead","onError","serialNumber","now","debounceKey","record","url","testIds","randomId","NFCHandler","isTokenValid","parts","str","StateValidationService","orchestratorUrl","validateToken","controller","timeoutId","stateValidationService","initializeUIManager","uiManager","createSessionModeManager","SessionModeManagerClass","instance","initializeViewController","viewController","loadSettings","loadDataManager","detectNFCSupport","nfcHandler","supported","registerServiceWorker","navigatorObj","swPath","registration","loadTokenDatabase","errorMsg","applyURLModeOverride","locationSearch","modeParam","determineInitialScreen","savedMode","validateAndDetermineInitialScreen","validationResult","applyInitialScreenDecision","decision","showWizardFn","initNetworkedModeFn","showLoadingScreen","resolve","InitializationSteps","SessionModeManager","OrchestratorClient","config","auth","reject","onConnect","eventType","action","timeout","cleanup","envelope","ConnectionManager","delay","statusElement","textElement","statusText","NetworkedQueueManager","batch","results","i","successCount","r","failCount","handlerKey","key","sendCommand","connection","ackHandler","SessionManager","VideoController","videoFile","fromIndex","toIndex","DisplayController","SystemMonitor","baseUrl","AdminOperations","CueRenderer","elements","cuesMap","quickFireCues","icon","label","disabledCuesSet","standingCues","isDisabled","statusClass","triggerLabel","activeCuesMap","entries","details","progress","progressPercent","isPaused","cueDef","cueLabel","currentVideo","autoCancelMs","banner","EnvironmentRenderer","lightingState","connected","activeScene","scenes","scene","isActive","safeId","safeName","audioState","routes","availableSinks","stream","sink","dropdown","newSinks","sinks","streams","scanning","foundedDevices","connectedDevices","allDevices","ad","safeAddress","isConnected","isPaired","itemClass","actionBtn","SessionRenderer","sessionState","viewState","nameEl","clockState","elapsed","formattedTime","overtimeData","m","sessionName","VideoRenderer","nowPlaying","isPlaying","percent","queueItems","item","countEl","pendingCountEl","MonitoringDisplay","client","teamRegistry","log","el","txTime","nowShowingVal","nowShowingIcon","btnIdle","btnScore","returnsContainer","returnsMode","pendingCount","btWarning","spotifyState","section","playPauseBtn","syncData","c","vlcElem","devices","listEl","orchestratorElem","secondsSeconds","totalSeconds","h","colors","BluetoothController","address","AudioController","LightingController","sceneId","CueController","SoundController","file","target","volume","SpotifyController","uri","AdminController","module","NetworkedSession","newSessionId","currentSessionId","App","dependencies","UIManager","screenDecision","formattedBonus","viewSelector","viewName","view","selectedView","tab","activeTab","adminController","scanScreen","teamInput","teamList","listLabel","list","currentTeamEl","sessionContainer","deviceId","connectionModal","err","cleanId","txId","historyContainer","targetScreen","endTime","days","input","filename","gameActivityContainer","scoreBoard","deltaInput","reasonInput","displayController","ConnectionWizard","connectionForm","statusDiv","serversDiv","btn","currentHost","subnet","commonPorts","protocol","promises","port","foundServers","servers","server","serverEl","serverUrlInput","debounceTimer","DEBOUNCE_MS","normalizedUrl","serverUrl","stationNameDisplay","existingIds","nextStationId","fallbackId","stationNumbers","num","nextNum","password","authResponse","modal","QueueStatusManager","queueManager","countSpan","queueStatus","queueCount","setupCleanupHandlers","bindDOMEvents","connectionWizard","queueStatusManager","handleAdminAction","method","actionElement","arg","ScreenUpdateManager","screenId","handlers","eventTypes","containerId","activeScreen","eventData","globals","activeScreenId","screenHandler","sourceListeners","boundHandler","DataManager","UnifiedDataManagerClass","TeamRegistry","TeamRegistryClass","UIManagerClass","screenUpdateManager","refreshHistoryScreen","includeStats","_eventData","scoreboardContainerHandlers","videoRenderer","initializeApp"],"mappings":"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"}